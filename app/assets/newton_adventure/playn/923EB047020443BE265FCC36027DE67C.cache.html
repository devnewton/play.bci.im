<html>
<head><meta charset="UTF-8" /><script>
var $gwt_version = "2.5.0";
var $wnd = parent;
var $doc = $wnd.document;
var $moduleName, $moduleBase;
var $strongName = '923EB047020443BE265FCC36027DE67C';
var $stats = $wnd.__gwtStatsEvent ? function(a) {return $wnd.__gwtStatsEvent(a);} : null,
$sessionId = $wnd.__gwtStatsSessionId ? $wnd.__gwtStatsSessionId : null;
$stats && $stats({moduleName:'playn',sessionId:$sessionId,subSystem:'startup',evtGroup:'moduleStartup',millis:(new Date()).getTime(),type:'moduleEvalStart'});
</script></head>
<body>
<script><!--
var _, N81_longLit = {l:4194175, m:4194303, h:1048575}, N1_longLit = {l:4194303, m:4194303, h:1048575}, P0_longLit = {l:0, m:0, h:0}, P1_longLit = {l:1, m:0, h:0}, Pa_longLit = {l:10, m:0, h:0}, P3c_longLit = {l:60, m:0, h:0}, P64_longLit = {l:100, m:0, h:0}, P80_longLit = {l:128, m:0, h:0}, Pf4240_longLit = {l:1000000, m:0, h:0}, Pfe502a_longLit = {l:4083754, m:3, h:0}, P27bc86a_longLit = {l:3917930, m:9, h:0}, P11e1a300_longLit = {l:2204416, m:71, h:0}, P17d78400_longLit = {l:1541120, m:95, h:0}, P1dcd6500_longLit = {l:877824, m:119, h:0}, P3b9aca00_longLit = {l:1755648, m:238, h:0}, P540be400_longLit = {l:779264, m:336, h:0}, P77359400_longLit = {l:3511296, m:476, h:0}, P7fffffff_longLit = {l:4194303, m:511, h:0}, Pb2d05e00_longLit = {l:1072640, m:715, h:0}, Pee6b2800_longLit = {l:2828288, m:953, h:0}, P12a05f200_longLit = {l:389632, m:1192, h:0}, P2540be400_longLit = {l:779264, m:2384, h:0}, Pdf8475800_longLit = {l:481280, m:14305, h:0}, P7fffffffffffffff_longLit = {l:4194303, m:4194303, h:524287}, seedTable = {}, Q$Object = 0, Q$String = 1, Q$Sound$LoadState = 2, Q$SoundController$MimeTypeSupport = 3, Q$SoundType = 4, Q$XmlParseException = 5, Q$XmlParser$AttrActions = 6, Q$XmlParser$StringPair = 7, Q$XmlParser$TagContentActions = 8, Q$XmlParser$TagHeaderActions = 9, Q$Context2d$Repetition = 10, Q$Context2d$TextBaseline = 11, Q$JavaScriptException = 12, Q$Style$FontStyle = 13, Q$Style$FontWeight = 14, Q$Style$HasCssName = 15, Q$Style$Overflow = 16, Q$Style$Position = 17, Q$Style$Unit = 18, Q$Style$Visibility = 19, Q$Style$WhiteSpace = 20, Q$HasAttachHandlers = 21, Q$HasHandlers = 22, Q$LongLibBase$LongEmul = 23, Q$EventListener = 24, Q$HasVisibility = 25, Q$IsWidget = 26, Q$UIObject = 27, Q$Widget = 28, Q$UmbrellaException = 29, Q$NuitLocale = 30, Q$Action = 31, Q$Control = 32, Q$VideoResolution = 33, Q$Drawable = 34, Q$LevelSequence = 35, Q$PreloadableSequence = 36, Q$Sequence$NormalTransitionException = 37, Q$Sequence$ResumableTransitionException = 38, Q$Sequence$ResumeTransitionException = 39, Q$Updatable = 40, Q$SnowLayer$SnowFlake = 41, Q$NewtonColor = 42, Q$AnimatedPlatform = 43, Q$Apple = 44, Q$Blocker = 45, Q$BossHand$Side = 46, Q$Cannon$Orientation = 47, Q$Coin = 48, Q$CollisionDetectionOnly = 49, Q$Compass = 50, Q$Door = 51, Q$DoorToBonusWorld = 52, Q$FireBall = 53, Q$GameOverException = 54, Q$Hero = 55, Q$Key = 56, Q$KeyLock = 57, Q$MemoryActivator = 58, Q$PikesComponent$DangerousSide = 59, Q$StaticPlatform = 60, Q$Teleporter = 61, Q$WorldMap = 62, Q$TmxMapOrientation = 63, Q$TmxTileInstance = 64, Q$TmxTileInstanceEffect = 65, Q$TmxTileInstance_$1 = 66, Q$int_$1 = 67, Q$Serializable = 68, Q$Boolean = 69, Q$CharSequence = 70, Q$Comparable = 71, Q$Double = 72, Q$Enum = 73, Q$Exception = 74, Q$Float = 75, Q$Integer = 76, Q$Long = 77, Q$Number = 78, Q$Object_$1 = 79, Q$RuntimeException = 80, Q$StackTraceElement = 81, Q$Throwable = 82, Q$ByteBuffer = 83, Q$FloatBuffer = 84, Q$ShortBuffer = 85, Q$Date = 86, Q$List = 87, Q$Map = 88, Q$Map$Entry = 89, Q$NoSuchElementException = 90, Q$Set = 91, Q$TreeMap$Node = 92, Q$TreeMap$SubMapType = 93, Q$ROVector2f = 94, Q$Vector2f = 95, Q$CollisionEvent = 96, Q$Contact = 97, Q$StaticBody = 98, Q$BoxBoxCollider$ClipVertex = 99, Q$ColliderUnavailableException = 100, Q$FeaturePair = 101, Q$Intersection = 102, Q$IntersectionGatherer$SortableIntersection = 103, Q$Intersection_$1 = 104, Q$AbstractShape = 105, Q$Box = 106, Q$Circle = 107, Q$ConvexPolygon = 108, Q$DynamicShape = 109, Q$Line = 110, Q$Polygon = 111, Q$Shape = 112, Q$AbstractFont = 113, Q$AbstractLayer$Flag = 114, Q$Events$Input = 115, Q$Events$Input$Impl = 116, Q$Events$Position = 117, Q$Events$Position$Impl = 118, Q$Font$Style = 119, Q$Key_0 = 120, Q$Log$Level = 121, Q$TextFormat = 122, Q$TextFormat$Alignment = 123, Q$Touch$Event = 124, Q$Touch$Event$Impl = 125, Q$HasArrayBufferView = 126, Q$HtmlGL20$VertexAttribArrayState = 127, Q$HtmlGL20$WebGLObjectType = 128, Q$AbstractDimension = 129, Q$AbstractPoint = 130, Q$AbstractRectangle = 131, Q$AbstractVector = 132, Q$NoninvertibleTransformException = 133, CM$ = {};
function newSeed(id){
  return new seedTable[id];
}

function defineSeed(id, superSeed, castableTypeMap){
  var seed = seedTable[id];
  if (seed && !seed.___clazz$) {
    _ = seed.prototype;
  }
   else {
    !seed && (seed = seedTable[id] = function(){
    }
    );
    _ = seed.prototype = superSeed < 0?{}:newSeed(superSeed);
    _.castableTypeMap$ = castableTypeMap;
  }
  for (var i = 3; i < arguments.length; ++i) {
    arguments[i].prototype = _;
  }
  if (seed.___clazz$) {
    _.___clazz$ = seed.___clazz$;
    seed.___clazz$ = null;
  }
}

function makeCastMap(a){
  var result = {};
  for (var i = 0, c = a.length; i < c; ++i) {
    result[a[i]] = 1;
  }
  return result;
}

function nullMethod(){
}

defineSeed(1, -1, CM$);
_.equals$ = function equals(other){
  return this === other;
}
;
_.getClass$ = function getClass_0(){
  return this.___clazz$;
}
;
_.hashCode$ = function hashCode_0(){
  return getHashCode(this);
}
;
_.toString$ = function toString_0(){
  return this.___clazz$.typeName + '@' + toPowerOfTwoString(this.hashCode$());
}
;
_.toString = function(){
  return this.toString$();
}
;
_.typeMarker$ = nullMethod;
function $clinit_AbstractSound(){
  $clinit_AbstractSound = nullMethod;
  INITIAL_LOAD_STATE = ($clinit_Sound$LoadState() , LOAD_STATE_UNINITIALIZED);
}

function $addEventHandler(this$static, handler){
  $add_0(this$static.soundHandlerCollection, handler);
  this$static.loadState != INITIAL_LOAD_STATE && $onSoundLoadStateChange(handler, new SoundLoadStateChangeEvent_0(this$static));
}

function $setLoadState(this$static, loadState){
  if (loadState != this$static.loadState) {
    this$static.loadState = loadState;
    loadState != INITIAL_LOAD_STATE && $fireOnSoundLoadStateChange(this$static.soundHandlerCollection, this$static);
  }
}

function AbstractSound_0(url){
  $clinit_AbstractSound();
  this.soundHandlerCollection = new SoundHandlerCollection_0;
  this.loadState = INITIAL_LOAD_STATE;
  this.mimeType = 'audio/mpeg';
  this.url = url;
  this.streaming = false;
  this.crossOrigin = false;
}

defineSeed(3, 1, {});
_.toString$ = function toString_1(){
  return this.getSoundType() + '("' + this.mimeType + '", "' + this.url + '", ' + (this.streaming?'streaming':'not streaming') + ', ' + (this.crossOrigin?'cross origin':'same origin') + ')';
}
;
_.crossOrigin = false;
_.mimeType = null;
_.streaming = false;
_.url = null;
var INITIAL_LOAD_STATE;
function $clinit_FlashSound(){
  $clinit_FlashSound = nullMethod;
  $clinit_AbstractSound();
  soundList = new ArrayList_0;
}

function $playbackCompleted(this$static){
  $fireOnPlaybackComplete(this$static.soundHandlerCollection, this$static);
}

function $registerSound(this$static){
  if (!this$static.soundRegistered) {
    $registerSound_0(this$static.voicesMovie, this$static);
    this$static.soundRegistered = true;
  }
}

function $soundLoaded(this$static){
  $setLoadState(this$static, ($clinit_Sound$LoadState() , LOAD_STATE_SUPPORTED_AND_READY));
  this$static.volume_0 != 100 && $setVolume(this$static.voicesMovie, this$static.soundNumber, this$static.volume_0);
  this$static.looping && $setLooping(this$static.voicesMovie, this$static.soundNumber, this$static.looping);
}

function FlashSound_0(url, voicesMovie){
  $clinit_FlashSound();
  AbstractSound_0.call(this, url);
  this.voicesMovie = voicesMovie;
  this.soundNumber = soundList.size;
  $add_0(soundList, this);
  $registerSound(this);
}

defineSeed(4, 3, {}, FlashSound_0);
_.getSoundType = function getSoundType(){
  return $clinit_SoundType() , FLASH;
}
;
_.play_1 = function play_0(){
  $registerSound(this);
  if (this.loadState == ($clinit_Sound$LoadState() , LOAD_STATE_SUPPORTED_AND_READY)) {
    return $playSound(this.voicesMovie, this.soundNumber);
  }
  return false;
}
;
_.setLooping_0 = function setLooping(looping){
  this.looping = looping;
  this.loadState == ($clinit_Sound$LoadState() , LOAD_STATE_SUPPORTED_AND_READY) && $setLooping(this.voicesMovie, this.soundNumber, looping);
}
;
_.setVolume_0 = function setVolume(volume){
  this.volume_0 = volume;
  this.loadState == ($clinit_Sound$LoadState() , LOAD_STATE_SUPPORTED_AND_READY) && $setVolume(this.voicesMovie, this.soundNumber, volume);
}
;
_.stop_0 = function stop_0(){
  this.loadState == ($clinit_Sound$LoadState() , LOAD_STATE_SUPPORTED_AND_READY) && $stopSound(this.voicesMovie, this.soundNumber);
}
;
_.looping = false;
_.soundNumber = 0;
_.soundRegistered = false;
_.voicesMovie = null;
_.volume_0 = 100;
var soundList;
function FlashSound$1_0(val$index){
  this.val$index = val$index;
}

defineSeed(5, 1, {}, FlashSound$1_0);
_.execute = function execute(){
  $playbackCompleted($get(($clinit_FlashSound() , soundList), this.val$index));
}
;
_.val$index = 0;
function FlashSound$2_0(val$index){
  this.val$index = val$index;
}

defineSeed(6, 1, {}, FlashSound$2_0);
_.execute = function execute_0(){
  $soundLoaded($get(($clinit_FlashSound() , soundList), this.val$index));
}
;
_.val$index = 0;
function $createAudioElement(this$static){
  var elem;
  !!this$static.endedRegistration && $removeHandler(this$static.endedRegistration.real);
  !!this$static.audio && $removeFromParent(this$static.audio);
  this$static.audio = createIfSupported();
  elem = this$static.audio.element;
  this$static.endedRegistration = $addBitlessDomHandler(this$static.audio, this$static.endedHandler, ($clinit_EndedEvent() , $clinit_EndedEvent() , TYPE));
  $add_3(($clinit_RootPanel() , get_9()), this$static.audio);
  this$static.crossOrigin && (elem.setAttribute('crossOrigin', 'anonymous') , undefined);
  $setSrc(elem, this$static.url);
}

function Html5Sound_0(url){
  $clinit_AbstractSound();
  var mimeTypeSupport;
  AbstractSound_0.call(this, url);
  this.endedHandler = new Html5Sound$1_0(this);
  $createAudioElement(this);
  mimeTypeSupport = getMimeTypeSupport();
  switch (mimeTypeSupport.ordinal) {
    case 2:
      $setLoadState(this, ($clinit_Sound$LoadState() , LOAD_STATE_SUPPORTED_MAYBE_READY));
      break;
    case 0:
      $setLoadState(this, ($clinit_Sound$LoadState() , LOAD_STATE_NOT_SUPPORTED));
      break;
    case 3:
      $setLoadState(this, ($clinit_Sound$LoadState() , LOAD_STATE_SUPPORT_NOT_KNOWN));
      throw new IllegalArgumentException_1('unexpected MIME type support ' + mimeTypeSupport);
    default:throw new IllegalArgumentException_1('unknown MIME type support ' + mimeTypeSupport);
  }
}

function getMimeTypeSupport(){
  var canPlayType;
  $clinit_AbstractSound();
  var support;
  if (!isSupported()) {
    return $clinit_SoundController$MimeTypeSupport() , MIME_TYPE_NOT_SUPPORTED;
  }
  support = (canPlayType = createIfSupported().element.canPlayType('audio/mpeg') , canPlayType == 'no'?'':canPlayType);
  if ($equals_0('probably', support)) {
    return $clinit_SoundController$MimeTypeSupport() , MIME_TYPE_SUPPORT_READY;
  }
  if ($equals_0('maybe', support)) {
    return $clinit_SoundController$MimeTypeSupport() , MIME_TYPE_SUPPORT_READY;
  }
  return $clinit_SoundController$MimeTypeSupport() , MIME_TYPE_SUPPORT_UNKNOWN;
}

defineSeed(7, 3, {}, Html5Sound_0);
_.getSoundType = function getSoundType_0(){
  return $clinit_SoundType() , HTML5;
}
;
_.play_1 = function play_1(){
  var $e0, elem;
  elem = this.audio.element;
  elem.pause();
  try {
    elem.currentTime = 0;
  }
   catch ($e0) {
    $e0 = caught_0($e0);
    if (!instanceOf($e0, Q$Exception))
      throw $e0;
  }
  elem.currentTime != 0 && $createAudioElement(this);
  elem.play();
  return true;
}
;
_.setLooping_0 = function setLooping_0(looping){
  $setBooleanAttr(this.audio.element, looping);
}
;
_.setVolume_0 = function setVolume_0(volume){
  $setVolume_1(this.audio.element, volume / 100);
}
;
_.stop_0 = function stop_1(){
  this.audio.element.pause();
}
;
_.audio = null;
_.endedRegistration = null;
function Html5Sound$1_0(this$0){
  this.this$0 = this$0;
}

defineSeed(8, 1, {}, Html5Sound$1_0);
_.this$0 = null;
function NativeSound_0(url, soundControllerElement){
  var elem, m_0;
  $clinit_AbstractSound();
  var mimeTypeSupport;
  AbstractSound_0.call(this, url);
  this.soundControllerElement = soundControllerElement;
  elem = $createElement(url);
  $setVolume_0(elem, 0);
  $play(soundControllerElement, elem);
  this.element = $createElement(url);
  mimeTypeSupport = (m_0 = navigator.mimeTypes['audio/mpeg'] , m_0 != null && m_0.enabledPlugin != null?($clinit_SoundController$MimeTypeSupport() , MIME_TYPE_SUPPORT_READY):($clinit_SoundController$MimeTypeSupport() , MIME_TYPE_NOT_SUPPORTED));
  switch (mimeTypeSupport.ordinal) {
    case 2:
      $setLoadState(this, ($clinit_Sound$LoadState() , LOAD_STATE_SUPPORTED_MAYBE_READY));
      break;
    case 0:
      $setLoadState(this, ($clinit_Sound$LoadState() , LOAD_STATE_NOT_SUPPORTED));
      break;
    case 3:
      $setLoadState(this, ($clinit_Sound$LoadState() , LOAD_STATE_SUPPORT_NOT_KNOWN));
      break;
    case 1:
      $setLoadState(this, ($clinit_Sound$LoadState() , LOAD_STATE_SUPPORTED_NOT_READY));
      break;
    default:throw new IllegalArgumentException_1('unknown MIME type support ' + mimeTypeSupport);
  }
}

defineSeed(9, 3, {}, NativeSound_0);
_.getSoundType = function getSoundType_1(){
  return $clinit_SoundType() , NATIVE;
}
;
_.play_1 = function play_2(){
  return $play(this.soundControllerElement, this.element);
}
;
_.setLooping_0 = function setLooping_1(looping){
  this.element.setAttribute('loop', 'infinite');
}
;
_.setVolume_0 = function setVolume_1(volume){
  $setVolume_0(this.element, volume);
}
;
_.stop_0 = function stop_2(){
  $stop(this.element);
}
;
_.element = null;
_.soundControllerElement = null;
function Enum_0(name_0, ordinal){
  this.name_0 = name_0;
  this.ordinal = ordinal;
}

function createValueOfMap(enumConstants){
  var result, value, value$index, value$max;
  result = {};
  for (value$index = 0 , value$max = enumConstants.length; value$index < value$max; ++value$index) {
    value = enumConstants[value$index];
    result[':' + value.name_0] = value;
  }
  return result;
}

function valueOf(map, name_0){
  var result;
  result = map[':' + name_0];
  if (result) {
    return result;
  }
  if (name_0 == null) {
    throw new NullPointerException_0;
  }
  throw new IllegalArgumentException_0;
}

defineSeed(11, 1, makeCastMap([Q$Serializable, Q$Comparable, Q$Enum]));
_.compareTo$ = function compareTo(other){
  return this.ordinal - other.ordinal;
}
;
_.equals$ = function equals_0(other){
  return this === other;
}
;
_.hashCode$ = function hashCode_1(){
  return getHashCode(this);
}
;
_.toString$ = function toString_2(){
  return this.name_0;
}
;
_.name_0 = null;
_.ordinal = 0;
function $clinit_Sound$LoadState(){
  $clinit_Sound$LoadState = nullMethod;
  LOAD_STATE_NOT_SUPPORTED = new Sound$LoadState_0('LOAD_STATE_NOT_SUPPORTED', 0);
  LOAD_STATE_SUPPORT_NOT_KNOWN = new Sound$LoadState_0('LOAD_STATE_SUPPORT_NOT_KNOWN', 1);
  LOAD_STATE_SUPPORTED_AND_READY = new Sound$LoadState_0('LOAD_STATE_SUPPORTED_AND_READY', 2);
  LOAD_STATE_SUPPORTED_MAYBE_READY = new Sound$LoadState_0('LOAD_STATE_SUPPORTED_MAYBE_READY', 3);
  LOAD_STATE_SUPPORTED_NOT_READY = new Sound$LoadState_0('LOAD_STATE_SUPPORTED_NOT_READY', 4);
  LOAD_STATE_UNINITIALIZED = new Sound$LoadState_0('LOAD_STATE_UNINITIALIZED', 5);
  $VALUES = initValues(_3Lcom_allen_1sauer_gwt_voices_client_Sound$LoadState_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Sound$LoadState, [LOAD_STATE_NOT_SUPPORTED, LOAD_STATE_SUPPORT_NOT_KNOWN, LOAD_STATE_SUPPORTED_AND_READY, LOAD_STATE_SUPPORTED_MAYBE_READY, LOAD_STATE_SUPPORTED_NOT_READY, LOAD_STATE_UNINITIALIZED]);
}

function Sound$LoadState_0(enum$name, enum$ordinal){
  Enum_0.call(this, enum$name, enum$ordinal);
}

function values_0(){
  $clinit_Sound$LoadState();
  return $VALUES;
}

defineSeed(10, 11, makeCastMap([Q$Sound$LoadState, Q$Serializable, Q$Comparable, Q$Enum]), Sound$LoadState_0);
var $VALUES, LOAD_STATE_NOT_SUPPORTED, LOAD_STATE_SUPPORTED_AND_READY, LOAD_STATE_SUPPORTED_MAYBE_READY, LOAD_STATE_SUPPORTED_NOT_READY, LOAD_STATE_SUPPORT_NOT_KNOWN, LOAD_STATE_UNINITIALIZED;
function $clinit_SoundController(){
  $clinit_SoundController = nullMethod;
  $wnd.$GWT_VOICES_VERSION = '3.2.0';
}

function $createSound(this$static, url){
  var sound;
  sound = $createSoundImpl(this$static, url);
  sound.setVolume_0(100);
  return sound;
}

function $createSoundImpl(this$static, url){
  var c, c$array, c$index, c$max, sound;
  sound = null;
  for (c$array = this$static.preferredSoundTypes , c$index = 0 , c$max = c$array.length; c$index < c$max; ++c$index) {
    c = c$array[c$index];
    switch (c.ordinal) {
      case 1:
        sound = $createSoundImplHtml5(url);
        break;
      case 0:
        sound = $createSoundImplFlash(this$static, url);
        break;
      case 2:
        sound = $createSoundImplWebAudio(url);
        break;
      case 3:
        sound = $createSoundImplWebAudio(url);
    }
    if (sound) {
      return sound;
    }
  }
  sound = $createSoundImplWebAudio(url);
  if (sound) {
    return sound;
  }
  sound = $createSoundImplFlash(this$static, url);
  if (sound) {
    return sound;
  }
  sound = $createSoundImplHtml5(url);
  if (sound) {
    return sound;
  }
  sound = new NativeSound_0(url, this$static.soundContainer);
  return sound;
}

function $createSoundImplFlash(this$static, url){
  var mimeTypeSupport, sound, vm;
  if (url.indexOf('data:') == 0) {
    return null;
  }
  $clinit_FlashMovie();
  if (impl_0.impl.getMajorVersion() >= 9) {
    vm = $getVoicesMovie(this$static);
    mimeTypeSupport = $getMimeTypeSupport(vm);
    if (mimeTypeSupport == ($clinit_SoundController$MimeTypeSupport() , MIME_TYPE_SUPPORT_READY) || mimeTypeSupport == MIME_TYPE_SUPPORT_NOT_READY) {
      sound = new FlashSound_0(url, vm);
      return sound;
    }
  }
  return null;
}

function $createSoundImplHtml5(url){
  if (getMimeTypeSupport() == ($clinit_SoundController$MimeTypeSupport() , MIME_TYPE_SUPPORT_READY)) {
    return new Html5Sound_0(url);
  }
  return null;
}

function $createSoundImplWebAudio(url){
  if (getMimeTypeSupport_0() == ($clinit_SoundController$MimeTypeSupport() , MIME_TYPE_SUPPORT_READY)) {
    return new WebAudioSound_0(url);
  }
  return null;
}

function $getVoicesMovie(this$static){
  if (!this$static.voicesWrapper) {
    this$static.voicesWrapper = new VoicesMovie_0('gwtVoices' + uniqueId++, this$static.gwtVoicesSwfBaseUrl);
    $appendChild(this$static.soundContainer, ($clinit_PotentialElement() , $resolve(this$static.voicesWrapper.element)));
  }
  return this$static.voicesWrapper;
}

function $setPreferredSoundTypes(this$static, soundTypes){
  var s$index, s$max;
  for (s$index = 0 , s$max = soundTypes.length; s$index < s$max; ++s$index) {
  }
  this$static.preferredSoundTypes = soundTypes;
}

function SoundController_0(){
  var s, i, gwtVoices, style;
  $clinit_SoundController();
  this.soundContainer = $doc.createElement('div');
  this.gwtVoicesSwfBaseUrl = (s = $doc.location.href , i = s.indexOf('#') , i != -1 && (s = s.substring(0, i)) , i = s.indexOf('?') , i != -1 && (s = s.substring(0, i)) , i = s.lastIndexOf('/') , i != -1 && (s = s.substring(0, i)) , s.length > 0?s + '/':'') + $moduleName + '/';
  gwtVoices = (ensureParameterMap() , paramMap.get_1('gwt-voices'));
  $equals_0(($clinit_SoundType() , FLASH).queryParameterValue, gwtVoices)?$setPreferredSoundTypes(this, initValues(_3Lcom_allen_1sauer_gwt_voices_client_SoundType_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$SoundType, [FLASH])):$equals_0(HTML5.queryParameterValue, gwtVoices)?$setPreferredSoundTypes(this, initValues(_3Lcom_allen_1sauer_gwt_voices_client_SoundType_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$SoundType, [HTML5])):$equals_0(WEB_AUDIO.queryParameterValue, gwtVoices)?$setPreferredSoundTypes(this, initValues(_3Lcom_allen_1sauer_gwt_voices_client_SoundType_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$SoundType, [WEB_AUDIO])):$equals_0(NATIVE.queryParameterValue, gwtVoices)?$setPreferredSoundTypes(this, initValues(_3Lcom_allen_1sauer_gwt_voices_client_SoundType_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$SoundType, [NATIVE])):$setPreferredSoundTypes(this, initValues(_3Lcom_allen_1sauer_gwt_voices_client_SoundType_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$SoundType, [WEB_AUDIO, FLASH, HTML5]));
  $appendChild(getBodyElement(), this.soundContainer);
  style = this.soundContainer.style;
  style['position'] = ($clinit_Style$Position() , 'absolute');
  style['overflow'] = ($clinit_Style$Overflow() , 'hidden');
  style['left'] = -500 + ($clinit_Style$Unit() , 'px');
  style['top'] = '-500px';
  style['width'] = '0px';
  style['height'] = '0px';
}

defineSeed(12, 1, {}, SoundController_0);
_.preferredSoundTypes = null;
_.voicesWrapper = null;
function $clinit_SoundController$MimeTypeSupport(){
  $clinit_SoundController$MimeTypeSupport = nullMethod;
  MIME_TYPE_NOT_SUPPORTED = new SoundController$MimeTypeSupport_0('MIME_TYPE_NOT_SUPPORTED', 0);
  MIME_TYPE_SUPPORT_NOT_READY = new SoundController$MimeTypeSupport_0('MIME_TYPE_SUPPORT_NOT_READY', 1);
  MIME_TYPE_SUPPORT_READY = new SoundController$MimeTypeSupport_0('MIME_TYPE_SUPPORT_READY', 2);
  MIME_TYPE_SUPPORT_UNKNOWN = new SoundController$MimeTypeSupport_0('MIME_TYPE_SUPPORT_UNKNOWN', 3);
  $VALUES_0 = initValues(_3Lcom_allen_1sauer_gwt_voices_client_SoundController$MimeTypeSupport_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$SoundController$MimeTypeSupport, [MIME_TYPE_NOT_SUPPORTED, MIME_TYPE_SUPPORT_NOT_READY, MIME_TYPE_SUPPORT_READY, MIME_TYPE_SUPPORT_UNKNOWN]);
}

function SoundController$MimeTypeSupport_0(enum$name, enum$ordinal){
  Enum_0.call(this, enum$name, enum$ordinal);
}

function values_1(){
  $clinit_SoundController$MimeTypeSupport();
  return $VALUES_0;
}

defineSeed(13, 11, makeCastMap([Q$SoundController$MimeTypeSupport, Q$Serializable, Q$Comparable, Q$Enum]), SoundController$MimeTypeSupport_0);
var $VALUES_0, MIME_TYPE_NOT_SUPPORTED, MIME_TYPE_SUPPORT_NOT_READY, MIME_TYPE_SUPPORT_READY, MIME_TYPE_SUPPORT_UNKNOWN;
function $clinit_SoundType(){
  $clinit_SoundType = nullMethod;
  FLASH = new SoundType_0('FLASH', 0, 'flash');
  HTML5 = new SoundType_0('HTML5', 1, 'html5');
  NATIVE = new SoundType_0('NATIVE', 2, 'native');
  WEB_AUDIO = new SoundType_0('WEB_AUDIO', 3, 'webaudio');
  $VALUES_1 = initValues(_3Lcom_allen_1sauer_gwt_voices_client_SoundType_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$SoundType, [FLASH, HTML5, NATIVE, WEB_AUDIO]);
}

function SoundType_0(enum$name, enum$ordinal, queryParameterValue){
  Enum_0.call(this, enum$name, enum$ordinal);
  this.queryParameterValue = queryParameterValue;
}

function values_2(){
  $clinit_SoundType();
  return $VALUES_1;
}

defineSeed(14, 11, makeCastMap([Q$SoundType, Q$Serializable, Q$Comparable, Q$Enum]), SoundType_0);
_.queryParameterValue = null;
var $VALUES_1, FLASH, HTML5, NATIVE, WEB_AUDIO;
function $clinit_WebAudioSound(){
  $clinit_WebAudioSound = nullMethod;
  $clinit_AbstractSound();
  audioContext = createAudioContext();
}

function $createVoice(this$static, url){
  var context = audioContext;
  var request = new $wnd.XMLHttpRequest;
  request.open('GET', url, true);
  request.responseType = 'arraybuffer';
  var self_0 = this$static;
  request.onload = function(){
    try {
      self_0.buffer_0 = context.createBuffer(request.response, false);
      self_0.soundLoaded_0();
    }
     catch (e) {
      self_0.soundLoadFailed();
    }
  }
  ;
  request.send();
}

function WebAudioSound_0(url){
  $clinit_WebAudioSound();
  var $e0, mimeTypeSupport;
  AbstractSound_0.call(this, url);
  try {
    $createVoice(this, url);
  }
   catch ($e0) {
    $e0 = caught_0($e0);
    if (instanceOf($e0, Q$Throwable)) {
      $setLoadState(this, ($clinit_Sound$LoadState() , LOAD_STATE_NOT_SUPPORTED));
    }
     else 
      throw $e0;
  }
  mimeTypeSupport = getMimeTypeSupport_0();
  switch (mimeTypeSupport.ordinal) {
    case 1:
    case 2:
      $setLoadState(this, ($clinit_Sound$LoadState() , LOAD_STATE_SUPPORTED_NOT_READY));
      break;
    case 0:
      $setLoadState(this, ($clinit_Sound$LoadState() , LOAD_STATE_NOT_SUPPORTED));
      break;
    case 3:
      $setLoadState(this, ($clinit_Sound$LoadState() , LOAD_STATE_SUPPORT_NOT_KNOWN));
      break;
    default:throw new IllegalArgumentException_1('unknown MIME type support ' + mimeTypeSupport);
  }
}

function createAudioContext(){
  try {
    return new AudioContext;
  }
   catch (ignore) {
  }
  try {
    return new webkitAudioContext;
  }
   catch (ignore) {
  }
  return null;
}

function getMimeTypeSupport_0(){
  $clinit_WebAudioSound();
  if (!audioContext) {
    return $clinit_SoundController$MimeTypeSupport() , MIME_TYPE_NOT_SUPPORTED;
  }
  return getMimeTypeSupport();
}

defineSeed(15, 3, {}, WebAudioSound_0);
_.getSoundType = function getSoundType_2(){
  return $clinit_SoundType() , WEB_AUDIO;
}
;
_.plackbackCompleted = function plackbackCompleted(){
  $fireOnPlaybackComplete(this.soundHandlerCollection, this);
}
;
_.play_1 = function play_3(){
  var buffer = this.buffer_0;
  if (buffer == null) {
    return false;
  }
  this.stop_0();
  var context = audioContext;
  var voice = context.createBufferSource();
  this.voice = voice;
  this.looping && (voice.loop = true);
  var node = voice;
  var volume = this.volume_0;
  if (volume != 100) {
    var gainNode = context.createGainNode();
    gainNode.gain.value = volume / 100;
    node.connect(gainNode);
    node = gainNode;
  }
  node.connect(context.destination);
  voice.buffer = buffer;
  voice.noteOn(context.currentTime);
  if (!voice.loop) {
    var self_0 = this;
    setTimeout(function(){
      self_0.plackbackCompleted();
    }
    , voice.buffer.duration * 1000);
  }
  return true;
}
;
_.setLooping_0 = function setLooping_2(looping){
  this.looping = looping;
}
;
_.setVolume_0 = function setVolume_2(volume){
  this.volume_0 = volume;
}
;
_.soundLoadFailed = function soundLoadFailed(){
  $setLoadState(this, ($clinit_Sound$LoadState() , LOAD_STATE_NOT_SUPPORTED));
}
;
_.soundLoaded_0 = function soundLoaded(){
  $setLoadState(this, ($clinit_Sound$LoadState() , LOAD_STATE_SUPPORTED_AND_READY));
}
;
_.stop_0 = function stop_3(){
  var context = audioContext;
  var voice = this.voice;
  if (voice == null) {
    return;
  }
  voice.noteOff(context.currentTime);
  this.voice = null;
}
;
_.buffer_0 = null;
_.looping = false;
_.voice = null;
_.volume_0 = 0;
var audioContext = null;
defineSeed(17, 1, {});
_.source = null;
function PlaybackCompleteEvent_0(source){
  this.source = source;
}

defineSeed(16, 17, {}, PlaybackCompleteEvent_0);
_.toString$ = function toString_3(){
  var sound;
  sound = this.source;
  return getSimpleName(Lcom_allen_1sauer_gwt_voices_client_handler_PlaybackCompleteEvent_2_classLit) + ': ' + sound;
}
;
function $advanceToFind(iter, o){
  var t;
  while (iter.hasNext()) {
    t = iter.next_0();
    if (o == null?t == null:equals__devirtual$(o, t)) {
      return iter;
    }
  }
  return null;
}

function $remove(this$static, o){
  var iter;
  iter = $advanceToFind(this$static.iterator_0(), o);
  if (iter) {
    iter.remove_2();
    return true;
  }
   else {
    return false;
  }
}

function $removeAll(this$static, c){
  var changed, iter;
  iter = new AbstractList$IteratorImpl_0(this$static);
  changed = false;
  while (iter.i < iter.this$0_0.size_0()) {
    if ($indexOf_0(c, $next_2(iter), 0) != -1) {
      $remove_10(iter);
      changed = true;
    }
  }
  return changed;
}

function $toArray(this$static, a){
  var i, it, size;
  size = this$static.size;
  a.length < size && (a = createFrom(a, size));
  it = $listIterator(this$static, 0);
  for (i = 0; i < size; ++i) {
    setCheck(a, i, $next_7(it));
  }
  a.length > size && setCheck(a, size, null);
  return a;
}

function $toString(this$static){
  var comma, iter, sb, value;
  sb = new StringBuffer_0;
  comma = null;
  sb.impl.string += '[';
  iter = this$static.iterator_0();
  while (iter.hasNext()) {
    comma != null?($append_3(sb.impl, comma) , sb):(comma = ', ');
    value = iter.next_0();
    $append_3(sb.impl, value === this$static?'(this Collection)':'' + value);
  }
  sb.impl.string += ']';
  return sb.impl.string;
}

defineSeed(21, 1, {});
_.add = function add(o){
  throw new UnsupportedOperationException_1('Add not supported on this collection');
}
;
_.contains_0 = function contains(o){
  var iter;
  iter = $advanceToFind(this.iterator_0(), o);
  return !!iter;
}
;
_.isEmpty = function isEmpty(){
  return this.size_0() == 0;
}
;
_.remove = function remove_0(o){
  return $remove(this, o);
}
;
_.toString$ = function toString_4(){
  return $toString(this);
}
;
function $indexOf(this$static, toFind){
  var i, n;
  for (i = 0 , n = this$static.size_0(); i < n; ++i) {
    if (toFind == null?this$static.get(i) == null:equals__devirtual$(toFind, this$static.get(i))) {
      return i;
    }
  }
  return -1;
}

function checkIndex(index, size){
  (index < 0 || index >= size) && indexOutOfBounds(index, size);
}

function indexOutOfBounds(index, size){
  throw new IndexOutOfBoundsException_1('Index: ' + index + ', Size: ' + size);
}

defineSeed(20, 21, makeCastMap([Q$List]));
_.add_0 = function add_0(index, element){
  throw new UnsupportedOperationException_1('Add not supported on this list');
}
;
_.add = function add_1(obj){
  this.add_0(this.size_0(), obj);
  return true;
}
;
--></script>
<script><!--
_.equals$ = function equals_1(o){
  var elem, elemOther, iter, iterOther, other;
  if (o === this) {
    return true;
  }
  if (!instanceOf(o, Q$List)) {
    return false;
  }
  other = o;
  if (this.size_0() != other.size_0()) {
    return false;
  }
  iter = this.iterator_0();
  iterOther = other.iterator_0();
  while (iter.hasNext()) {
    elem = iter.next_0();
    elemOther = iterOther.next_0();
    if (!(elem == null?elemOther == null:equals__devirtual$(elem, elemOther))) {
      return false;
    }
  }
  return true;
}
;
_.hashCode$ = function hashCode_2(){
  var iter, k, obj;
  k = 1;
  iter = this.iterator_0();
  while (iter.hasNext()) {
    obj = iter.next_0();
    k = 31 * k + (obj == null?0:hashCode__devirtual$(obj));
    k = ~~k;
  }
  return k;
}
;
_.indexOf_0 = function indexOf(toFind){
  return $indexOf(this, toFind);
}
;
_.iterator_0 = function iterator_0(){
  return new AbstractList$IteratorImpl_0(this);
}
;
_.listIterator = function listIterator(){
  return this.listIterator_0(0);
}
;
_.listIterator_0 = function listIterator_0(from){
  return new AbstractList$ListIteratorImpl_0(this, from);
}
;
_.remove_0 = function remove_1(index){
  throw new UnsupportedOperationException_1('Remove not supported on this list');
}
;
function $$init(this$static){
  this$static.array = initDim(_3Ljava_lang_Object_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Object, 0, 0);
}

function $add(this$static, index, o){
  (index < 0 || index > this$static.size) && indexOutOfBounds(index, this$static.size);
  splice_0(this$static.array, index, 0, o);
  ++this$static.size;
}

function $add_0(this$static, o){
  setCheck(this$static.array, this$static.size++, o);
  return true;
}

function $clear(this$static){
  this$static.array = initDim(_3Ljava_lang_Object_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Object, 0, 0);
  this$static.size = 0;
}

function $get(this$static, index){
  checkIndex(index, this$static.size);
  return this$static.array[index];
}

function $indexOf_0(this$static, o, index){
  for (; index < this$static.size; ++index) {
    if (equalsWithNullCheck(o, this$static.array[index])) {
      return index;
    }
  }
  return -1;
}

function $remove_0(this$static, index){
  var previous;
  previous = (checkIndex(index, this$static.size) , this$static.array[index]);
  splice(this$static.array, index, 1);
  --this$static.size;
  return previous;
}

function $remove_1(this$static, o){
  var i;
  i = $indexOf_0(this$static, o, 0);
  if (i == -1) {
    return false;
  }
  $remove_0(this$static, i);
  return true;
}

function $set(this$static, index, o){
  var previous;
  previous = (checkIndex(index, this$static.size) , this$static.array[index]);
  setCheck(this$static.array, index, o);
  return previous;
}

function $toArray_0(this$static, out){
  var i;
  out.length < this$static.size && (out = createFrom(out, this$static.size));
  for (i = 0; i < this$static.size; ++i) {
    setCheck(out, i, this$static.array[i]);
  }
  out.length > this$static.size && setCheck(out, this$static.size, null);
  return out;
}

function ArrayList_0(){
  $$init(this);
}

function ArrayList_1(initialCapacity){
  $$init(this);
  setCapacity(this.array, initialCapacity);
}

function ArrayList_2(c){
  $$init(this);
  spliceArray(this.array, 0, 0, $toArray(c, initDim(_3Ljava_lang_Object_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Object, c.size, 0)));
  this.size = this.array.length;
}

function setCapacity(array, newSize){
  array.length = newSize;
}

function splice(array, index, deleteCount){
  array.splice(index, deleteCount);
}

function splice_0(array, index, deleteCount, value){
  array.splice(index, deleteCount, value);
}

function spliceArray(array, index, deleteCount, values){
  Array.prototype.splice.apply(array, [index, deleteCount].concat(values));
}

defineSeed(19, 20, makeCastMap([Q$Serializable, Q$List]), ArrayList_0, ArrayList_1, ArrayList_2);
_.add_0 = function add_2(index, o){
  $add(this, index, o);
}
;
_.add = function add_3(o){
  return $add_0(this, o);
}
;
_.contains_0 = function contains_0(o){
  return $indexOf_0(this, o, 0) != -1;
}
;
_.get = function get(index){
  return $get(this, index);
}
;
_.indexOf_0 = function indexOf_0(o){
  return $indexOf_0(this, o, 0);
}
;
_.isEmpty = function isEmpty_0(){
  return this.size == 0;
}
;
_.remove_0 = function remove_2(index){
  return $remove_0(this, index);
}
;
_.remove = function remove_3(o){
  return $remove_1(this, o);
}
;
_.size_0 = function size_0(){
  return this.size;
}
;
_.size = 0;
function $fireOnPlaybackComplete(this$static, sender){
  var handler, handler$iterator;
  new PlaybackCompleteEvent_0(sender);
  for (handler$iterator = new AbstractList$IteratorImpl_0(this$static); handler$iterator.i < handler$iterator.this$0_0.size_0();) {
    handler = $next_2(handler$iterator);
    handler.this$0.playing = false;
  }
}

function $fireOnSoundLoadStateChange(this$static, sender){
  var event_0, handler, handler$iterator;
  event_0 = new SoundLoadStateChangeEvent_0(sender);
  for (handler$iterator = new AbstractList$IteratorImpl_0(this$static); handler$iterator.i < handler$iterator.this$0_0.size_0();) {
    handler = $next_2(handler$iterator);
    $onSoundLoadStateChange(handler, event_0);
  }
}

function SoundHandlerCollection_0(){
  $$init(this);
}

defineSeed(18, 19, makeCastMap([Q$Serializable, Q$List]), SoundHandlerCollection_0);
function SoundLoadStateChangeEvent_0(source){
  this.source = source;
  this.loadState = source.loadState;
}

defineSeed(22, 17, {}, SoundLoadStateChangeEvent_0);
_.toString$ = function toString_5(){
  var sound;
  sound = this.source;
  return getSimpleName(Lcom_allen_1sauer_gwt_voices_client_handler_SoundLoadStateChangeEvent_2_classLit) + ': ' + sound + '; ' + this.loadState.name_0;
}
;
_.loadState = null;
function $clinit_FlashMovie(){
  $clinit_FlashMovie = nullMethod;
  impl_0 = new FlashMovieImplPlayN_0;
}

defineSeed(23, 1, {});
_.element = null;
var impl_0 = null;
function $clinit_VoicesMovie(){
  $clinit_VoicesMovie = nullMethod;
  $clinit_FlashMovie();
  FLASH_SUPPORTED_MIME_TYPES = initValues(_3Ljava_lang_String_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$String, ['audio/mpeg', 'audio/mpeg; codecs=MP3']);
}

function $callCreateSound(this$static, id, soundURL, checkPolicyFile){
  var elem = this$static.element;
  elem.createSound(id, soundURL, checkPolicyFile);
}

function $getMimeTypeSupport(this$static){
  switch (this$static.flashSupport.ordinal) {
    case 2:
    case 1:
      return contains_1(FLASH_SUPPORTED_MIME_TYPES)?($clinit_SoundController$MimeTypeSupport() , MIME_TYPE_SUPPORT_READY):($clinit_SoundController$MimeTypeSupport() , MIME_TYPE_NOT_SUPPORTED);
    case 3:
    case 0:
      return this$static.flashSupport;
    default:throw new RuntimeException_1('Unhandled flash support value ' + this$static.flashSupport);
  }
}

function $installFlashCallbackHooks(this$static, id_0){
  $doc.VoicesMovie === undefined && ($doc.VoicesMovie = {});
  var self_0 = this$static;
  $doc.VoicesMovie[id_0] = {};
  $doc.VoicesMovie[id_0].ready = function(){
    self_0.movieReady();
  }
  ;
  $doc.VoicesMovie[id_0].soundLoaded = function(id){
    $clinit_FlashSound();
    $scheduleDeferred(($clinit_SchedulerImpl() , INSTANCE), new FlashSound$2_0(id));
    return true;
  }
  ;
  $doc.VoicesMovie[id_0].playbackCompleted = function(id){
    $clinit_FlashSound();
    $scheduleDeferred(($clinit_SchedulerImpl() , INSTANCE), new FlashSound$1_0(id));
  }
  ;
  $doc.VoicesMovie[id_0].log = function(text){
    self_0.debug('FLASH[' + id_0 + ']: ' + text);
  }
  ;
}

function $movieUnsupported(this$static){
  var flashSound, flashSound$iterator;
  for (flashSound$iterator = new AbstractList$IteratorImpl_0(this$static.unitializedSoundList); flashSound$iterator.i < flashSound$iterator.this$0_0.size_0();) {
    flashSound = $next_2(flashSound$iterator);
    $setLoadState(flashSound, ($clinit_Sound$LoadState() , LOAD_STATE_NOT_SUPPORTED));
  }
}

function $playSound(this$static, id){
  var elem;
  if (this$static.flashSupport == ($clinit_SoundController$MimeTypeSupport() , MIME_TYPE_SUPPORT_READY)) {
    return elem = this$static.element , elem.playSound(id);
  }
  return false;
}

function $registerSound_0(this$static, flashSound){
  this$static.flashSupport == ($clinit_SoundController$MimeTypeSupport() , MIME_TYPE_SUPPORT_READY)?$callCreateSound(this$static, flashSound.soundNumber, flashSound.url, flashSound.crossOrigin):$add_0(this$static.unitializedSoundList, flashSound);
}

function $setLooping(this$static, id, looping){
  var elem;
  this$static.flashSupport == ($clinit_SoundController$MimeTypeSupport() , MIME_TYPE_SUPPORT_READY) && (elem = this$static.element , elem.setLooping(id, looping?2147483647:0) , undefined);
}

function $setVolume(this$static, id, volume){
  var elem;
  this$static.flashSupport == ($clinit_SoundController$MimeTypeSupport() , MIME_TYPE_SUPPORT_READY) && (elem = this$static.element , elem.setVolume(id, volume / 100) , undefined);
}

function $stopSound(this$static, id){
  var elem;
  this$static.flashSupport == ($clinit_SoundController$MimeTypeSupport() , MIME_TYPE_SUPPORT_READY) && (elem = this$static.element , elem.stopSound(id) , undefined);
}

function VoicesMovie_0(id, gwtVoicesSwfBaseUrl){
  $clinit_VoicesMovie();
  this.element = $createElementMaybeSetURL(impl_0, id, gwtVoicesSwfBaseUrl + 'gwt-voices.swf');
  this.flashSupport = ($clinit_SoundController$MimeTypeSupport() , MIME_TYPE_SUPPORT_UNKNOWN);
  this.unitializedSoundList = new ArrayList_0;
  $installFlashCallbackHooks(this, id);
  if (impl_0.impl.getMajorVersion() >= 9) {
    this.flashSupport = MIME_TYPE_SUPPORT_NOT_READY;
  }
   else {
    this.flashSupport = MIME_TYPE_NOT_SUPPORTED;
    $scheduleDeferred(($clinit_SchedulerImpl() , INSTANCE), new VoicesMovie$1_0(this));
  }
}

defineSeed(24, 23, {}, VoicesMovie_0);
_.debug = function debug(text){
}
;
_.movieReady = function movieReady(){
  var flashSound, iterator;
  this.flashSupport = ($clinit_SoundController$MimeTypeSupport() , MIME_TYPE_SUPPORT_READY);
  for (iterator = new AbstractList$IteratorImpl_0(this.unitializedSoundList); iterator.i < iterator.this$0_0.size_0();) {
    flashSound = $next_2(iterator);
    $callCreateSound(this, flashSound.soundNumber, flashSound.url, flashSound.crossOrigin);
    $remove_10(iterator);
  }
}
;
var FLASH_SUPPORTED_MIME_TYPES;
function VoicesMovie$1_0(this$0){
  this.this$0 = this$0;
}

defineSeed(25, 1, {}, VoicesMovie$1_0);
_.execute = function execute_1(){
  $movieUnsupported(this.this$0);
}
;
_.this$0 = null;
defineSeed(26, 1, {});
_.getMajorVersion = function getMajorVersion(){
  var versionString;
  versionString = this.getVersionString();
  return versionString == null?0:__parseAndValidateInt($replaceFirst(versionString, ',.*', ''));
}
;
_.getVersionString = function getVersionString(){
  var rawVersionString;
  rawVersionString = this.getRawVersionString();
  return rawVersionString == null?null:$replaceFirst($replaceAll(rawVersionString, '\\D*(\\d+)', '$1,'), ',$', '');
}
;
function FlashMovieImplIE6_0(){
}

defineSeed(27, 26, {}, FlashMovieImplIE6_0);
_.createElementMaybeSetURL = function createElementMaybeSetURL(id, url){
  var elem = $doc.createElement('object');
  elem.tabIndex = -1;
  elem.id = id;
  elem.classid = 'clsid:d27cdb6e-ae6d-11cf-96b8-444553540000';
  elem.codebase = 'http://fpdownload.macromedia.com/pub/shockwave/cabs/flash/swflash.cab#version=8,0,0,0';
  elem.FlashVars = 'id=' + id;
  elem.Movie = url;
  return elem;
}
;
_.getRawVersionString = function getRawVersionString(){
  try {
    return (new ActiveXObject('ShockwaveFlash.ShockwaveFlash')).GetVariable('$version');
  }
   catch (e) {
    return null;
  }
}
;
function $createElementMaybeSetURL(this$static, id, url){
  return this$static.impl.createElementMaybeSetURL(id, url);
}

function FlashMovieImplPlayN_0(){
  $wnd.navigator.userAgent.indexOf('MSIE') != -1?(this.impl = new FlashMovieImplIE6_0):(this.impl = new FlashMovieImplSafari_0);
  $debug(platform_1.log_0, 'CHOSE: ' + this.impl.___clazz$.typeName);
}

defineSeed(28, 26, {}, FlashMovieImplPlayN_0);
_.createElementMaybeSetURL = function createElementMaybeSetURL_0(id, url){
  return this.impl.createElementMaybeSetURL(id, url);
}
;
_.getMajorVersion = function getMajorVersion_0(){
  return this.impl.getMajorVersion();
}
;
_.getRawVersionString = function getRawVersionString_0(){
  return this.impl.getRawVersionString();
}
;
_.getVersionString = function getVersionString_0(){
  return this.impl.getVersionString();
}
;
_.impl = null;
defineSeed(30, 26, {});
_.createElementMaybeSetURL = function createElementMaybeSetURL_1(id, url){
  var elem = $doc.createElement('object');
  elem.setAttribute('id', id);
  elem.setAttribute('type', 'application/x-shockwave-flash');
  elem.setAttribute('data', url);
  var param = $doc.createElement('param');
  param.setAttribute('name', 'FlashVars');
  param.setAttribute('value', 'id=' + id);
  elem.appendChild(param);
  return elem;
}
;
_.getRawVersionString = function getRawVersionString_1(){
  var p = navigator.plugins['Shockwave Flash'];
  return p == null?null:p.description;
}
;
function FlashMovieImplSafari_0(){
}

defineSeed(29, 30, {}, FlashMovieImplSafari_0);
function $stop(elem){
  var parent_0 = elem.parentNode;
  parent_0 != null && parent_0.removeChild(elem);
}

function $createElement(url){
  var elem = $doc.createElement('object');
  elem.setAttribute('data', url);
  elem.setAttribute('autostart', 'true');
  return elem;
}

function $setVolume_0(elem, volume){
  elem.setAttribute('volume', '' + volume);
}

function $play(soundControllerElement, elem){
  var parent_0 = elem.parentNode;
  parent_0 != null && parent_0.removeChild(elem);
  soundControllerElement.appendChild(elem);
  return true;
}

var uniqueId = 1000;
function contains_1(arr){
  var element, element$index, element$max;
  for (element$index = 0 , element$max = arr.length; element$index < element$max; ++element$index) {
    element = arr[element$index];
    if ($equals_0(element, 'audio/mpeg')) {
      return true;
    }
  }
  return false;
}

function getSimpleName(clazz){
  var name_0;
  name_0 = clazz.typeName;
  return $substring(name_0, $lastIndexOf(name_0, fromCodePoint(46)) + 1);
}

function $add_1(this$static, widget){
  var cell, column, columnCell, i, lastCell, nn, other;
  cell = new Cell_0;
  cell.widget = widget;
  if (this$static.cells.size > 0) {
    lastCell = $get(this$static.cells, this$static.cells.size - 1);
    if (lastCell.endRow) {
      cell.column = 0;
      cell.row = lastCell.row + 1;
    }
     else {
      cell.column = lastCell.column + lastCell.colspan.value_0;
      cell.row = lastCell.row;
    }
    if (cell.row > 0) {
      outer: for (i = this$static.cells.size - 1; i >= 0; --i) {
        other = $get(this$static.cells, i);
        for (column = other.column , nn = column + other.colspan.value_0; column < nn; ++column) {
          if (column == cell.column) {
            cell.cellAboveIndex = i;
            break outer;
          }
        }
      }
    }
  }
   else {
    cell.column = 0;
    cell.row = 0;
  }
  $add_0(this$static.cells, cell);
  $set_0(cell, this$static.cellDefaults);
  if (cell.column < this$static.columnDefaults.size) {
    columnCell = $get(this$static.columnDefaults, cell.column);
    !!columnCell && $merge(cell, columnCell);
  }
  $merge(cell, this$static.rowDefaults);
  !!widget && $add_5(this$static.table, widget);
  return cell;
}

function $computeSize(this$static){
  var above, c, column, extraMinWidth, extraPrefWidth, hpadding, i, maxHeight, maxWidth, minHeight, minWidth, n, nn, prefHeight, prefWidth, ratio, spaceRight, spaceRightLast, spannedMinWidth, spannedPrefWidth, totalExpandWidth, uniformMinHeight, uniformMinWidth, uniformPrefHeight, uniformPrefWidth, vpadding;
  this$static.sizeInvalid = false;
  this$static.cells.size > 0 && !$get(this$static.cells, this$static.cells.size - 1).endRow && $endRow(this$static);
  this$static.columnMinWidth = $ensureSize(this$static.columnMinWidth, this$static.columns);
  this$static.rowMinHeight = $ensureSize(this$static.rowMinHeight, this$static.rows);
  this$static.columnPrefWidth = $ensureSize(this$static.columnPrefWidth, this$static.columns);
  this$static.rowPrefHeight = $ensureSize(this$static.rowPrefHeight, this$static.rows);
  this$static.columnWidth = $ensureSize(this$static.columnWidth, this$static.columns);
  this$static.rowHeight = $ensureSize(this$static.rowHeight, this$static.rows);
  this$static.expandWidth = $ensureSize(this$static.expandWidth, this$static.columns);
  this$static.expandHeight = $ensureSize(this$static.expandHeight, this$static.rows);
  spaceRightLast = 0;
  for (i = 0 , n = this$static.cells.size; i < n; ++i) {
    c = $get(this$static.cells, i);
    if (c.ignore.value_0)
      continue;
    c.expandY.value_0 != 0 && this$static.expandHeight[c.row] == 0 && (this$static.expandHeight[c.row] = c.expandY.value_0);
    c.colspan.value_0 == 1 && c.expandX.value_0 != 0 && this$static.expandWidth[c.column] == 0 && (this$static.expandWidth[c.column] = c.expandX.value_0);
    c.computedPadLeft = $w(c.padLeft, c) + (c.column == 0?0:max_0(0, $w(c.spaceLeft, c) - spaceRightLast));
    c.computedPadTop = $h(c.padTop, c);
    if (c.cellAboveIndex != -1) {
      above = $get(this$static.cells, c.cellAboveIndex);
      c.computedPadTop += max_0(0, $h(c.spaceTop, c) - $h(above.spaceBottom, above));
    }
    spaceRight = $w(c.spaceRight, c);
    c.computedPadRight = $w(c.padRight, c) + (c.column + c.colspan.value_0 == this$static.columns?0:spaceRight);
    c.computedPadBottom = $h(c.padBottom, c) + (c.row == this$static.rows - 1?0:$h(c.spaceBottom, c));
    spaceRightLast = spaceRight;
    prefWidth = $w(c.prefWidth, c);
    prefHeight = $h(c.prefHeight, c);
    minWidth = $w(c.minWidth, c);
    minHeight = $h(c.minHeight, c);
    maxWidth = $w(c.maxWidth, c);
    maxHeight = $h(c.maxHeight, c);
    prefWidth < minWidth && (prefWidth = minWidth);
    prefHeight < minHeight && (prefHeight = minHeight);
    maxWidth > 0 && prefWidth > maxWidth && (prefWidth = maxWidth);
    maxHeight > 0 && prefHeight > maxHeight && (prefHeight = maxHeight);
    if (c.colspan.value_0 == 1) {
      hpadding = c.computedPadLeft + c.computedPadRight;
      this$static.columnPrefWidth[c.column] = max_0(this$static.columnPrefWidth[c.column], prefWidth + hpadding);
      this$static.columnMinWidth[c.column] = max_0(this$static.columnMinWidth[c.column], minWidth + hpadding);
    }
    vpadding = c.computedPadTop + c.computedPadBottom;
    this$static.rowPrefHeight[c.row] = max_0(this$static.rowPrefHeight[c.row], prefHeight + vpadding);
    this$static.rowMinHeight[c.row] = max_0(this$static.rowMinHeight[c.row], minHeight + vpadding);
  }
  outer: for (i = 0 , n = this$static.cells.size; i < n; ++i) {
    c = $get(this$static.cells, i);
    if (c.ignore.value_0 || c.expandX.value_0 == 0)
      continue;
    for (column = c.column , nn = column + c.colspan.value_0; column < nn; ++column)
      if (this$static.expandWidth[column] != 0)
        continue outer;
    for (column = c.column , nn = column + c.colspan.value_0; column < nn; ++column)
      this$static.expandWidth[column] = c.expandX.value_0;
  }
  for (i = 0 , n = this$static.cells.size; i < n; ++i) {
    c = $get(this$static.cells, i);
    if (c.ignore.value_0 || c.colspan.value_0 == 1)
      continue;
    minWidth = $w(c.minWidth, c);
    prefWidth = $w(c.prefWidth, c);
    maxWidth = $w(c.maxWidth, c);
    prefWidth < minWidth && (prefWidth = minWidth);
    maxWidth > 0 && prefWidth > maxWidth && (prefWidth = maxWidth);
    spannedMinWidth = -(c.computedPadLeft + c.computedPadRight);
    spannedPrefWidth = spannedMinWidth;
    for (column = c.column , nn = column + c.colspan.value_0; column < nn; ++column) {
      spannedMinWidth += this$static.columnMinWidth[column];
      spannedPrefWidth += this$static.columnPrefWidth[column];
    }
    totalExpandWidth = 0;
    for (column = c.column , nn = column + c.colspan.value_0; column < nn; ++column)
      totalExpandWidth += this$static.expandWidth[column];
    extraMinWidth = 0 > minWidth - spannedMinWidth?0:minWidth - spannedMinWidth;
    extraPrefWidth = 0 > prefWidth - spannedPrefWidth?0:prefWidth - spannedPrefWidth;
    for (column = c.column , nn = column + c.colspan.value_0; column < nn; ++column) {
      ratio = totalExpandWidth == 0?1 / c.colspan.value_0:this$static.expandWidth[column] / totalExpandWidth;
      this$static.columnMinWidth[column] += extraMinWidth * ratio;
      this$static.columnPrefWidth[column] += extraPrefWidth * ratio;
    }
  }
  uniformMinWidth = 0;
  uniformMinHeight = 0;
  uniformPrefWidth = 0;
  uniformPrefHeight = 0;
  for (i = 0 , n = this$static.cells.size; i < n; ++i) {
    c = $get(this$static.cells, i);
    if (c.ignore.value_0)
      continue;
    if (c.uniformX == ($clinit_Boolean() , TRUE) && c.colspan.value_0 == 1) {
      hpadding = c.computedPadLeft + c.computedPadRight;
      uniformMinWidth = max_0(uniformMinWidth, this$static.columnMinWidth[c.column] - hpadding);
      uniformPrefWidth = max_0(uniformPrefWidth, this$static.columnPrefWidth[c.column] - hpadding);
    }
    if (c.uniformY == TRUE) {
      vpadding = c.computedPadTop + c.computedPadBottom;
      uniformMinHeight = max_0(uniformMinHeight, this$static.rowMinHeight[c.row] - vpadding);
      uniformPrefHeight = max_0(uniformPrefHeight, this$static.rowPrefHeight[c.row] - vpadding);
    }
  }
  if (uniformPrefWidth > 0 || uniformPrefHeight > 0) {
    for (i = 0 , n = this$static.cells.size; i < n; ++i) {
      c = $get(this$static.cells, i);
      if (c.ignore.value_0)
        continue;
      if (uniformPrefWidth > 0 && c.uniformX == ($clinit_Boolean() , TRUE) && c.colspan.value_0 == 1) {
        hpadding = c.computedPadLeft + c.computedPadRight;
        this$static.columnMinWidth[c.column] = uniformMinWidth + hpadding;
        this$static.columnPrefWidth[c.column] = uniformPrefWidth + hpadding;
      }
      if (uniformPrefHeight > 0 && c.uniformY == ($clinit_Boolean() , TRUE)) {
        vpadding = c.computedPadTop + c.computedPadBottom;
        this$static.rowMinHeight[c.row] = uniformMinHeight + vpadding;
        this$static.rowPrefHeight[c.row] = uniformPrefHeight + vpadding;
      }
    }
  }
  this$static.tableMinWidth = 0;
  this$static.tableMinHeight = 0;
  this$static.tablePrefWidth = 0;
  this$static.tablePrefHeight = 0;
  for (i = 0; i < this$static.columns; ++i) {
    this$static.tableMinWidth += this$static.columnMinWidth[i];
    this$static.tablePrefWidth += this$static.columnPrefWidth[i];
  }
  for (i = 0; i < this$static.rows; ++i) {
    this$static.tableMinHeight += this$static.rowMinHeight[i];
    this$static.tablePrefHeight += max_0(this$static.rowMinHeight[i], this$static.rowPrefHeight[i]);
  }
  this$static.tableMinWidth = this$static.tableMinWidth;
  this$static.tableMinHeight = this$static.tableMinHeight;
  this$static.tablePrefWidth = max_0(this$static.tablePrefWidth, this$static.tableMinWidth);
  this$static.tablePrefHeight = max_0(this$static.tablePrefHeight, this$static.tableMinHeight);
}

function $endRow(this$static){
  var cell, i, rowColumns;
  rowColumns = 0;
  for (i = this$static.cells.size - 1; i >= 0; --i) {
    cell = $get(this$static.cells, i);
    if (cell.endRow)
      break;
    rowColumns += cell.colspan.value_0;
  }
  this$static.columns = max_1(this$static.columns, rowColumns);
  ++this$static.rows;
  $get(this$static.cells, this$static.cells.size - 1).endRow = true;
  this$static.sizeInvalid = true;
}

function $ensureSize(array, size){
  var i, n;
  if (array == null || array.length < size)
    return initDim(_3F_classLit, makeCastMap([Q$Serializable]), -1, size, 1);
  for (i = 0 , n = array.length; i < n; ++i)
    array[i] = 0;
  return array;
}

function $h(value, cell){
  return !value?0:value.get_0(cell);
}

--></script>
<script><!--
function $layout(this$static, layoutX, layoutY, layoutWidth, layoutHeight){
  var amount, c, column, currentX, currentY, extra, extraHeight, extraWidth, growHeight, growRatio, growWidth, i, lastIndex, localColumnWeightedWidth, localRowWeightedHeight, maxHeight, maxWidth, minHeight, minWidth, n, nn, prefHeight, prefWidth, spannedCellWidth, spannedWeightedWidth, tableHeight, tableWidth, totalExpandHeight, totalExpandWidth, totalGrowHeight, totalGrowWidth, used, weightedHeight, x, y;
  this$static.sizeInvalid && $computeSize(this$static);
  totalExpandWidth = 0;
  totalExpandHeight = 0;
  for (i = 0; i < this$static.columns; ++i)
    totalExpandWidth += this$static.expandWidth[i];
  for (i = 0; i < this$static.rows; ++i)
    totalExpandHeight += this$static.expandHeight[i];
  totalGrowWidth = this$static.tablePrefWidth - this$static.tableMinWidth;
  if (totalGrowWidth == 0)
    localColumnWeightedWidth = this$static.columnMinWidth;
  else {
    extraWidth = min(totalGrowWidth, max_0(0, layoutWidth - this$static.tableMinWidth));
    localColumnWeightedWidth = this$static.columnWeightedWidth = $ensureSize(this$static.columnWeightedWidth, this$static.columns);
    for (i = 0; i < this$static.columns; ++i) {
      growWidth = this$static.columnPrefWidth[i] - this$static.columnMinWidth[i];
      growRatio = growWidth / totalGrowWidth;
      localColumnWeightedWidth[i] = this$static.columnMinWidth[i] + extraWidth * growRatio;
    }
  }
  totalGrowHeight = this$static.tablePrefHeight - this$static.tableMinHeight;
  if (totalGrowHeight == 0)
    localRowWeightedHeight = this$static.rowMinHeight;
  else {
    localRowWeightedHeight = this$static.rowWeightedHeight = $ensureSize(this$static.rowWeightedHeight, this$static.rows);
    extraHeight = min(totalGrowHeight, max_0(0, layoutHeight - this$static.tableMinHeight));
    for (i = 0; i < this$static.rows; ++i) {
      growHeight = this$static.rowPrefHeight[i] - this$static.rowMinHeight[i];
      growRatio = growHeight / totalGrowHeight;
      localRowWeightedHeight[i] = this$static.rowMinHeight[i] + extraHeight * growRatio;
    }
  }
  for (i = 0 , n = this$static.cells.size; i < n; ++i) {
    c = $get(this$static.cells, i);
    if (c.ignore.value_0)
      continue;
    spannedWeightedWidth = 0;
    for (column = c.column , nn = column + c.colspan.value_0; column < nn; ++column)
      spannedWeightedWidth += localColumnWeightedWidth[column];
    weightedHeight = localRowWeightedHeight[c.row];
    prefWidth = $w(c.prefWidth, c);
    prefHeight = $h(c.prefHeight, c);
    minWidth = $w(c.minWidth, c);
    minHeight = $h(c.minHeight, c);
    maxWidth = $w(c.maxWidth, c);
    maxHeight = $h(c.maxHeight, c);
    prefWidth < minWidth && (prefWidth = minWidth);
    prefHeight < minHeight && (prefHeight = minHeight);
    maxWidth > 0 && prefWidth > maxWidth && (prefWidth = maxWidth);
    maxHeight > 0 && prefHeight > maxHeight && (prefHeight = maxHeight);
    c.widgetWidth = min(spannedWeightedWidth - c.computedPadLeft - c.computedPadRight, prefWidth);
    c.widgetHeight = min(weightedHeight - c.computedPadTop - c.computedPadBottom, prefHeight);
    c.colspan.value_0 == 1 && (this$static.columnWidth[c.column] = max_0(this$static.columnWidth[c.column], spannedWeightedWidth));
    this$static.rowHeight[c.row] = max_0(this$static.rowHeight[c.row], weightedHeight);
  }
  if (totalExpandWidth > 0) {
    extra = layoutWidth;
    for (i = 0; i < this$static.columns; ++i)
      extra -= this$static.columnWidth[i];
    used = 0;
    lastIndex = 0;
    for (i = 0; i < this$static.columns; ++i) {
      if (this$static.expandWidth[i] == 0)
        continue;
      amount = extra * this$static.expandWidth[i] / totalExpandWidth;
      this$static.columnWidth[i] += amount;
      used += amount;
      lastIndex = i;
    }
    this$static.columnWidth[lastIndex] += extra - used;
  }
  if (totalExpandHeight > 0) {
    extra = layoutHeight;
    for (i = 0; i < this$static.rows; ++i)
      extra -= this$static.rowHeight[i];
    used = 0;
    lastIndex = 0;
    for (i = 0; i < this$static.rows; ++i) {
      if (this$static.expandHeight[i] == 0)
        continue;
      amount = extra * this$static.expandHeight[i] / totalExpandHeight;
      this$static.rowHeight[i] += amount;
      used += amount;
      lastIndex = i;
    }
    this$static.rowHeight[lastIndex] += extra - used;
  }
  for (i = 0 , n = this$static.cells.size; i < n; ++i) {
    c = $get(this$static.cells, i);
    if (c.ignore.value_0)
      continue;
    if (c.colspan.value_0 == 1)
      continue;
    extraWidth = 0;
    for (column = c.column , nn = column + c.colspan.value_0; column < nn; ++column)
      extraWidth += localColumnWeightedWidth[column] - this$static.columnWidth[column];
    extraWidth -= max_0(0, c.computedPadLeft + c.computedPadRight);
    extraWidth /= c.colspan.value_0;
    if (extraWidth > 0) {
      for (column = c.column , nn = column + c.colspan.value_0; column < nn; ++column)
        this$static.columnWidth[column] += extraWidth;
    }
  }
  tableWidth = 0;
  tableHeight = 0;
  for (i = 0; i < this$static.columns; ++i)
    tableWidth += this$static.columnWidth[i];
  for (i = 0; i < this$static.rows; ++i)
    tableHeight += this$static.rowHeight[i];
  x = layoutX;
  x += (layoutWidth - tableWidth) / 2;
  y = layoutY;
  y += (layoutHeight - tableHeight) / 2;
  currentX = x;
  currentY = y;
  for (i = 0 , n = this$static.cells.size; i < n; ++i) {
    c = $get(this$static.cells, i);
    if (c.ignore.value_0)
      continue;
    spannedCellWidth = 0;
    for (column = c.column , nn = column + c.colspan.value_0; column < nn; ++column)
      spannedCellWidth += this$static.columnWidth[column];
    spannedCellWidth -= c.computedPadLeft + c.computedPadRight;
    currentX += c.computedPadLeft;
    if (c.fillX.value_0 > 0) {
      c.widgetWidth = spannedCellWidth * c.fillX.value_0;
      maxWidth = $w(c.maxWidth, c);
      maxWidth > 0 && (c.widgetWidth = min(c.widgetWidth, maxWidth));
    }
    if (c.fillY.value_0 > 0) {
      c.widgetHeight = this$static.rowHeight[c.row] * c.fillY.value_0 - c.computedPadTop - c.computedPadBottom;
      maxHeight = $h(c.maxHeight, c);
      maxHeight > 0 && (c.widgetHeight = min(c.widgetHeight, maxHeight));
    }
    (c.align.value_0 & 8) != 0?(c.widgetX = currentX):(c.align.value_0 & 16) != 0?(c.widgetX = currentX + spannedCellWidth - c.widgetWidth):(c.widgetX = currentX + (spannedCellWidth - c.widgetWidth) / 2);
    (c.align.value_0 & 2) != 0?(c.widgetY = currentY + c.computedPadTop):(c.align.value_0 & 4) != 0?(c.widgetY = currentY + this$static.rowHeight[c.row] - c.widgetHeight - c.computedPadBottom):(c.widgetY = currentY + (this$static.rowHeight[c.row] - c.widgetHeight + c.computedPadTop - c.computedPadBottom) / 2);
    if (c.endRow) {
      currentX = x;
      currentY += this$static.rowHeight[c.row];
    }
     else 
      currentX += spannedCellWidth + c.computedPadRight;
  }
  return;
}

function $row(this$static){
  this$static.cells.size > 0 && $endRow(this$static);
  this$static.rowDefaults = new Cell_0;
  $clear_0(this$static.rowDefaults);
  return this$static.rowDefaults;
}

function $w(value, cell){
  return !value?0:value.get_0(cell);
}

defineSeed(36, 1, {});
_.cellDefaults = null;
_.columnMinWidth = null;
_.columnPrefWidth = null;
_.columnWeightedWidth = null;
_.columnWidth = null;
_.columns = 0;
_.expandHeight = null;
_.expandWidth = null;
_.rowDefaults = null;
_.rowHeight = null;
_.rowMinHeight = null;
_.rowPrefHeight = null;
_.rowWeightedHeight = null;
_.rows = 0;
_.sizeInvalid = true;
_.table = null;
_.tableMinHeight = 0;
_.tableMinWidth = 0;
_.tablePrefHeight = 0;
_.tablePrefWidth = 0;
function $clear_0(this$static){
  this$static.minWidth = null;
  this$static.minHeight = null;
  this$static.prefWidth = null;
  this$static.prefHeight = null;
  this$static.maxWidth = null;
  this$static.maxHeight = null;
  this$static.spaceTop = null;
  this$static.spaceLeft = null;
  this$static.spaceBottom = null;
  this$static.spaceRight = null;
  this$static.padTop = null;
  this$static.padLeft = null;
  this$static.padBottom = null;
  this$static.padRight = null;
  this$static.fillX = null;
  this$static.fillY = null;
  this$static.align = null;
  this$static.expandX = null;
  this$static.expandY = null;
  this$static.ignore = null;
  this$static.colspan = null;
  this$static.uniformX = null;
  this$static.uniformY = null;
}

function $colspan(this$static, colspan){
  this$static.colspan = colspan;
  return this$static;
}

function $defaults(this$static){
  this$static.minWidth = new MinWidthValue_0;
  this$static.minHeight = new MinHeightValue_0;
  this$static.prefWidth = new PrefWidthValue_0;
  this$static.prefHeight = new PrefHeightValue_0;
  this$static.maxWidth = new MaxWidthValue_0;
  this$static.maxHeight = new MaxHeightValue_0;
  this$static.spaceTop = new FixedValue_0(0);
  this$static.spaceLeft = new FixedValue_0(0);
  this$static.spaceBottom = new FixedValue_0(0);
  this$static.spaceRight = new FixedValue_0(0);
  this$static.padTop = new FixedValue_0(0);
  this$static.padLeft = new FixedValue_0(0);
  this$static.padBottom = new FixedValue_0(0);
  this$static.padRight = new FixedValue_0(0);
  this$static.fillX = new Float_0(0);
  this$static.fillY = new Float_0(0);
  this$static.align = valueOf_3(1);
  this$static.expandX = valueOf_3(0);
  this$static.expandY = valueOf_3(0);
  this$static.ignore = ($clinit_Boolean() , $clinit_Boolean() , FALSE);
  this$static.colspan = valueOf_3(1);
  this$static.uniformX = null;
  this$static.uniformY = null;
}

function $expand(this$static){
  this$static.expandX = valueOf_3(1);
  this$static.expandY = valueOf_3(1);
  return this$static;
}

function $fill(this$static){
  this$static.fillX = new Float_0(1);
  this$static.fillY = new Float_0(1);
  return this$static;
}

function $merge(this$static, cell){
  if (!cell)
    return;
  !!cell.minWidth && (this$static.minWidth = cell.minWidth);
  !!cell.minHeight && (this$static.minHeight = cell.minHeight);
  !!cell.prefWidth && (this$static.prefWidth = cell.prefWidth);
  !!cell.prefHeight && (this$static.prefHeight = cell.prefHeight);
  !!cell.maxWidth && (this$static.maxWidth = cell.maxWidth);
  !!cell.maxHeight && (this$static.maxHeight = cell.maxHeight);
  !!cell.spaceTop && (this$static.spaceTop = cell.spaceTop);
  !!cell.spaceLeft && (this$static.spaceLeft = cell.spaceLeft);
  !!cell.spaceBottom && (this$static.spaceBottom = cell.spaceBottom);
  !!cell.spaceRight && (this$static.spaceRight = cell.spaceRight);
  !!cell.padTop && (this$static.padTop = cell.padTop);
  !!cell.padLeft && (this$static.padLeft = cell.padLeft);
  !!cell.padBottom && (this$static.padBottom = cell.padBottom);
  !!cell.padRight && (this$static.padRight = cell.padRight);
  !!cell.fillX && (this$static.fillX = cell.fillX);
  !!cell.fillY && (this$static.fillY = cell.fillY);
  !!cell.align && (this$static.align = cell.align);
  !!cell.expandX && (this$static.expandX = cell.expandX);
  !!cell.expandY && (this$static.expandY = cell.expandY);
  !!cell.ignore && (this$static.ignore = cell.ignore);
  !!cell.colspan && (this$static.colspan = cell.colspan);
  !!cell.uniformX && (this$static.uniformX = cell.uniformX);
  !!cell.uniformY && (this$static.uniformY = cell.uniformY);
}

function $set_0(this$static, defaults){
  this$static.minWidth = defaults.minWidth;
  this$static.minHeight = defaults.minHeight;
  this$static.prefWidth = defaults.prefWidth;
  this$static.prefHeight = defaults.prefHeight;
  this$static.maxWidth = defaults.maxWidth;
  this$static.maxHeight = defaults.maxHeight;
  this$static.spaceTop = defaults.spaceTop;
  this$static.spaceLeft = defaults.spaceLeft;
  this$static.spaceBottom = defaults.spaceBottom;
  this$static.spaceRight = defaults.spaceRight;
  this$static.padTop = defaults.padTop;
  this$static.padLeft = defaults.padLeft;
  this$static.padBottom = defaults.padBottom;
  this$static.padRight = defaults.padRight;
  this$static.fillX = defaults.fillX;
  this$static.fillY = defaults.fillY;
  this$static.align = defaults.align;
  this$static.expandX = defaults.expandX;
  this$static.expandY = defaults.expandY;
  this$static.ignore = defaults.ignore;
  this$static.colspan = defaults.colspan;
  this$static.uniformX = defaults.uniformX;
  this$static.uniformY = defaults.uniformY;
}

function $space(this$static){
  var value;
  value = new FixedValue_0(10);
  this$static.spaceTop = value;
  this$static.spaceLeft = value;
  this$static.spaceBottom = value;
  this$static.spaceRight = value;
  return this$static;
}

function Cell_0(){
}

defineSeed(37, 1, {}, Cell_0);
_.align = null;
_.cellAboveIndex = -1;
_.colspan = null;
_.column = 0;
_.computedPadBottom = 0;
_.computedPadLeft = 0;
_.computedPadRight = 0;
_.computedPadTop = 0;
_.endRow = false;
_.expandX = null;
_.expandY = null;
_.fillX = null;
_.fillY = null;
_.ignore = null;
_.maxHeight = null;
_.maxWidth = null;
_.minHeight = null;
_.minWidth = null;
_.padBottom = null;
_.padLeft = null;
_.padRight = null;
_.padTop = null;
_.prefHeight = null;
_.prefWidth = null;
_.row = 0;
_.spaceBottom = null;
_.spaceLeft = null;
_.spaceRight = null;
_.spaceTop = null;
_.uniformX = null;
_.uniformY = null;
_.widget = null;
_.widgetHeight = 0;
_.widgetWidth = 0;
_.widgetX = 0;
_.widgetY = 0;
defineSeed(39, 1, {});
defineSeed(38, 39, {});
function FixedValue_0(value){
  this.value_0 = value;
}

defineSeed(40, 39, {}, FixedValue_0);
_.get_0 = function get_0(cell){
  return this.value_0;
}
;
_.value_0 = 0;
function MaxHeightValue_0(){
}

defineSeed(41, 38, {}, MaxHeightValue_0);
_.get_0 = function get_1(cell){
  var widget;
  if (!cell)
    throw new RuntimeException_1('maxHeight can only be set on a cell property.');
  widget = cell.widget;
  if (!widget)
    return 0;
  return 0;
}
;
function MaxWidthValue_0(){
}

defineSeed(42, 38, {}, MaxWidthValue_0);
_.get_0 = function get_2(cell){
  var widget;
  if (!cell)
    throw new RuntimeException_1('maxWidth can only be set on a cell property.');
  widget = cell.widget;
  if (!widget)
    return 0;
  return 0;
}
;
function MinHeightValue_0(){
}

defineSeed(43, 38, {}, MinHeightValue_0);
_.get_0 = function get_3(cell){
  var widget;
  if (!cell)
    throw new RuntimeException_1('minHeight can only be set on a cell property.');
  widget = cell.widget;
  if (!widget)
    return 0;
  return widget.getMinHeight();
}
;
function MinWidthValue_0(){
}

defineSeed(44, 38, {}, MinWidthValue_0);
_.get_0 = function get_4(cell){
  var widget;
  if (!cell)
    throw new RuntimeException_1('minWidth can only be set on a cell property.');
  widget = cell.widget;
  if (!widget)
    return 0;
  return widget.getMinWidth();
}
;
function PrefHeightValue_0(){
}

defineSeed(45, 38, {}, PrefHeightValue_0);
_.get_0 = function get_5(cell){
  var widget;
  if (!cell)
    throw new RuntimeException_1('prefHeight can only be set on a cell property.');
  widget = cell.widget;
  if (!widget)
    return 0;
  return 0;
}
;
function PrefWidthValue_0(){
}

defineSeed(46, 38, {}, PrefWidthValue_0);
_.get_0 = function get_6(cell){
  var widget;
  if (!cell)
    throw new RuntimeException_1('prefWidth can only be set on a cell property.');
  widget = cell.widget;
  if (!widget)
    return 0;
  return 0;
}
;
defineSeed(47, 1, {});
function ReplaceStr(input, toReplace, replacement){
  var replacePos, res;
  res = input;
  replacePos = input.indexOf(toReplace);
  while (replacePos != -1) {
    res = res.substr(0, replacePos - 0) + replacement + $substring(res, replacePos + toReplace.length);
    replacePos = $indexOf_3(res, toReplace, replacePos + replacement.length);
  }
  return res;
}

function XmlDoc_0(){
  this.prologue = new XmlPrologue_0;
  this.root = new XmlTag_0;
}

defineSeed(49, 1, {}, XmlDoc_0);
_.toString$ = function toString_6(){
  var res;
  res = $toString_1(this.prologue) + $toString_2(this.root);
  return res;
}
;
function $printStackTrace(this$static){
  var causeMessage, currentCause, msg;
  msg = new StringBuffer_0;
  currentCause = this$static;
  while (currentCause) {
    causeMessage = currentCause.getMessage();
    currentCause != this$static && (msg.impl.string += 'Caused by: ' , msg);
    $append_5(msg, currentCause.___clazz$.typeName);
    msg.impl.string += ': ';
    $append_3(msg.impl, causeMessage == null?'(No exception detail)':causeMessage);
    msg.impl.string += '\n';
    currentCause = currentCause.cause;
  }
}

function $setStackTrace(stackTrace){
  var c, copy, i;
  copy = initDim(_3Ljava_lang_StackTraceElement_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$StackTraceElement, stackTrace.length, 0);
  for (i = 0 , c = stackTrace.length; i < c; ++i) {
    if (!stackTrace[i]) {
      throw new NullPointerException_0;
    }
    copy[i] = stackTrace[i];
  }
}

function $toString_0(this$static){
  var className, msg;
  className = this$static.___clazz$.typeName;
  msg = this$static.getMessage();
  return msg != null?className + ': ' + msg:className;
}

function Throwable_0(){
  $fillInStackTrace($clinit_StackTraceCreator$CollectorChrome());
}

function Throwable_1(message, cause){
  $fillInStackTrace($clinit_StackTraceCreator$CollectorChrome());
  this.cause = cause;
  this.detailMessage = message;
}

defineSeed(52, 1, makeCastMap([Q$Serializable, Q$Throwable]));
_.getMessage = function getMessage(){
  return this.detailMessage;
}
;
_.toString$ = function toString_7(){
  return $toString_0(this);
}
;
_.cause = null;
_.detailMessage = null;
function Exception_0(message){
  $fillInStackTrace($clinit_StackTraceCreator$CollectorChrome());
  this.detailMessage = message;
}

defineSeed(51, 52, makeCastMap([Q$Serializable, Q$Exception, Q$Throwable]));
function XmlParseException_0(msg, pos){
  Exception_0.call(this, msg + ' at ' + pos);
}

defineSeed(50, 51, makeCastMap([Q$XmlParseException, Q$Serializable, Q$Exception, Q$Throwable]), XmlParseException_0);
function $clinit_XmlParser(){
  $clinit_XmlParser = nullMethod;
  TagHeaderStateMachine = initValues(_3_3Lcom_github_asilvestre_jpurexml_XmlParser$TagHeaderStates_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$int_$1, [initValues(_3Lcom_github_asilvestre_jpurexml_XmlParser$TagHeaderStates_2_classLit, makeCastMap([Q$int_$1, Q$Serializable]), -1, [0, 1, 6, 6, 6, 6]), initValues(_3Lcom_github_asilvestre_jpurexml_XmlParser$TagHeaderStates_2_classLit, makeCastMap([Q$int_$1, Q$Serializable]), -1, [1, 6, 2, 6, 6, 6]), initValues(_3Lcom_github_asilvestre_jpurexml_XmlParser$TagHeaderStates_2_classLit, makeCastMap([Q$int_$1, Q$Serializable]), -1, [3, 6, 2, 4, 5, 6]), initValues(_3Lcom_github_asilvestre_jpurexml_XmlParser$TagHeaderStates_2_classLit, makeCastMap([Q$int_$1, Q$Serializable]), -1, [3, 6, 6, 4, 5, 6]), initValues(_3Lcom_github_asilvestre_jpurexml_XmlParser$TagHeaderStates_2_classLit, makeCastMap([Q$int_$1, Q$Serializable]), -1, [6, 6, 6, 6, 5, 6])]);
  AttrStateMachine = initValues(_3_3Lcom_github_asilvestre_jpurexml_XmlParser$AttrStates_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$int_$1, [initValues(_3Lcom_github_asilvestre_jpurexml_XmlParser$AttrStates_2_classLit, makeCastMap([Q$int_$1, Q$Serializable]), -1, [0, 1, 8, 8, 8, 8, 8]), initValues(_3Lcom_github_asilvestre_jpurexml_XmlParser$AttrStates_2_classLit, makeCastMap([Q$int_$1, Q$Serializable]), -1, [2, 1, 3, 8, 8, 8, 8]), initValues(_3Lcom_github_asilvestre_jpurexml_XmlParser$AttrStates_2_classLit, makeCastMap([Q$int_$1, Q$Serializable]), -1, [2, 8, 3, 8, 8, 8, 8]), initValues(_3Lcom_github_asilvestre_jpurexml_XmlParser$AttrStates_2_classLit, makeCastMap([Q$int_$1, Q$Serializable]), -1, [4, 8, 8, 5, 6, 8, 8]), initValues(_3Lcom_github_asilvestre_jpurexml_XmlParser$AttrStates_2_classLit, makeCastMap([Q$int_$1, Q$Serializable]), -1, [4, 8, 8, 5, 6, 8, 8]), initValues(_3Lcom_github_asilvestre_jpurexml_XmlParser$AttrStates_2_classLit, makeCastMap([Q$int_$1, Q$Serializable]), -1, [5, 5, 5, 7, 5, 5, 8]), initValues(_3Lcom_github_asilvestre_jpurexml_XmlParser$AttrStates_2_classLit, makeCastMap([Q$int_$1, Q$Serializable]), -1, [6, 6, 6, 6, 7, 6, 8])]);
  TagContentStateMachine = initValues(_3_3Lcom_github_asilvestre_jpurexml_XmlParser$TagContentStates_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$int_$1, [initValues(_3Lcom_github_asilvestre_jpurexml_XmlParser$TagContentStates_2_classLit, makeCastMap([Q$int_$1, Q$Serializable]), -1, [0, 1, 4, 4]), initValues(_3Lcom_github_asilvestre_jpurexml_XmlParser$TagContentStates_2_classLit, makeCastMap([Q$int_$1, Q$Serializable]), -1, [3, 4, 2, 4]), initValues(_3Lcom_github_asilvestre_jpurexml_XmlParser$TagContentStates_2_classLit, makeCastMap([Q$int_$1, Q$Serializable]), -1, [0, 1, 4, 4])]);
  EscapedEntities = initValues(_3Lcom_github_asilvestre_jpurexml_XmlParser$StringPair_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$XmlParser$StringPair, [new XmlParser$StringPair_0('&lt', '<'), new XmlParser$StringPair_0('&gt', '>'), new XmlParser$StringPair_0('&amp', '&'), new XmlParser$StringPair_0('&apos', "'"), new XmlParser$StringPair_0('&quot', '"')]);
}

function escapeXmlLiteral(literal, skip){
  $clinit_XmlParser();
  var i, res, skipSet;
  res = literal;
  skipSet = new TreeSet_0;
  if (skip != null) {
    for (i = 0; i < skip.length; ++i) {
      $add_13(skipSet, skip[i]);
    }
  }
  for (i = 0; i < EscapedEntities.length; ++i) {
    $contains_3(skipSet, EscapedEntities[i].second) || (res = ReplaceStr(res, EscapedEntities[i].second, EscapedEntities[i].first));
  }
  return res;
}

function hasChildren(xml, pointer, parentName){
  var $e0, res;
  res = false;
  try {
    parseEndTag(xml, pointer, parentName);
  }
   catch ($e0) {
    $e0 = caught_0($e0);
    if (instanceOf($e0, Q$XmlParseException)) {
      res = true;
    }
     else 
      throw $e0;
  }
  return res;
}

function parseAttributeList(xml, pointer, attributes){
  var action, attrDone, done, i, name_0, newState, nextChar, parserData, state, value, res, res_0;
  i = pointer;
  do {
    state = 0;
    parserData = new XmlParser$AttrParserData_0;
    attrDone = i >= xml.length;
    while (!attrDone) {
      nextChar = xml.charCodeAt(i);
      action = (res = ($clinit_XmlParser$AttrActions() , NameChar) , isSpace(nextChar)?(res = Space):nextChar == 60 || nextChar == 62?(res = Invalid):nextChar == 61?(res = Separator):nextChar == 39?(res = SingleQuote):nextChar == 34?(res = DoubleQuote):nextChar == 47 && (res = Slash) , res);
      newState = AttrStateMachine[state][action.ordinal];
      state != newState?(i = (res_0 = i + 1 , state != 1 && newState == 1?(parserData.nameStart = i):state == 1 && newState != 1?(parserData.nameEnd = i):state != 5 && newState == 5 || state != 6 && newState == 6?(parserData.valueStart = i + 1):(state == 5 && newState == 7 || state == 6 && newState == 7) && (parserData.valueEnd = i) , newState == 8 && (res_0 = i) , res_0)):++i;
      state = newState;
      attrDone = i >= xml.length || newState == 7 || newState == 8;
    }
    if (state == 7) {
      name_0 = $substring_0(xml, parserData.nameStart, parserData.nameEnd);
      value = $substring_0(xml, parserData.valueStart, parserData.valueEnd);
      value = unescapeXmlLiteral(value);
      attributes.put(name_0, value);
    }
    done = i >= xml.length || state == 8;
  }
   while (!done);
  return i;
}

function parseCDATA(xml, pos, parserData){
  var cdataEnd, contentBit, correct, res;
  correct = !(pos < 0 || pos >= xml.length) && xml.indexOf('<![CDATA[', pos) == pos;
  res = pos;
  if (correct) {
    cdataEnd = xml.indexOf(']]>', pos);
    correct = cdataEnd != -1;
    if (correct) {
      contentBit = xml.substr(pos + 9, cdataEnd - (pos + 9));
      $add_12(parserData.contentBits, contentBit);
      res = cdataEnd + 3;
    }
  }
  if (!correct) {
    throw new XmlParseException_0('Error parsing CDATA block', pos);
  }
  return res;
}

function parseEndTag(xml, pointer, tagName){
  var correct, endPos, potentialParentEndTag, res;
  correct = !(pointer < 0 || pointer >= xml.length) && xml.indexOf('<\/', pointer) == pointer;
  endPos = xml.indexOf('>', pointer);
  correct && (correct = endPos != -1);
  if (correct) {
    potentialParentEndTag = xml.substr(pointer + 2, endPos - (pointer + 2));
    potentialParentEndTag = $trim(potentialParentEndTag);
    correct = $equals_0(tagName, potentialParentEndTag);
  }
  if (correct) {
    res = endPos + 1;
  }
   else {
    throw new XmlParseException_0('Expecting end tag <' + tagName + '>', pointer);
  }
  return res;
}

function parsePrologue(xml, prologue){
  var prologueAttrs, prologueEnd, prologueStart, prologueString;
  prologue.version = '1.0';
  prologue.encoding = 'UTF-8';
  prologueStart = xml.indexOf('<?xml');
  prologueEnd = xml.indexOf('?>', prologueStart);
  if (prologueStart != -1 && prologueEnd != -1) {
    prologueString = xml.substr(prologueStart + 5, prologueEnd - (prologueStart + 5));
    prologueAttrs = new HashMap_0;
    parseAttributeList(prologueString, 0, prologueAttrs);
    prologueAttrs.containsKey('version') && (prologue.version = prologueAttrs.get_1('version'));
    prologueAttrs.containsKey('encoding') && (prologue.encoding = prologueAttrs.get_1('encoding'));
  }
  return prologueEnd != -1?prologueEnd + 2:0;
}

function parseTag(xml, pointer, tag){
  var child, childrenPos, headerEnd, res;
  headerEnd = parseTagHeader(xml, pointer, tag);
  if (tag.empty) {
    res = headerEnd;
  }
   else {
    childrenPos = parseTagContent(xml, headerEnd, tag);
    while (hasChildren(xml, childrenPos, tag.name_0)) {
      child = new XmlTag_0;
      childrenPos = parseTag(xml, childrenPos, child);
      $add_12(tag.children, child);
      childrenPos = parseTagContent(xml, childrenPos, tag);
    }
    res = parseEndTag(xml, childrenPos, tag.name_0);
  }
  return res;
}

function parseTagContent(xml, pointer, tag){
  var action, contentBit, done, i, newState, nextChar, parserData, state, res;
  state = 0;
  parserData = new XmlParser$TagContentParserData_0(pointer);
  i = pointer;
  done = pointer >= xml.length;
  while (!done) {
    nextChar = xml.charCodeAt(i);
    action = (res = ($clinit_XmlParser$TagContentActions() , Char) , nextChar == 60?(res = TagInit):nextChar == 33?(res = Exclamation):(nextChar == 62 || nextChar == 39 || nextChar == 34) && (res = Invalid_0) , res);
    newState = TagContentStateMachine[state][action.ordinal];
    state != newState?(i = processTagContentStateTransition(xml, i, state, newState, parserData)):++i;
    state = newState;
    done = i >= xml.length || newState == 3 || newState == 4;
  }
  if (state == 3) {
    contentBit = $poll_1(parserData.contentBits);
    while (contentBit != null) {
      tag.content_0 += contentBit;
      contentBit = $poll_1(parserData.contentBits);
    }
    i -= 2;
  }
   else {
    throw new XmlParseException_0('Error parsing tag content', i);
  }
  return i;
}

function parseTagHeader(xml, pointer, tag){
  var action, done, i, name_0, newState, nextChar, parserData, state, res, res_0;
  state = 0;
  parserData = new XmlParser$TagHeaderParserData_0;
  i = pointer;
  done = pointer >= xml.length;
  while (!done) {
    nextChar = xml.charCodeAt(i);
    action = (res = ($clinit_XmlParser$TagHeaderActions() , NameChar_0) , isSpace(nextChar)?(res = Space_0):nextChar == 60?(res = TagInit_0):nextChar == 62?(res = TagEnd):nextChar == 47?(res = Slash_0):(nextChar == 39 || nextChar == 34) && (res = Invalid_1) , res);
    newState = TagHeaderStateMachine[state][action.ordinal];
    state != newState?(i = (res_0 = i + 1 , state != 2 && newState == 2?(parserData.nameStart = i):state == 2 && newState != 2 && (parserData.nameEnd = i) , state != 3 && newState == 3 && (res_0 = parseAttributeList(xml, i, parserData.attributes)) , newState == 4 && (parserData.empty = true) , res_0)):++i;
    state = newState;
    done = i >= xml.length || newState == 5 || newState == 6;
  }
  if (state == 5) {
    name_0 = $substring_0(xml, parserData.nameStart, parserData.nameEnd);
    tag.name_0 = name_0;
    tag.attributes = parserData.attributes;
    tag.empty = parserData.empty;
  }
   else {
    throw new XmlParseException_0('Error parsing tag header', i);
  }
  return i;
}

function parseXml(xml){
  $clinit_XmlParser();
  var procXml, prologEnd, res;
  res = new XmlDoc_0;
  procXml = removeComments(xml);
  prologEnd = parsePrologue(procXml, res.prologue);
  parseTag(procXml, prologEnd, res.root);
  return res;
}

function processTagContentStateTransition(xml, pos, from, to, parserData){
  var contentBit, res;
  res = pos + 1;
  from != 0 && to == 0 && (parserData.lastContentStart = pos);
  if (from == 0 && to != 0) {
    if (pos != parserData.lastContentStart) {
      contentBit = $substring_0(xml, parserData.lastContentStart, pos);
      contentBit = $trim(contentBit);
      contentBit = unescapeXmlLiteral(contentBit);
      contentBit = (res_0 = ReplaceStr(contentBit, '\n', '') , res_0 = ReplaceStr(res_0, '\t', '') , ReplaceStr(res_0, '\r', ''));
      $add_12(parserData.contentBits, contentBit);
    }
  }
   else 
    from != 2 && to == 2 && (res = parseCDATA(xml, pos - 1, parserData));
  return res;
}

function removeComments(xml){
  var commentEnd, commentPos, res;
  res = xml;
  commentPos = xml.indexOf('<!--');
  while (commentPos != -1) {
    commentEnd = res.indexOf('-->');
    if (commentEnd == -1) {
      throw new XmlParseException_0("Missing comment ending '-->'", commentPos);
    }
    res = res.substr(0, commentPos - 0) + $substring(res, commentEnd + 3);
    commentPos = res.indexOf('<!--');
  }
  return res;
}

function unescapeXmlLiteral(literal){
  var i, res;
  res = literal;
  for (i = 0; i < EscapedEntities.length; ++i) {
    res = ReplaceStr(res, EscapedEntities[i].first, EscapedEntities[i].second);
  }
  return res;
}

var AttrStateMachine, EscapedEntities, TagContentStateMachine, TagHeaderStateMachine;
--></script>
<script><!--
function $clinit_XmlParser$AttrActions(){
  $clinit_XmlParser$AttrActions = nullMethod;
  Space = new XmlParser$AttrActions_0('Space', 0);
  NameChar = new XmlParser$AttrActions_0('NameChar', 1);
  Separator = new XmlParser$AttrActions_0('Separator', 2);
  SingleQuote = new XmlParser$AttrActions_0('SingleQuote', 3);
  DoubleQuote = new XmlParser$AttrActions_0('DoubleQuote', 4);
  Slash = new XmlParser$AttrActions_0('Slash', 5);
  Invalid = new XmlParser$AttrActions_0('Invalid', 6);
  $VALUES_2 = initValues(_3Lcom_github_asilvestre_jpurexml_XmlParser$AttrActions_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$XmlParser$AttrActions, [Space, NameChar, Separator, SingleQuote, DoubleQuote, Slash, Invalid]);
}

function XmlParser$AttrActions_0(enum$name, enum$ordinal){
  Enum_0.call(this, enum$name, enum$ordinal);
}

function values_3(){
  $clinit_XmlParser$AttrActions();
  return $VALUES_2;
}

defineSeed(54, 11, makeCastMap([Q$XmlParser$AttrActions, Q$Serializable, Q$Comparable, Q$Enum]), XmlParser$AttrActions_0);
var $VALUES_2, DoubleQuote, Invalid, NameChar, Separator, SingleQuote, Slash, Space;
function XmlParser$AttrParserData_0(){
}

defineSeed(55, 1, {}, XmlParser$AttrParserData_0);
_.nameEnd = 0;
_.nameStart = 0;
_.valueEnd = 0;
_.valueStart = 0;
function values_4(){
  return $VALUES_3;
}

var $VALUES_3 = null;
function XmlParser$StringPair_0(first, second){
  this.first = first;
  this.second = second;
}

defineSeed(57, 1, makeCastMap([Q$XmlParser$StringPair]), XmlParser$StringPair_0);
_.first = null;
_.second = null;
function $clinit_XmlParser$TagContentActions(){
  $clinit_XmlParser$TagContentActions = nullMethod;
  Char = new XmlParser$TagContentActions_0('Char', 0);
  TagInit = new XmlParser$TagContentActions_0('TagInit', 1);
  Exclamation = new XmlParser$TagContentActions_0('Exclamation', 2);
  Invalid_0 = new XmlParser$TagContentActions_0('Invalid', 3);
  $VALUES_4 = initValues(_3Lcom_github_asilvestre_jpurexml_XmlParser$TagContentActions_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$XmlParser$TagContentActions, [Char, TagInit, Exclamation, Invalid_0]);
}

function XmlParser$TagContentActions_0(enum$name, enum$ordinal){
  Enum_0.call(this, enum$name, enum$ordinal);
}

function values_5(){
  $clinit_XmlParser$TagContentActions();
  return $VALUES_4;
}

defineSeed(58, 11, makeCastMap([Q$XmlParser$TagContentActions, Q$Serializable, Q$Comparable, Q$Enum]), XmlParser$TagContentActions_0);
var $VALUES_4, Char, Exclamation, Invalid_0, TagInit;
function XmlParser$TagContentParserData_0(pos){
  this.contentBits = new LinkedList_0;
  this.lastContentStart = pos;
}

defineSeed(59, 1, {}, XmlParser$TagContentParserData_0);
_.lastContentStart = 0;
function values_6(){
  return $VALUES_5;
}

var $VALUES_5 = null;
function $clinit_XmlParser$TagHeaderActions(){
  $clinit_XmlParser$TagHeaderActions = nullMethod;
  Space_0 = new XmlParser$TagHeaderActions_0('Space', 0);
  TagInit_0 = new XmlParser$TagHeaderActions_0('TagInit', 1);
  NameChar_0 = new XmlParser$TagHeaderActions_0('NameChar', 2);
  Slash_0 = new XmlParser$TagHeaderActions_0('Slash', 3);
  TagEnd = new XmlParser$TagHeaderActions_0('TagEnd', 4);
  Invalid_1 = new XmlParser$TagHeaderActions_0('Invalid', 5);
  $VALUES_6 = initValues(_3Lcom_github_asilvestre_jpurexml_XmlParser$TagHeaderActions_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$XmlParser$TagHeaderActions, [Space_0, TagInit_0, NameChar_0, Slash_0, TagEnd, Invalid_1]);
}

function XmlParser$TagHeaderActions_0(enum$name, enum$ordinal){
  Enum_0.call(this, enum$name, enum$ordinal);
}

function values_7(){
  $clinit_XmlParser$TagHeaderActions();
  return $VALUES_6;
}

defineSeed(61, 11, makeCastMap([Q$XmlParser$TagHeaderActions, Q$Serializable, Q$Comparable, Q$Enum]), XmlParser$TagHeaderActions_0);
var $VALUES_6, Invalid_1, NameChar_0, Slash_0, Space_0, TagEnd, TagInit_0;
function XmlParser$TagHeaderParserData_0(){
  this.attributes = new HashMap_0;
}

defineSeed(62, 1, {}, XmlParser$TagHeaderParserData_0);
_.empty = false;
_.nameEnd = 0;
_.nameStart = 0;
function values_8(){
  return $VALUES_7;
}

var $VALUES_7 = null;
function $toString_1(this$static){
  var res;
  res = '<?xml version="' + this$static.version + '" encoding="' + this$static.encoding + '"?>';
  return res;
}

function XmlPrologue_0(){
}

defineSeed(64, 1, {}, XmlPrologue_0);
_.toString$ = function toString_8(){
  return $toString_1(this);
}
;
_.encoding = null;
_.version = null;
function $clinit_XmlTag(){
  $clinit_XmlTag = nullMethod;
  SpecialChars = initValues(_3C_classLit, makeCastMap([Q$Serializable]), -1, [10, 13, 9, 60, 62, 38, 39, 34]);
}

function $contentHasSpecialChars(this$static){
  var i, res;
  res = false;
  for (i = 0; i < SpecialChars.length && !res; ++i) {
    res = $indexOf_2(this$static.content_0, fromCodePoint(SpecialChars[i])) != -1;
  }
  res = res || !$equals_0($trim(this$static.content_0), this$static.content_0);
  return res;
}

function $toString_2(this$static){
  var attrStr, child, childIter, childrenStr, key, keyIter, procContent, res, sortedKeyIter, treeSet, value, valueHasDoubleQuotes;
  attrStr = '';
  keyIter = $iterator($keySet(this$static.attributes));
  treeSet = new TreeSet_0;
  while (keyIter.val$outerIter.hasNext()) {
    $add_13(treeSet, $next_3(keyIter));
  }
  sortedKeyIter = $iterator($keySet(treeSet.map));
  while (sortedKeyIter.val$outerIter.hasNext()) {
    key = escapeXmlLiteral($next_3(sortedKeyIter), null);
    value = escapeXmlLiteral(this$static.attributes.get_1(key), initValues(_3Ljava_lang_String_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$String, ['"', "'"]));
    valueHasDoubleQuotes = value.indexOf('"') != -1;
    valueHasDoubleQuotes?(attrStr += key + "='" + value + "' "):(attrStr += key + '="' + value + '" ');
  }
  res = '<' + escapeXmlLiteral(this$static.name_0, null) + ' ' + attrStr;
  this$static.empty?(res += '/>'):(res += '>');
  if (!this$static.empty) {
    childrenStr = '';
    childIter = $listIterator(this$static.children, 0);
    while (childIter.currentNode != childIter.this$0.header) {
      child = $next_7(childIter);
      childrenStr += $toString_2(child);
    }
    $contentHasSpecialChars(this$static)?(procContent = '<![CDATA[' + this$static.content_0 + ']]>'):(procContent = this$static.content_0);
    res = res + childrenStr + procContent + '<\/' + escapeXmlLiteral(this$static.name_0, null) + '>';
  }
  return res;
}

function XmlTag_0(){
  $clinit_XmlTag();
  this.attributes = new HashMap_0;
  this.children = new LinkedList_0;
}

defineSeed(65, 1, {}, XmlTag_0);
_.toString$ = function toString_9(){
  return $toString_2(this);
}
;
_.content_0 = '';
_.empty = false;
_.name_0 = '';
var SpecialChars;
function equals__devirtual$(this$static, other){
  var maybeJsoInvocation;
  return maybeJsoInvocation = this$static , isJavaObject(maybeJsoInvocation)?maybeJsoInvocation.equals$(other):maybeJsoInvocation === other;
}

function getClass__devirtual$(this$static){
  var maybeJsoInvocation;
  return maybeJsoInvocation = this$static , isJavaObject(maybeJsoInvocation)?maybeJsoInvocation.___clazz$:Lcom_google_gwt_core_client_JavaScriptObject_2_classLit;
}

function hashCode__devirtual$(this$static){
  var maybeJsoInvocation;
  return maybeJsoInvocation = this$static , isJavaObject(maybeJsoInvocation)?maybeJsoInvocation.hashCode$():getHashCode(maybeJsoInvocation);
}

function toString__devirtual$(this$static){
  var maybeJsoInvocation;
  return maybeJsoInvocation = this$static , isJavaObject(maybeJsoInvocation)?maybeJsoInvocation.toString$():maybeJsoInvocation.toString?maybeJsoInvocation.toString():'[JavaScriptObject]';
}

function $clearRect(this$static, x, y, w, h_0){
  this$static.clearRect(x, y, w, h_0);
}

function $createPattern(this$static, image, repetition){
  return this$static.createPattern(image, repetition);
}

function $drawImage(this$static, image, dx, dy, dw, dh){
  this$static.drawImage(image, dx, dy, dw, dh);
}

function $drawImage_0(this$static, image, sx, sy, sw, sh, dx, dy, dw, dh){
  this$static.drawImage(image, sx, sy, sw, sh, dx, dy, dw, dh);
}

function $fillRect(this$static, x, y, w, h_0){
  this$static.fillRect(x, y, w, h_0);
}

function $fillText(this$static, text, x, y){
  this$static.fillText && this$static.fillText(text, x, y);
}

function $lineTo(this$static, x, y){
  this$static.lineTo(x, y);
}

function $moveTo(this$static, x, y){
  this$static.moveTo(x, y);
}

function $rotate(this$static, angle){
  this$static.rotate(angle);
}

function $scale(this$static, x, y){
  this$static.scale(x, y);
}

function $setFillStyleWeb(this$static, fillStyle){
  this$static.fillStyle = fillStyle;
}

function $setFont(this$static, f){
  this$static.font = f;
}

function $setGlobalAlpha(this$static, alpha){
  this$static.globalAlpha = alpha;
}

function $setLineWidth(this$static, lineWidth){
  this$static.lineWidth = lineWidth;
}

function $setStrokeStyleWeb(this$static, strokeStyle){
  this$static.strokeStyle = strokeStyle;
}

function $setTextBaseline(this$static, baseline){
  this$static.textBaseline = baseline;
}

function $transform(this$static, m11, m12, m21, m22, dx, dy){
  this$static.transform(m11, m12, m21, m22, dx, dy);
}

function $translate(this$static, x, y){
  this$static.translate(x, y);
}

function $clinit_Context2d$Repetition(){
  $clinit_Context2d$Repetition = nullMethod;
  NO_REPEAT = new Context2d$Repetition_0('NO_REPEAT', 0, 'no-repeat');
  REPEAT = new Context2d$Repetition_0('REPEAT', 1, 'repeat');
  REPEAT_X = new Context2d$Repetition_0('REPEAT_X', 2, 'repeat-x');
  REPEAT_Y = new Context2d$Repetition_0('REPEAT_Y', 3, 'repeat-y');
  $VALUES_8 = initValues(_3Lcom_google_gwt_canvas_dom_client_Context2d$Repetition_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Context2d$Repetition, [NO_REPEAT, REPEAT, REPEAT_X, REPEAT_Y]);
}

function Context2d$Repetition_0(enum$name, enum$ordinal, value){
  Enum_0.call(this, enum$name, enum$ordinal);
  this.value_0 = value;
}

function values_9(){
  $clinit_Context2d$Repetition();
  return $VALUES_8;
}

defineSeed(70, 11, makeCastMap([Q$Context2d$Repetition, Q$Serializable, Q$Comparable, Q$Enum]), Context2d$Repetition_0);
_.value_0 = null;
var $VALUES_8, NO_REPEAT, REPEAT, REPEAT_X, REPEAT_Y;
function $clinit_Context2d$TextBaseline(){
  $clinit_Context2d$TextBaseline = nullMethod;
  ALPHABETIC = new Context2d$TextBaseline_0('ALPHABETIC', 0, 'alphabetic');
  BOTTOM = new Context2d$TextBaseline_0('BOTTOM', 1, 'bottom');
  HANGING = new Context2d$TextBaseline_0('HANGING', 2, 'hanging');
  IDEOGRAPHIC = new Context2d$TextBaseline_0('IDEOGRAPHIC', 3, 'ideographic');
  MIDDLE = new Context2d$TextBaseline_0('MIDDLE', 4, 'middle');
  TOP = new Context2d$TextBaseline_0('TOP', 5, 'top');
  $VALUES_9 = initValues(_3Lcom_google_gwt_canvas_dom_client_Context2d$TextBaseline_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Context2d$TextBaseline, [ALPHABETIC, BOTTOM, HANGING, IDEOGRAPHIC, MIDDLE, TOP]);
}

function Context2d$TextBaseline_0(enum$name, enum$ordinal, value){
  Enum_0.call(this, enum$name, enum$ordinal);
  this.value_0 = value;
}

function values_10(){
  $clinit_Context2d$TextBaseline();
  return $VALUES_9;
}

defineSeed(71, 11, makeCastMap([Q$Context2d$TextBaseline, Q$Serializable, Q$Comparable, Q$Enum]), Context2d$TextBaseline_0);
_.value_0 = null;
var $VALUES_9, ALPHABETIC, BOTTOM, HANGING, IDEOGRAPHIC, MIDDLE, TOP;
function currentTimeMillis(){
  return (new Date).getTime();
}

function setUncaughtExceptionHandler(handler){
  sUncaughtExceptionHandler = handler;
}

var sUncaughtExceptionHandler = null;
function RuntimeException_0(){
  Throwable_0.call(this);
}

function RuntimeException_1(message){
  Exception_0.call(this, message);
}

function RuntimeException_2(message, cause){
  Throwable_1.call(this, message, cause);
}

function RuntimeException_3(cause){
  $fillInStackTrace($clinit_StackTraceCreator$CollectorChrome());
  this.detailMessage = !cause?null:$toString_0(cause);
  this.cause = cause;
}

defineSeed(77, 51, makeCastMap([Q$Serializable, Q$Exception, Q$RuntimeException, Q$Throwable]), RuntimeException_1, RuntimeException_2, RuntimeException_3);
function JavaScriptException_0(e){
  RuntimeException_0.call(this);
  this.e = e;
  this.description_0 = '';
  $createStackTrace(new StackTraceCreator$CollectorChromeNoSourceMap_0, this);
}

function getExceptionDescription(e){
  return instanceOfJso(e)?e == null?null:e.message:e + '';
}

function getExceptionName(e){
  return e == null?'null':instanceOfJso(e)?e == null?null:e.name:instanceOf(e, Q$String)?'String':getClass__devirtual$(e).typeName;
}

function getExceptionProperties(e){
  return instanceOfJso(e)?$getProperties(($clinit_StackTraceCreator$CollectorChrome() , e)):'';
}

defineSeed(76, 77, makeCastMap([Q$JavaScriptException, Q$Serializable, Q$Exception, Q$RuntimeException, Q$Throwable]), JavaScriptException_0);
_.getMessage = function getMessage_0(){
  this.message_0 == null && (this.name_0 = getExceptionName(this.e) , this.description_0 = this.description_0 + ': ' + getExceptionDescription(this.e) , this.message_0 = '(' + this.name_0 + ') ' + getExceptionProperties(this.e) + this.description_0 , undefined);
  return this.message_0;
}
;
_.description_0 = '';
_.e = null;
_.message_0 = null;
_.name_0 = null;
function $push(this$static, value){
  this$static[this$static.length] = value;
}

function $push_0(this$static, value){
  this$static[this$static.length] = value;
}

function $push_1(this$static, value){
  this$static[this$static.length] = value;
}

defineSeed(84, 1, {});
function apply(jsFunction, thisObj, arguments_0){
  return jsFunction.apply(thisObj, arguments_0);
  var __0;
}

function enter(){
  var now;
  if (entryDepth != 0) {
    now = currentTimeMillis();
    if (now - watchdogEntryDepthLastScheduled > 2000) {
      watchdogEntryDepthLastScheduled = now;
      watchdogEntryDepthTimerId = watchdogEntryDepthSchedule();
    }
  }
  if (entryDepth++ == 0) {
    $flushEntryCommands(($clinit_SchedulerImpl() , INSTANCE));
    return true;
  }
  return false;
}

function entry_0(jsFunction){
  return function(){
    try {
      return entry0(jsFunction, this, arguments);
    }
     catch (e) {
      throw e;
    }
  }
  ;
}

function entry0(jsFunction, thisObj, arguments_0){
  var $e0, initialEntry, t;
  initialEntry = enter();
  try {
    if (sUncaughtExceptionHandler) {
      try {
        return apply(jsFunction, thisObj, arguments_0);
      }
       catch ($e0) {
        $e0 = caught_0($e0);
        if (instanceOf($e0, Q$Throwable)) {
          t = $e0;
          $error_0(($clinit_HtmlPlatform() , log_0), 'Uncaught Exception: ', t);
          return undefined;
        }
         else 
          throw $e0;
      }
    }
     else {
      return apply(jsFunction, thisObj, arguments_0);
    }
  }
   finally {
    exit(initialEntry);
  }
}

function exit(initialEntry){
  initialEntry && $flushFinallyCommands(($clinit_SchedulerImpl() , INSTANCE));
  --entryDepth;
  if (initialEntry) {
    if (watchdogEntryDepthTimerId != -1) {
      watchdogEntryDepthCancel(watchdogEntryDepthTimerId);
      watchdogEntryDepthTimerId = -1;
    }
  }
}

function getHashCode(o){
  return o.$H || (o.$H = ++sNextHashId);
}

function watchdogEntryDepthCancel(timerId){
  $wnd.clearTimeout(timerId);
}

function watchdogEntryDepthSchedule(){
  return $wnd.setTimeout(function(){
    entryDepth != 0 && (entryDepth = 0);
    watchdogEntryDepthTimerId = -1;
  }
  , 10);
}

var entryDepth = 0, sNextHashId = 0, watchdogEntryDepthLastScheduled = 0, watchdogEntryDepthTimerId = -1;
function $clinit_SchedulerImpl(){
  $clinit_SchedulerImpl = nullMethod;
  INSTANCE = new SchedulerImpl_0;
}

function $flushEntryCommands(this$static){
  var oldQueue, rescheduled;
  if (this$static.entryCommands) {
    rescheduled = null;
    do {
      oldQueue = this$static.entryCommands;
      this$static.entryCommands = null;
      rescheduled = runScheduledTasks(oldQueue, rescheduled);
    }
     while (this$static.entryCommands);
    this$static.entryCommands = rescheduled;
  }
}

function $flushFinallyCommands(this$static){
  var oldQueue, rescheduled;
  if (this$static.finallyCommands) {
    rescheduled = null;
    do {
      oldQueue = this$static.finallyCommands;
      this$static.finallyCommands = null;
      rescheduled = runScheduledTasks(oldQueue, rescheduled);
    }
     while (this$static.finallyCommands);
    this$static.finallyCommands = rescheduled;
  }
}

function $flushPostEventPumpCommands(this$static){
  var oldDeferred;
  if (this$static.deferredCommands) {
    oldDeferred = this$static.deferredCommands;
    this$static.deferredCommands = null;
    !this$static.incrementalCommands && (this$static.incrementalCommands = []);
    runScheduledTasks(oldDeferred, this$static.incrementalCommands);
  }
  !!this$static.incrementalCommands && (this$static.incrementalCommands = runRepeatingTasks(this$static.incrementalCommands));
}

function $isWorkQueued(this$static){
  return !!this$static.deferredCommands || !!this$static.incrementalCommands;
}

function $maybeSchedulePostEventPumpCommands(this$static){
  if (!this$static.shouldBeRunning) {
    this$static.shouldBeRunning = true;
    !this$static.flusher && (this$static.flusher = new SchedulerImpl$Flusher_0(this$static));
    scheduleFixedDelayImpl(this$static.flusher, 1);
    !this$static.rescue && (this$static.rescue = new SchedulerImpl$Rescuer_0(this$static));
    scheduleFixedDelayImpl(this$static.rescue, 50);
  }
}

function $scheduleDeferred(this$static, cmd){
  this$static.deferredCommands = push(this$static.deferredCommands, [cmd, false]);
  $maybeSchedulePostEventPumpCommands(this$static);
}

function SchedulerImpl_0(){
}

function execute_2(cmd){
  return cmd.execute_0();
}

function push(queue, task){
  !queue && (queue = []);
  $push(queue, task);
  return queue;
}

function runRepeatingTasks(tasks){
  var canceledSomeTasks, i, length_0, newTasks, start, t;
  length_0 = tasks.length;
  if (length_0 == 0) {
    return null;
  }
  canceledSomeTasks = false;
  start = currentTimeMillis();
  while (currentTimeMillis() - start < 100) {
    for (i = 0; i < length_0; ++i) {
      t = tasks[i];
      if (!t) {
        continue;
      }
      if (!t[0].execute_0()) {
        tasks[i] = null;
        canceledSomeTasks = true;
      }
    }
  }
  if (canceledSomeTasks) {
    newTasks = [];
    for (i = 0; i < length_0; ++i) {
      !!tasks[i] && (newTasks[newTasks.length] = tasks[i] , undefined);
    }
    return newTasks.length == 0?null:newTasks;
  }
   else {
    return tasks;
  }
}

function runScheduledTasks(tasks, rescheduled){
  var $e0, e, i, j, t;
  for (i = 0 , j = tasks.length; i < j; ++i) {
    t = tasks[i];
    try {
      t[1]?t[0].execute_0() && (rescheduled = push(rescheduled, t)):t[0].execute();
    }
     catch ($e0) {
      $e0 = caught_0($e0);
      if (instanceOf($e0, Q$Throwable)) {
        e = $e0;
        !!sUncaughtExceptionHandler && $error_0(($clinit_HtmlPlatform() , log_0), 'Uncaught Exception: ', e);
      }
       else 
        throw $e0;
    }
  }
  return rescheduled;
}

function scheduleFixedDelayImpl(cmd, delayMs){
  $clinit_SchedulerImpl();
  $wnd.setTimeout(function(){
    var ret = $entry(execute_2)(cmd);
    ret && $wnd.setTimeout(arguments.callee, delayMs);
  }
  , delayMs);
}

defineSeed(86, 84, {}, SchedulerImpl_0);
_.deferredCommands = null;
_.entryCommands = null;
_.finallyCommands = null;
_.flushRunning = false;
_.flusher = null;
_.incrementalCommands = null;
_.rescue = null;
_.shouldBeRunning = false;
var INSTANCE;
function SchedulerImpl$Flusher_0(this$0){
  this.this$0 = this$0;
}

defineSeed(87, 1, {}, SchedulerImpl$Flusher_0);
_.execute_0 = function execute_3(){
  this.this$0.flushRunning = true;
  $flushPostEventPumpCommands(this.this$0);
  this.this$0.flushRunning = false;
  return this.this$0.shouldBeRunning = $isWorkQueued(this.this$0);
}
;
_.this$0 = null;
function SchedulerImpl$Rescuer_0(this$0){
  this.this$0 = this$0;
}

defineSeed(88, 1, {}, SchedulerImpl$Rescuer_0);
_.execute_0 = function execute_4(){
  this.this$0.flushRunning && scheduleFixedDelayImpl(this.this$0.flusher, 1);
  return this.this$0.shouldBeRunning;
}
;
_.this$0 = null;
function extractNameFromToString(fnToString){
  var index, start, toReturn;
  toReturn = '';
  fnToString = $trim(fnToString);
  index = fnToString.indexOf('(');
  start = fnToString.indexOf('function') == 0?8:0;
  if (index == -1) {
    index = $indexOf_2(fnToString, fromCodePoint(64));
    start = fnToString.indexOf('function ') == 0?9:0;
  }
  index != -1 && (toReturn = $trim(fnToString.substr(start, index - start)));
  return toReturn.length > 0?toReturn:'anonymous';
}

function parseInt_0(number){
  return parseInt(number) || -1;
}

function splice_1(arr, length_0){
  arr.length >= length_0 && arr.splice(0, length_0);
  return arr;
}

function $getProperties(e){
  var result = '';
  try {
    for (var prop in e) {
      if (prop != 'name' && prop != 'message' && prop != 'toString') {
        try {
          result += '\n ' + prop + ': ' + e[prop];
        }
         catch (ignored) {
        }
      }
    }
  }
   catch (ignored) {
  }
  return result;
}

function $makeException(){
  try {
    null.a();
  }
   catch (e) {
    return e;
  }
}

function StackTraceCreator$Collector_0(){
}

defineSeed(91, 1, {}, StackTraceCreator$Collector_0);
_.collect = function collect(){
  var seen = {};
  var toReturn = [];
  var callee = arguments.callee.caller.caller;
  while (callee) {
    var name_0 = this.extractName(callee.toString());
    toReturn.push(name_0);
    var keyName = ':' + name_0;
    var withThisName = seen[keyName];
    if (withThisName) {
      var i, j;
      for (i = 0 , j = withThisName.length; i < j; i++) {
        if (withThisName[i] === callee) {
          return toReturn;
        }
      }
    }
    (withThisName || (seen[keyName] = [])).push(callee);
    callee = callee.caller;
  }
  return toReturn;
}
;
_.extractName = function extractName(fnToString){
  return extractNameFromToString(fnToString);
}
;
_.inferFrom = function inferFrom(e){
  return [];
}
;
function $inferFrom(this$static, e){
  var i, j, stack;
  stack = e && e.stack?e.stack.split('\n'):[];
  for (i = 0 , j = stack.length; i < j; ++i) {
    stack[i] = this$static.extractName(stack[i]);
  }
  return stack;
}

defineSeed(93, 91, {});
_.collect = function collect_0(){
  return splice_1(this.inferFrom($makeException()), this.toSplice());
}
;
_.inferFrom = function inferFrom_0(e){
  return $inferFrom(this, e);
}
;
_.toSplice = function toSplice(){
  return 2;
}
;
function $clinit_StackTraceCreator$CollectorChrome(){
  $clinit_StackTraceCreator$CollectorChrome = nullMethod;
  Error.stackTraceLimit = 128;
}

function $collect(this$static){
  var res;
  res = splice_1($inferFrom_0(this$static, $makeException()), 3);
  res.length == 0 && (res = splice_1((new StackTraceCreator$Collector_0).collect(), 1));
  return res;
}

function $createStackTrace(this$static, e){
  var stack;
  stack = $inferFrom_0(this$static, instanceOfJso(e.e)?e.e:null);
  $parseStackTrace(stack);
}

function $fillInStackTrace(){
  var stack;
  stack = $collect(new StackTraceCreator$CollectorChromeNoSourceMap_0);
  $parseStackTrace(stack);
}

function $inferFrom_0(this$static, e){
  var stack;
  stack = $inferFrom(this$static, e);
  return stack.length == 0?(new StackTraceCreator$Collector_0).inferFrom(e):splice_1(stack, 1);
}

function $parseStackTrace(stack){
  var col, endFileUrl, fileName, i, j, lastColon, location_0, stackElements, stackTrace;
  stackTrace = initDim(_3Ljava_lang_StackTraceElement_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$StackTraceElement, stack.length, 0);
  for (i = 0 , j = stackTrace.length; i < j; ++i) {
    stackElements = $split(stack[i], '@@', 0);
    col = -1;
    fileName = 'Unknown';
    if (stackElements.length == 2 && stackElements[1] != null) {
      location_0 = stackElements[1];
      lastColon = $lastIndexOf(location_0, fromCodePoint(58));
      endFileUrl = $lastIndexOf_0(location_0, fromCodePoint(58), lastColon - 1);
      fileName = location_0.substr(0, endFileUrl - 0);
      if (lastColon != -1 && endFileUrl != -1) {
        parseInt_0(location_0.substr(endFileUrl + 1, lastColon - (endFileUrl + 1)));
        col = parseInt_0($substring(location_0, lastColon + 1));
      }
    }
    stackTrace[i] = new StackTraceElement_0(stackElements[0], fileName + '@' + col);
  }
  $setStackTrace(stackTrace);
}

defineSeed(92, 93, {});
_.collect = function collect_1(){
  return $collect(this);
}
;
_.extractName = function extractName_0(fnToString){
  var closeParen, index, location_0, toReturn;
  if (fnToString.length == 0) {
    return 'anonymous';
  }
  toReturn = $trim(fnToString);
  toReturn.indexOf('at ') == 0 && (toReturn = $substring(toReturn, 3));
  index = toReturn.indexOf('[');
  index != -1 && (toReturn = $trim(toReturn.substr(0, index - 0)) + $trim($substring(toReturn, toReturn.indexOf(']', index) + 1)));
  index = toReturn.indexOf('(');
  if (index == -1) {
    location_0 = toReturn;
    toReturn = '';
  }
   else {
    closeParen = toReturn.indexOf(')', index);
    location_0 = toReturn.substr(index + 1, closeParen - (index + 1));
    toReturn = $trim(toReturn.substr(0, index - 0));
  }
  index = $indexOf_2(toReturn, fromCodePoint(46));
  index != -1 && (toReturn = $substring(toReturn, index + 1));
  return (toReturn.length > 0?toReturn:'anonymous') + '@@' + location_0;
}
;
_.inferFrom = function inferFrom_1(e){
  return $inferFrom_0(this, e);
}
;
_.toSplice = function toSplice_0(){
  return 3;
}
;
function StackTraceCreator$CollectorChromeNoSourceMap_0(){
  $clinit_StackTraceCreator$CollectorChrome();
}

defineSeed(94, 92, {}, StackTraceCreator$CollectorChromeNoSourceMap_0);
defineSeed(95, 1, {});
function $append(this$static, x){
  this$static.string += x;
}

function $append_0(this$static, x){
  this$static.string += x;
}

function $append_1(this$static, x){
  this$static.string += x;
}

function $append_2(this$static, x){
  this$static.string += x;
}

function $append_3(this$static, x){
  this$static.string += x;
}

function $appendNonNull(this$static, x){
  this$static.string += x;
}

function $replace(this$static, start, end){
  this$static.string = $substring_0(this$static.string, 0, start) + '' + $substring(this$static.string, end);
}

function StringBufferImplAppend_0(){
}

defineSeed(96, 95, {}, StringBufferImplAppend_0);
_.string = '';
function $appendChild(this$static, newChild){
  return this$static.appendChild(newChild);
}

function $removeChild(this$static, oldChild){
  return this$static.removeChild(oldChild);
}

function $setBooleanAttr(this$static, value){
  value?(this$static.setAttribute('loop', '') , undefined):(this$static.removeAttribute('loop') , undefined);
}

function $setSrc(this$static, url){
  this$static.src = url;
}

function $setVolume_1(this$static, volume){
  this$static.volume = volume;
}

function $setHeight(this$static, height){
  this$static.height = height;
}

function $setWidth(this$static, width){
  this$static.width = width;
}

function $eventGetButton(evt){
  var button = evt.button;
  if (button == 1) {
    return 4;
  }
   else if (button == 2) {
    return 2;
  }
  return 1;
}

function $isOrHasChild(parent_0, child){
  return parent_0.contains(child);
}

function $setInnerText(elem, text){
  elem.textContent = text || '';
}

function $getAbsoluteLeft(elem){
  var rect;
  rect = getBoundingClientRect(elem);
  return rect?rect.left + $getScrollLeft(elem.ownerDocument.body):getAbsoluteLeftUsingOffsets(elem);
}

function $getAbsoluteTop(elem){
  var rect;
  rect = getBoundingClientRect(elem);
  return rect?rect.top + (elem.ownerDocument.body.scrollTop || 0):getAbsoluteTopUsingOffsets(elem);
}

function $getScrollLeft(elem){
  if (elem.ownerDocument.defaultView.getComputedStyle(elem, '').direction == 'rtl') {
    return (elem.scrollLeft || 0) - ((elem.scrollWidth || 0) - elem.clientWidth);
  }
  return elem.scrollLeft || 0;
}

function $getTabIndex(elem){
  return typeof elem.tabIndex != 'undefined'?elem.tabIndex:-1;
}

function getAbsoluteLeftUsingOffsets(elem){
  if (elem.offsetLeft == null) {
    return 0;
  }
  var left = 0;
  var doc = elem.ownerDocument;
  var curr = elem.parentNode;
  if (curr) {
    while (curr.offsetParent) {
      left -= curr.scrollLeft;
      doc.defaultView.getComputedStyle(curr, '').getPropertyValue('direction') == 'rtl' && (left += curr.scrollWidth - curr.clientWidth);
      curr = curr.parentNode;
    }
  }
  while (elem) {
    left += elem.offsetLeft;
    if (doc.defaultView.getComputedStyle(elem, '')['position'] == 'fixed') {
      left += doc.body.scrollLeft;
      return left;
    }
    var parent_0 = elem.offsetParent;
    parent_0 && $wnd.devicePixelRatio && (left += parseInt(doc.defaultView.getComputedStyle(parent_0, '').getPropertyValue('border-left-width')));
    if (parent_0 && parent_0.tagName == 'BODY' && elem.style.position == 'absolute') {
      break;
    }
    elem = parent_0;
  }
  return left;
}

function getAbsoluteTopUsingOffsets(elem){
  if (elem.offsetTop == null) {
    return 0;
  }
  var top_0 = 0;
  var doc = elem.ownerDocument;
  var curr = elem.parentNode;
  if (curr) {
    while (curr.offsetParent) {
      top_0 -= curr.scrollTop;
      curr = curr.parentNode;
    }
  }
  while (elem) {
    top_0 += elem.offsetTop;
    if (doc.defaultView.getComputedStyle(elem, '')['position'] == 'fixed') {
      top_0 += doc.body.scrollTop;
      return top_0;
    }
    var parent_0 = elem.offsetParent;
    parent_0 && $wnd.devicePixelRatio && (top_0 += parseInt(doc.defaultView.getComputedStyle(parent_0, '').getPropertyValue('border-top-width')));
    if (parent_0 && parent_0.tagName == 'BODY' && elem.style.position == 'absolute') {
      break;
    }
    elem = parent_0;
  }
  return top_0;
}

--></script>
<script><!--
function getBoundingClientRect(element){
  return element.getBoundingClientRect && element.getBoundingClientRect();
}

function $clinit_Style$FontStyle(){
  $clinit_Style$FontStyle = nullMethod;
  NORMAL = new Style$FontStyle$1_0;
  ITALIC = new Style$FontStyle$2_0;
  OBLIQUE = new Style$FontStyle$3_0;
  $VALUES_10 = initValues(_3Lcom_google_gwt_dom_client_Style$FontStyle_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Style$FontStyle, [NORMAL, ITALIC, OBLIQUE]);
}

function values_11(){
  $clinit_Style$FontStyle();
  return $VALUES_10;
}

defineSeed(113, 11, makeCastMap([Q$Style$FontStyle, Q$Style$HasCssName, Q$Serializable, Q$Comparable, Q$Enum]));
var $VALUES_10, ITALIC, NORMAL, OBLIQUE;
function Style$FontStyle$1_0(){
  Enum_0.call(this, 'NORMAL', 0);
}

defineSeed(114, 113, makeCastMap([Q$Style$FontStyle, Q$Style$HasCssName, Q$Serializable, Q$Comparable, Q$Enum]), Style$FontStyle$1_0);
function Style$FontStyle$2_0(){
  Enum_0.call(this, 'ITALIC', 1);
}

defineSeed(115, 113, makeCastMap([Q$Style$FontStyle, Q$Style$HasCssName, Q$Serializable, Q$Comparable, Q$Enum]), Style$FontStyle$2_0);
function Style$FontStyle$3_0(){
  Enum_0.call(this, 'OBLIQUE', 2);
}

defineSeed(116, 113, makeCastMap([Q$Style$FontStyle, Q$Style$HasCssName, Q$Serializable, Q$Comparable, Q$Enum]), Style$FontStyle$3_0);
function $clinit_Style$FontWeight(){
  $clinit_Style$FontWeight = nullMethod;
  NORMAL_0 = new Style$FontWeight$1_0;
  BOLD = new Style$FontWeight$2_0;
  BOLDER = new Style$FontWeight$3_0;
  LIGHTER = new Style$FontWeight$4_0;
  $VALUES_11 = initValues(_3Lcom_google_gwt_dom_client_Style$FontWeight_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Style$FontWeight, [NORMAL_0, BOLD, BOLDER, LIGHTER]);
}

function values_12(){
  $clinit_Style$FontWeight();
  return $VALUES_11;
}

defineSeed(117, 11, makeCastMap([Q$Style$FontWeight, Q$Style$HasCssName, Q$Serializable, Q$Comparable, Q$Enum]));
var $VALUES_11, BOLD, BOLDER, LIGHTER, NORMAL_0;
function Style$FontWeight$1_0(){
  Enum_0.call(this, 'NORMAL', 0);
}

defineSeed(118, 117, makeCastMap([Q$Style$FontWeight, Q$Style$HasCssName, Q$Serializable, Q$Comparable, Q$Enum]), Style$FontWeight$1_0);
function Style$FontWeight$2_0(){
  Enum_0.call(this, 'BOLD', 1);
}

defineSeed(119, 117, makeCastMap([Q$Style$FontWeight, Q$Style$HasCssName, Q$Serializable, Q$Comparable, Q$Enum]), Style$FontWeight$2_0);
function Style$FontWeight$3_0(){
  Enum_0.call(this, 'BOLDER', 2);
}

defineSeed(120, 117, makeCastMap([Q$Style$FontWeight, Q$Style$HasCssName, Q$Serializable, Q$Comparable, Q$Enum]), Style$FontWeight$3_0);
function Style$FontWeight$4_0(){
  Enum_0.call(this, 'LIGHTER', 3);
}

defineSeed(121, 117, makeCastMap([Q$Style$FontWeight, Q$Style$HasCssName, Q$Serializable, Q$Comparable, Q$Enum]), Style$FontWeight$4_0);
function $clinit_Style$Overflow(){
  $clinit_Style$Overflow = nullMethod;
  VISIBLE = new Style$Overflow$1_0;
  HIDDEN = new Style$Overflow$2_0;
  SCROLL = new Style$Overflow$3_0;
  AUTO = new Style$Overflow$4_0;
  $VALUES_12 = initValues(_3Lcom_google_gwt_dom_client_Style$Overflow_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Style$Overflow, [VISIBLE, HIDDEN, SCROLL, AUTO]);
}

function values_13(){
  $clinit_Style$Overflow();
  return $VALUES_12;
}

defineSeed(122, 11, makeCastMap([Q$Style$HasCssName, Q$Style$Overflow, Q$Serializable, Q$Comparable, Q$Enum]));
var $VALUES_12, AUTO, HIDDEN, SCROLL, VISIBLE;
function Style$Overflow$1_0(){
  Enum_0.call(this, 'VISIBLE', 0);
}

defineSeed(123, 122, makeCastMap([Q$Style$HasCssName, Q$Style$Overflow, Q$Serializable, Q$Comparable, Q$Enum]), Style$Overflow$1_0);
function Style$Overflow$2_0(){
  Enum_0.call(this, 'HIDDEN', 1);
}

defineSeed(124, 122, makeCastMap([Q$Style$HasCssName, Q$Style$Overflow, Q$Serializable, Q$Comparable, Q$Enum]), Style$Overflow$2_0);
function Style$Overflow$3_0(){
  Enum_0.call(this, 'SCROLL', 2);
}

defineSeed(125, 122, makeCastMap([Q$Style$HasCssName, Q$Style$Overflow, Q$Serializable, Q$Comparable, Q$Enum]), Style$Overflow$3_0);
function Style$Overflow$4_0(){
  Enum_0.call(this, 'AUTO', 3);
}

defineSeed(126, 122, makeCastMap([Q$Style$HasCssName, Q$Style$Overflow, Q$Serializable, Q$Comparable, Q$Enum]), Style$Overflow$4_0);
function $clinit_Style$Position(){
  $clinit_Style$Position = nullMethod;
  STATIC = new Style$Position$1_0;
  RELATIVE = new Style$Position$2_0;
  ABSOLUTE = new Style$Position$3_0;
  FIXED = new Style$Position$4_0;
  $VALUES_13 = initValues(_3Lcom_google_gwt_dom_client_Style$Position_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Style$Position, [STATIC, RELATIVE, ABSOLUTE, FIXED]);
}

function values_14(){
  $clinit_Style$Position();
  return $VALUES_13;
}

defineSeed(127, 11, makeCastMap([Q$Style$HasCssName, Q$Style$Position, Q$Serializable, Q$Comparable, Q$Enum]));
var $VALUES_13, ABSOLUTE, FIXED, RELATIVE, STATIC;
function Style$Position$1_0(){
  Enum_0.call(this, 'STATIC', 0);
}

defineSeed(128, 127, makeCastMap([Q$Style$HasCssName, Q$Style$Position, Q$Serializable, Q$Comparable, Q$Enum]), Style$Position$1_0);
function Style$Position$2_0(){
  Enum_0.call(this, 'RELATIVE', 1);
}

defineSeed(129, 127, makeCastMap([Q$Style$HasCssName, Q$Style$Position, Q$Serializable, Q$Comparable, Q$Enum]), Style$Position$2_0);
function Style$Position$3_0(){
  Enum_0.call(this, 'ABSOLUTE', 2);
}

defineSeed(130, 127, makeCastMap([Q$Style$HasCssName, Q$Style$Position, Q$Serializable, Q$Comparable, Q$Enum]), Style$Position$3_0);
function Style$Position$4_0(){
  Enum_0.call(this, 'FIXED', 3);
}

defineSeed(131, 127, makeCastMap([Q$Style$HasCssName, Q$Style$Position, Q$Serializable, Q$Comparable, Q$Enum]), Style$Position$4_0);
function $clinit_Style$Unit(){
  $clinit_Style$Unit = nullMethod;
  PX = new Style$Unit$1_0;
  PCT = new Style$Unit$2_0;
  EM = new Style$Unit$3_0;
  EX = new Style$Unit$4_0;
  PT = new Style$Unit$5_0;
  PC = new Style$Unit$6_0;
  IN = new Style$Unit$7_0;
  CM = new Style$Unit$8_0;
  MM = new Style$Unit$9_0;
  $VALUES_14 = initValues(_3Lcom_google_gwt_dom_client_Style$Unit_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Style$Unit, [PX, PCT, EM, EX, PT, PC, IN, CM, MM]);
}

function values_15(){
  $clinit_Style$Unit();
  return $VALUES_14;
}

defineSeed(132, 11, makeCastMap([Q$Style$Unit, Q$Serializable, Q$Comparable, Q$Enum]));
var $VALUES_14, CM, EM, EX, IN, MM, PC, PCT, PT, PX;
function Style$Unit$1_0(){
  Enum_0.call(this, 'PX', 0);
}

defineSeed(133, 132, makeCastMap([Q$Style$Unit, Q$Serializable, Q$Comparable, Q$Enum]), Style$Unit$1_0);
function Style$Unit$2_0(){
  Enum_0.call(this, 'PCT', 1);
}

defineSeed(134, 132, makeCastMap([Q$Style$Unit, Q$Serializable, Q$Comparable, Q$Enum]), Style$Unit$2_0);
function Style$Unit$3_0(){
  Enum_0.call(this, 'EM', 2);
}

defineSeed(135, 132, makeCastMap([Q$Style$Unit, Q$Serializable, Q$Comparable, Q$Enum]), Style$Unit$3_0);
function Style$Unit$4_0(){
  Enum_0.call(this, 'EX', 3);
}

defineSeed(136, 132, makeCastMap([Q$Style$Unit, Q$Serializable, Q$Comparable, Q$Enum]), Style$Unit$4_0);
function Style$Unit$5_0(){
  Enum_0.call(this, 'PT', 4);
}

defineSeed(137, 132, makeCastMap([Q$Style$Unit, Q$Serializable, Q$Comparable, Q$Enum]), Style$Unit$5_0);
function Style$Unit$6_0(){
  Enum_0.call(this, 'PC', 5);
}

defineSeed(138, 132, makeCastMap([Q$Style$Unit, Q$Serializable, Q$Comparable, Q$Enum]), Style$Unit$6_0);
function Style$Unit$7_0(){
  Enum_0.call(this, 'IN', 6);
}

defineSeed(139, 132, makeCastMap([Q$Style$Unit, Q$Serializable, Q$Comparable, Q$Enum]), Style$Unit$7_0);
function Style$Unit$8_0(){
  Enum_0.call(this, 'CM', 7);
}

defineSeed(140, 132, makeCastMap([Q$Style$Unit, Q$Serializable, Q$Comparable, Q$Enum]), Style$Unit$8_0);
function Style$Unit$9_0(){
  Enum_0.call(this, 'MM', 8);
}

defineSeed(141, 132, makeCastMap([Q$Style$Unit, Q$Serializable, Q$Comparable, Q$Enum]), Style$Unit$9_0);
function $clinit_Style$Visibility(){
  $clinit_Style$Visibility = nullMethod;
  VISIBLE_0 = new Style$Visibility$1_0;
  HIDDEN_0 = new Style$Visibility$2_0;
  $VALUES_15 = initValues(_3Lcom_google_gwt_dom_client_Style$Visibility_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Style$Visibility, [VISIBLE_0, HIDDEN_0]);
}

function values_16(){
  $clinit_Style$Visibility();
  return $VALUES_15;
}

defineSeed(142, 11, makeCastMap([Q$Style$HasCssName, Q$Style$Visibility, Q$Serializable, Q$Comparable, Q$Enum]));
var $VALUES_15, HIDDEN_0, VISIBLE_0;
function Style$Visibility$1_0(){
  Enum_0.call(this, 'VISIBLE', 0);
}

defineSeed(143, 142, makeCastMap([Q$Style$HasCssName, Q$Style$Visibility, Q$Serializable, Q$Comparable, Q$Enum]), Style$Visibility$1_0);
function Style$Visibility$2_0(){
  Enum_0.call(this, 'HIDDEN', 1);
}

defineSeed(144, 142, makeCastMap([Q$Style$HasCssName, Q$Style$Visibility, Q$Serializable, Q$Comparable, Q$Enum]), Style$Visibility$2_0);
function $clinit_Style$WhiteSpace(){
  $clinit_Style$WhiteSpace = nullMethod;
  NORMAL_1 = new Style$WhiteSpace$1_0;
  NOWRAP = new Style$WhiteSpace$2_0;
  PRE = new Style$WhiteSpace$3_0;
  PRE_LINE = new Style$WhiteSpace$4_0;
  PRE_WRAP = new Style$WhiteSpace$5_0;
  $VALUES_16 = initValues(_3Lcom_google_gwt_dom_client_Style$WhiteSpace_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Style$WhiteSpace, [NORMAL_1, NOWRAP, PRE, PRE_LINE, PRE_WRAP]);
}

function values_17(){
  $clinit_Style$WhiteSpace();
  return $VALUES_16;
}

defineSeed(145, 11, makeCastMap([Q$Style$HasCssName, Q$Style$WhiteSpace, Q$Serializable, Q$Comparable, Q$Enum]));
var $VALUES_16, NORMAL_1, NOWRAP, PRE, PRE_LINE, PRE_WRAP;
function Style$WhiteSpace$1_0(){
  Enum_0.call(this, 'NORMAL', 0);
}

defineSeed(146, 145, makeCastMap([Q$Style$HasCssName, Q$Style$WhiteSpace, Q$Serializable, Q$Comparable, Q$Enum]), Style$WhiteSpace$1_0);
function Style$WhiteSpace$2_0(){
  Enum_0.call(this, 'NOWRAP', 1);
}

defineSeed(147, 145, makeCastMap([Q$Style$HasCssName, Q$Style$WhiteSpace, Q$Serializable, Q$Comparable, Q$Enum]), Style$WhiteSpace$2_0);
function Style$WhiteSpace$3_0(){
  Enum_0.call(this, 'PRE', 2);
}

defineSeed(148, 145, makeCastMap([Q$Style$HasCssName, Q$Style$WhiteSpace, Q$Serializable, Q$Comparable, Q$Enum]), Style$WhiteSpace$3_0);
function Style$WhiteSpace$4_0(){
  Enum_0.call(this, 'PRE_LINE', 3);
}

defineSeed(149, 145, makeCastMap([Q$Style$HasCssName, Q$Style$WhiteSpace, Q$Serializable, Q$Comparable, Q$Enum]), Style$WhiteSpace$4_0);
function Style$WhiteSpace$5_0(){
  Enum_0.call(this, 'PRE_WRAP', 4);
}

defineSeed(150, 145, makeCastMap([Q$Style$HasCssName, Q$Style$WhiteSpace, Q$Serializable, Q$Comparable, Q$Enum]), Style$WhiteSpace$5_0);
function $getRelativeX(this$static, target){
  return this$static.clientX - $getAbsoluteLeft(target) + $getScrollLeft(target) + $getScrollLeft(target.ownerDocument.body);
}

function $getRelativeY(this$static, target){
  return this$static.clientY - $getAbsoluteTop(target) + (target.scrollTop || 0) + (target.ownerDocument.body.scrollTop || 0);
}

defineSeed(154, 1, {});
_.toString$ = function toString_10(){
  return 'An event type';
}
;
_.source = null;
function $overrideSource(this$static, source){
  this$static.source = source;
}

defineSeed(153, 154, {});
_.dead = false;
function $setNativeEvent(this$static, nativeEvent){
  this$static.nativeEvent = nativeEvent;
}

function $setRelativeElement(this$static, relativeElem){
  this$static.relativeElem = relativeElem;
}

function fireNativeEvent(nativeEvent, handlerSource, relativeElem){
  var currentNative, currentRelativeElem, typeKey;
  if (registered) {
    typeKey = $unsafeGet(registered, nativeEvent.type);
    if (typeKey) {
      currentNative = typeKey.flyweight.nativeEvent;
      currentRelativeElem = typeKey.flyweight.relativeElem;
      $setNativeEvent(typeKey.flyweight, nativeEvent);
      $setRelativeElement(typeKey.flyweight, relativeElem);
      $fireEvent_0(handlerSource, typeKey.flyweight);
      $setNativeEvent(typeKey.flyweight, currentNative);
      $setRelativeElement(typeKey.flyweight, currentRelativeElem);
    }
  }
}

defineSeed(152, 153, {});
_.getAssociatedType = function getAssociatedType(){
  return $clinit_EndedEvent() , TYPE;
}
;
_.nativeEvent = null;
_.relativeElem = null;
var registered = null;
defineSeed(157, 1, {});
_.hashCode$ = function hashCode_3(){
  return this.index_0;
}
;
_.toString$ = function toString_11(){
  return 'Event type';
}
;
_.index_0 = 0;
var nextHashCode = 0;
function GwtEvent$Type_0(){
  this.index_0 = ++nextHashCode;
}

defineSeed(156, 157, {}, GwtEvent$Type_0);
function DomEvent$Type_0(flyweight){
  GwtEvent$Type_0.call(this);
  this.flyweight = flyweight;
  !registered && (registered = new PrivateMap_0);
  registered.map['ended'] = this;
  this.name_0 = 'ended';
}

defineSeed(155, 156, {}, DomEvent$Type_0);
_.flyweight = null;
_.name_0 = null;
function $clinit_EndedEvent(){
  $clinit_EndedEvent = nullMethod;
  TYPE = new DomEvent$Type_0(new EndedEvent_0);
}

function EndedEvent_0(){
}

defineSeed(158, 152, {}, EndedEvent_0);
_.dispatch = function dispatch(handler){
  $fireOnPlaybackComplete(handler.this$0.soundHandlerCollection, handler.this$0);
}
;
var TYPE;
function $unsafeGet(this$static, key){
  return this$static.map[key];
}

function PrivateMap_0(){
  this.map = {};
}

defineSeed(159, 1, {}, PrivateMap_0);
_.map = null;
function CloseEvent_0(){
}

function fire(source){
  var event_0;
  if (TYPE_0) {
    event_0 = new CloseEvent_0;
    $fireEvent(source, event_0);
  }
}

defineSeed(161, 153, {}, CloseEvent_0);
_.dispatch = function dispatch_0(handler){
  detachWidgets();
}
;
_.getAssociatedType = function getAssociatedType_0(){
  return TYPE_0;
}
;
var TYPE_0 = null;
function $addHandler(this$static, type, handler){
  return new LegacyHandlerWrapper_0($doAdd(this$static.eventBus, type, handler));
}

function $fireEvent(this$static, event_0){
  var $e0, e, oldSource;
  !event_0.dead || (event_0.dead = false , event_0.source = null);
  oldSource = event_0.source;
  $overrideSource(event_0, this$static.source);
  try {
    $doFire(this$static.eventBus, event_0);
  }
   catch ($e0) {
    $e0 = caught_0($e0);
    if (instanceOf($e0, Q$UmbrellaException)) {
      e = $e0;
      throw new UmbrellaException_2(e.causes);
    }
     else 
      throw $e0;
  }
   finally {
    oldSource == null?(event_0.dead = true , event_0.source = null):(event_0.source = oldSource);
  }
}

function HandlerManager_0(source){
  this.eventBus = new HandlerManager$Bus_0;
  this.source = source;
}

defineSeed(162, 1, makeCastMap([Q$HasHandlers]), HandlerManager_0);
_.eventBus = null;
_.source = null;
defineSeed(165, 1, {});
function $defer(this$static, command){
  !this$static.deferredDeltas && (this$static.deferredDeltas = new ArrayList_0);
  $add_0(this$static.deferredDeltas, command);
}

function $doAdd(this$static, type, handler){
  if (!type) {
    throw new NullPointerException_1('Cannot add a handler with a null type');
  }
  if (!handler) {
    throw new NullPointerException_1('Cannot add a null handler');
  }
  this$static.firingDepth > 0?$defer(this$static, new SimpleEventBus$2_0(this$static, type, handler)):$doAddNow(this$static, type, null, handler);
  return new SimpleEventBus$1_0(this$static, type, handler);
}

function $doAddNow(this$static, type, source, handler){
  var l_0;
  l_0 = $ensureHandlerList(this$static, type, source);
  l_0.add(handler);
}

function $doFire(this$static, event_0){
  var $e0, causes, e, handler, handlers, it;
  if (!event_0) {
    throw new NullPointerException_1('Cannot fire null event');
  }
  try {
    ++this$static.firingDepth;
    handlers = $getDispatchList(this$static, event_0.getAssociatedType());
    causes = null;
    it = this$static.isReverseOrder?handlers.listIterator_0(handlers.size_0()):handlers.listIterator();
    while (this$static.isReverseOrder?it.hasPrevious():it.hasNext()) {
      handler = this$static.isReverseOrder?it.previous_0():it.next_0();
      try {
        event_0.dispatch(handler);
      }
       catch ($e0) {
        $e0 = caught_0($e0);
        if (instanceOf($e0, Q$Throwable)) {
          e = $e0;
          !causes && (causes = new HashSet_0);
          $add_11(causes, e);
        }
         else 
          throw $e0;
      }
    }
    if (causes) {
      throw new UmbrellaException_1(causes);
    }
  }
   finally {
    --this$static.firingDepth;
    this$static.firingDepth == 0 && $handleQueuedAddsAndRemoves(this$static);
  }
}

function $doRemoveNow(this$static, type, source, handler){
  var l_0, removed, sourceMap;
  l_0 = $getHandlerList(this$static, type, source);
  removed = l_0.remove(handler);
  removed && l_0.isEmpty() && (sourceMap = this$static.map.get_1(type) , sourceMap.remove_1(source) , sourceMap.isEmpty() && this$static.map.remove_1(type) , undefined);
}

function $ensureHandlerList(this$static, type, source){
  var handlers, sourceMap;
  sourceMap = this$static.map.get_1(type);
  if (!sourceMap) {
    sourceMap = new HashMap_0;
    this$static.map.put(type, sourceMap);
  }
  handlers = sourceMap.get_1(source);
  if (!handlers) {
    handlers = new ArrayList_0;
    sourceMap.put(source, handlers);
  }
  return handlers;
}

function $getDispatchList(this$static, type){
  var directHandlers;
  directHandlers = $getHandlerList(this$static, type, null);
  return directHandlers;
}

function $getHandlerList(this$static, type, source){
  var handlers, sourceMap;
  sourceMap = this$static.map.get_1(type);
  if (!sourceMap) {
    return $clinit_Collections() , $clinit_Collections() , EMPTY_LIST;
  }
  handlers = sourceMap.get_1(source);
  if (!handlers) {
    return $clinit_Collections() , $clinit_Collections() , EMPTY_LIST;
  }
  return handlers;
}

function $handleQueuedAddsAndRemoves(this$static){
  var c, c$iterator;
  if (this$static.deferredDeltas) {
    try {
      for (c$iterator = new AbstractList$IteratorImpl_0(this$static.deferredDeltas); c$iterator.i < c$iterator.this$0_0.size_0();) {
        c = $next_2(c$iterator);
        c.execute();
      }
    }
     finally {
      this$static.deferredDeltas = null;
    }
  }
}

defineSeed(164, 165, {});
_.deferredDeltas = null;
_.firingDepth = 0;
_.isReverseOrder = false;
function $doRemove(this$static, type, source, handler){
  this$static.firingDepth > 0?$defer(this$static, new SimpleEventBus$3_0(this$static, type, source, handler)):$doRemoveNow(this$static, type, source, handler);
}

function HandlerManager$Bus_0(){
  this.map = new HashMap_0;
  this.isReverseOrder = false;
}

defineSeed(163, 164, {}, HandlerManager$Bus_0);
function LegacyHandlerWrapper_0(real){
  this.real = real;
}

defineSeed(166, 1, {}, LegacyHandlerWrapper_0);
_.real = null;
function UmbrellaException_1(causes){
  RuntimeException_2.call(this, makeMessage(causes), makeCause(causes));
  this.causes = causes;
}

function makeCause(causes){
  var iterator;
  iterator = causes.iterator_0();
  if (!iterator.hasNext()) {
    return null;
  }
  return iterator.next_0();
}

function makeMessage(causes){
  var b, count, first, t, t$iterator;
  count = causes.size_0();
  if (count == 0) {
    return null;
  }
  b = new StringBuilder_1(count == 1?'Exception caught: ':count + ' exceptions caught: ');
  first = true;
  for (t$iterator = causes.iterator_0(); t$iterator.hasNext();) {
    t = t$iterator.next_0();
    first?(first = false):(b.impl.string += '; ' , b);
    $append_12(b, t.getMessage());
  }
  return b.impl.string;
}

defineSeed(168, 77, makeCastMap([Q$UmbrellaException, Q$Serializable, Q$Exception, Q$RuntimeException, Q$Throwable]), UmbrellaException_1);
_.causes = null;
function UmbrellaException_2(causes){
  UmbrellaException_1.call(this, causes);
}

defineSeed(167, 168, makeCastMap([Q$UmbrellaException, Q$Serializable, Q$Exception, Q$RuntimeException, Q$Throwable]), UmbrellaException_2);
function throwIfNull(value){
  if (null == value) {
    throw new NullPointerException_1('encodedURLComponent cannot be null');
  }
}

function Array_0(){
}

function cloneSubrange(array, fromIndex, toIndex){
  var a, result;
  a = array;
  result = a.slice(fromIndex, toIndex);
  initValues(a.___clazz$, a.castableTypeMap$, a.queryId$, result);
  return result;
}

function createFrom(array, length_0){
  var a, result;
  a = array;
  result = createFromSeed(0, length_0);
  initValues(a.___clazz$, a.castableTypeMap$, a.queryId$, result);
  return result;
}

function createFromSeed(seedType, length_0){
  var array = new Array(length_0);
  if (seedType == 3) {
    for (var i = 0; i < length_0; ++i) {
      var value = new Object;
      value.l = value.m = value.h = 0;
      array[i] = value;
    }
  }
   else if (seedType > 0) {
    var value = [null, 0, false][seedType];
    for (var i = 0; i < length_0; ++i) {
      array[i] = value;
    }
  }
  return array;
}

function initDim(arrayClass, castableTypeMap, queryId, length_0, seedType){
  var result;
  result = createFromSeed(seedType, length_0);
  initValues(arrayClass, castableTypeMap, queryId, result);
  return result;
}

function initDims(arrayClasses, castableTypeMapExprs, queryIdExprs, dimExprs, count, seedType){
  return initDims_0(arrayClasses, castableTypeMapExprs, queryIdExprs, dimExprs, 0, count, seedType);
}

function initDims_0(arrayClasses, castableTypeMapExprs, queryIdExprs, dimExprs, index, count, seedType){
  var i, isLastDim, length_0, result;
  length_0 = dimExprs[index];
  isLastDim = index == count - 1;
  result = createFromSeed(isLastDim?seedType:0, length_0);
  initValues(arrayClasses[index], castableTypeMapExprs[index], queryIdExprs[index], result);
  if (!isLastDim) {
    ++index;
    for (i = 0; i < length_0; ++i) {
      result[i] = initDims_0(arrayClasses, castableTypeMapExprs, queryIdExprs, dimExprs, index, count, seedType);
    }
  }
  return result;
}

function initValues(arrayClass, castableTypeMap, queryId, array){
  $clinit_Array$ExpandoWrapper();
  wrapArray(array, expandoNames_0, expandoValues_0);
  array.___clazz$ = arrayClass;
  array.castableTypeMap$ = castableTypeMap;
  array.queryId$ = queryId;
  return array;
}

function setCheck(array, index, value){
  if (value != null) {
    if (array.queryId$ > 0 && !canCastUnsafe(value, array.queryId$)) {
      throw new ArrayStoreException_0;
    }
     else if (array.queryId$ == -1 && (value.typeMarker$ == nullMethod || canCast(value, 1))) {
      throw new ArrayStoreException_0;
    }
     else if (array.queryId$ < -1 && !(value.typeMarker$ != nullMethod && !canCast(value, 1)) && !canCastUnsafe(value, -array.queryId$)) {
      throw new ArrayStoreException_0;
    }
  }
  return array[index] = value;
}

defineSeed(171, 1, {}, Array_0);
_.queryId$ = 0;
function $clinit_Array$ExpandoWrapper(){
  $clinit_Array$ExpandoWrapper = nullMethod;
  expandoNames_0 = [];
  expandoValues_0 = [];
  initExpandos(new Array_0, expandoNames_0, expandoValues_0);
}

function initExpandos(protoType, expandoNames, expandoValues){
  var i = 0, value;
  for (var name_0 in protoType) {
    if (value = protoType[name_0]) {
      expandoNames[i] = name_0;
      expandoValues[i] = value;
      ++i;
    }
  }
}

function wrapArray(array, expandoNames, expandoValues){
  $clinit_Array$ExpandoWrapper();
  for (var i = 0, c = expandoNames.length; i < c; ++i) {
    array[expandoNames[i]] = expandoValues[i];
  }
}

var expandoNames_0, expandoValues_0;
function canCast(src, dstId){
  return src.castableTypeMap$ && !!src.castableTypeMap$[dstId];
}

function canCastUnsafe(src, dstId){
  return src.castableTypeMap$ && src.castableTypeMap$[dstId];
}

function instanceOf(src, dstId){
  return src != null && canCast(src, dstId);
}

function instanceOfJso(src){
  return src != null && src.typeMarker$ != nullMethod && !canCast(src, 1);
}

function isJavaObject(src){
  return src.typeMarker$ == nullMethod || canCast(src, 1);
}

function maskUndefined(src){
  return src == null?null:src;
}

function round_int(x){
  return ~~Math.max(Math.min(x, 2147483647), -2147483648);
}

function init(){
  !!$stats && onModuleStart('com.google.gwt.useragent.client.UserAgentAsserter');
  !!$stats && onModuleStart('com.google.gwt.user.client.DocumentModeAsserter');
  $onModuleLoad();
  !!$stats && onModuleStart('im.bci.newtonadv.platform.playn.html.PlaynNewtonAdventureGameHtml');
  setUncaughtExceptionHandler(new HtmlGame$1_0);
  $scheduleDeferred(($clinit_SchedulerImpl() , INSTANCE), new HtmlGame$2_0);
}

function caught_0(e){
  if (instanceOf(e, Q$Throwable)) {
    return e;
  }
  return new JavaScriptException_0(e);
}

function create(value){
  var a0, a1, a2;
  a0 = value & 4194303;
  a1 = ~~value >> 22 & 4194303;
  a2 = value < 0?1048575:0;
  return create0(a0, a1, a2);
}

function create_0(a){
  return create0(a.l, a.m, a.h);
}

function create0(l_0, m_0, h_0){
  return _ = new LongLibBase$LongEmul_0 , _.l = l_0 , _.m = m_0 , _.h = h_0 , _;
}

function divMod(a, b, computeRemainder){
  var aIsCopy, aIsMinValue, aIsNegative, bpower, c, negative;
  if (b.l == 0 && b.m == 0 && b.h == 0) {
    throw new ArithmeticException_0;
  }
  if (a.l == 0 && a.m == 0 && a.h == 0) {
    computeRemainder && (remainder = create0(0, 0, 0));
    return create0(0, 0, 0);
  }
  if (b.h == 524288 && b.m == 0 && b.l == 0) {
    return divModByMinValue(a, computeRemainder);
  }
  negative = false;
  if (~~b.h >> 19 != 0) {
    b = neg(b);
    negative = true;
  }
  bpower = powerOfTwo(b);
  aIsNegative = false;
  aIsMinValue = false;
  aIsCopy = false;
  if (a.h == 524288 && a.m == 0 && a.l == 0) {
    aIsMinValue = true;
    aIsNegative = true;
    if (bpower == -1) {
      a = create_0(($clinit_LongLib$Const() , MAX_VALUE));
      aIsCopy = true;
      negative = !negative;
    }
     else {
      c = shr(a, bpower);
      negative && negate(c);
      computeRemainder && (remainder = create0(0, 0, 0));
      return c;
    }
  }
   else if (~~a.h >> 19 != 0) {
    aIsNegative = true;
    a = neg(a);
    aIsCopy = true;
    negative = !negative;
  }
  if (bpower != -1) {
    return divModByShift(a, bpower, negative, aIsNegative, computeRemainder);
  }
  if (!gte_0(a, b)) {
    computeRemainder && (aIsNegative?(remainder = neg(a)):(remainder = create0(a.l, a.m, a.h)));
    return create0(0, 0, 0);
  }
  return divModHelper(aIsCopy?a:create0(a.l, a.m, a.h), b, negative, aIsNegative, aIsMinValue, computeRemainder);
}

function divModByMinValue(a, computeRemainder){
  if (a.h == 524288 && a.m == 0 && a.l == 0) {
    computeRemainder && (remainder = create0(0, 0, 0));
    return create_0(($clinit_LongLib$Const() , ONE));
  }
  computeRemainder && (remainder = create0(a.l, a.m, a.h));
  return create0(0, 0, 0);
}

function divModByShift(a, bpower, negative, aIsNegative, computeRemainder){
  var c;
  c = shr(a, bpower);
  negative && negate(c);
  if (computeRemainder) {
    a = maskRight(a, bpower);
    aIsNegative?(remainder = neg(a)):(remainder = create0(a.l, a.m, a.h));
  }
  return c;
}

function divModHelper(a, b, negative, aIsNegative, aIsMinValue, computeRemainder){
  var bshift, gte, quotient, shift, a1, a2, a0;
  shift = numberOfLeadingZeros(b) - numberOfLeadingZeros(a);
  bshift = shl(b, shift);
  quotient = create0(0, 0, 0);
  while (shift >= 0) {
    gte = trialSubtract(a, bshift);
    if (gte) {
      shift < 22?(quotient.l |= 1 << shift , undefined):shift < 44?(quotient.m |= 1 << shift - 22 , undefined):(quotient.h |= 1 << shift - 44 , undefined);
      if (a.l == 0 && a.m == 0 && a.h == 0) {
        break;
      }
    }
    a1 = bshift.m;
    a2 = bshift.h;
    a0 = bshift.l;
    bshift.h = ~~a2 >>> 1;
    bshift.m = ~~a1 >>> 1 | (a2 & 1) << 21;
    bshift.l = ~~a0 >>> 1 | (a1 & 1) << 21;
    --shift;
  }
  negative && negate(quotient);
  if (computeRemainder) {
    if (aIsNegative) {
      remainder = neg(a);
      aIsMinValue && (remainder = sub(remainder, ($clinit_LongLib$Const() , ONE)));
    }
     else {
      remainder = create0(a.l, a.m, a.h);
    }
  }
  return quotient;
}

function maskRight(a, bits){
  var b0, b1, b2;
  if (bits <= 22) {
    b0 = a.l & (1 << bits) - 1;
    b1 = b2 = 0;
  }
   else if (bits <= 44) {
    b0 = a.l;
    b1 = a.m & (1 << bits - 22) - 1;
    b2 = 0;
  }
   else {
    b0 = a.l;
    b1 = a.m;
    b2 = a.h & (1 << bits - 44) - 1;
  }
  return create0(b0, b1, b2);
}

function negate(a){
  var neg0, neg1, neg2;
  neg0 = ~a.l + 1 & 4194303;
  neg1 = ~a.m + (neg0 == 0?1:0) & 4194303;
  neg2 = ~a.h + (neg0 == 0 && neg1 == 0?1:0) & 1048575;
  a.l = neg0;
  a.m = neg1;
  a.h = neg2;
}

function numberOfLeadingZeros(a){
  var b1, b2;
  b2 = numberOfLeadingZeros_0(a.h);
  if (b2 == 32) {
    b1 = numberOfLeadingZeros_0(a.m);
    return b1 == 32?numberOfLeadingZeros_0(a.l) + 32:b1 + 20 - 10;
  }
   else {
    return b2 - 12;
  }
}

function powerOfTwo(a){
  var h_0, l_0, m_0;
  l_0 = a.l;
  if ((l_0 & l_0 - 1) != 0) {
    return -1;
  }
  m_0 = a.m;
  if ((m_0 & m_0 - 1) != 0) {
    return -1;
  }
  h_0 = a.h;
  if ((h_0 & h_0 - 1) != 0) {
    return -1;
  }
  if (h_0 == 0 && m_0 == 0 && l_0 == 0) {
    return -1;
  }
  if (h_0 == 0 && m_0 == 0 && l_0 != 0) {
    return numberOfTrailingZeros(l_0);
  }
  if (h_0 == 0 && m_0 != 0 && l_0 == 0) {
    return numberOfTrailingZeros(m_0) + 22;
  }
  if (h_0 != 0 && m_0 == 0 && l_0 == 0) {
    return numberOfTrailingZeros(h_0) + 44;
  }
  return -1;
}

function toDoubleHelper(a){
  return a.l + a.m * 4194304 + a.h * 17592186044416;
}

function trialSubtract(a, b){
  var sum0, sum1, sum2;
  sum2 = a.h - b.h;
  if (sum2 < 0) {
    return false;
  }
  sum0 = a.l - b.l;
  sum1 = a.m - b.m + (~~sum0 >> 22);
  sum2 += ~~sum1 >> 22;
  if (sum2 < 0) {
    return false;
  }
  a.l = sum0 & 4194303;
  a.m = sum1 & 4194303;
  a.h = sum2 & 1048575;
  return true;
}

var remainder = null;
function add_4(a, b){
  var sum0, sum1, sum2;
  sum0 = a.l + b.l;
  sum1 = a.m + b.m + (~~sum0 >> 22);
  sum2 = a.h + b.h + (~~sum1 >> 22);
  return create0(sum0 & 4194303, sum1 & 4194303, sum2 & 1048575);
}

function and(a, b){
  return create0(a.l & b.l, a.m & b.m, a.h & b.h);
}

function div(a, b){
  return divMod(a, b, false);
}

--></script>
<script><!--
function eq(a, b){
  return a.l == b.l && a.m == b.m && a.h == b.h;
}

function fromDouble(value){
  var a0, a1, a2, negative, result;
  if (isNaN(value)) {
    return $clinit_LongLib$Const() , ZERO;
  }
  if (value < -9223372036854775808) {
    return $clinit_LongLib$Const() , MIN_VALUE;
  }
  if (value >= 9223372036854775807) {
    return $clinit_LongLib$Const() , MAX_VALUE;
  }
  negative = false;
  if (value < 0) {
    negative = true;
    value = -value;
  }
  a2 = 0;
  if (value >= 17592186044416) {
    a2 = round_int(value / 17592186044416);
    value -= a2 * 17592186044416;
  }
  a1 = 0;
  if (value >= 4194304) {
    a1 = round_int(value / 4194304);
    value -= a1 * 4194304;
  }
  a0 = round_int(value);
  result = create0(a0, a1, a2);
  negative && negate(result);
  return result;
}

function fromInt(value){
  var rebase, result;
  if (value > -129 && value < 128) {
    rebase = value + 128;
    boxedValues == null && (boxedValues = initDim(_3Lcom_google_gwt_lang_LongLibBase$LongEmul_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$LongLibBase$LongEmul, 256, 0));
    result = boxedValues[rebase];
    !result && (result = boxedValues[rebase] = create(value));
    return result;
  }
  return create(value);
}

function gt(a, b){
  var signa, signb;
  signa = ~~a.h >> 19;
  signb = ~~b.h >> 19;
  return signa == 0?signb != 0 || a.h > b.h || a.h == b.h && a.m > b.m || a.h == b.h && a.m == b.m && a.l > b.l:!(signb == 0 || a.h < b.h || a.h == b.h && a.m < b.m || a.h == b.h && a.m == b.m && a.l <= b.l);
}

function gte_0(a, b){
  var signa, signb;
  signa = ~~a.h >> 19;
  signb = ~~b.h >> 19;
  return signa == 0?signb != 0 || a.h > b.h || a.h == b.h && a.m > b.m || a.h == b.h && a.m == b.m && a.l >= b.l:!(signb == 0 || a.h < b.h || a.h == b.h && a.m < b.m || a.h == b.h && a.m == b.m && a.l < b.l);
}

function lt(a, b){
  return !gte_0(a, b);
}

function lte(a, b){
  return !gt(a, b);
}

function mod(a, b){
  divMod(a, b, true);
  return remainder;
}

function mul(a, b){
  var a0, a1, a2, a3, a4, b0, b1, b2, b3, b4, c0, c00, c01, c1, c10, c11, c12, c13, c2, c22, c23, c24, p0, p1, p2, p3, p4;
  a0 = a.l & 8191;
  a1 = ~~a.l >> 13 | (a.m & 15) << 9;
  a2 = ~~a.m >> 4 & 8191;
  a3 = ~~a.m >> 17 | (a.h & 255) << 5;
  a4 = ~~(a.h & 1048320) >> 8;
  b0 = b.l & 8191;
  b1 = ~~b.l >> 13 | (b.m & 15) << 9;
  b2 = ~~b.m >> 4 & 8191;
  b3 = ~~b.m >> 17 | (b.h & 255) << 5;
  b4 = ~~(b.h & 1048320) >> 8;
  p0 = a0 * b0;
  p1 = a1 * b0;
  p2 = a2 * b0;
  p3 = a3 * b0;
  p4 = a4 * b0;
  if (b1 != 0) {
    p1 += a0 * b1;
    p2 += a1 * b1;
    p3 += a2 * b1;
    p4 += a3 * b1;
  }
  if (b2 != 0) {
    p2 += a0 * b2;
    p3 += a1 * b2;
    p4 += a2 * b2;
  }
  if (b3 != 0) {
    p3 += a0 * b3;
    p4 += a1 * b3;
  }
  b4 != 0 && (p4 += a0 * b4);
  c00 = p0 & 4194303;
  c01 = (p1 & 511) << 13;
  c0 = c00 + c01;
  c10 = ~~p0 >> 22;
  c11 = ~~p1 >> 9;
  c12 = (p2 & 262143) << 4;
  c13 = (p3 & 31) << 17;
  c1 = c10 + c11 + c12 + c13;
  c22 = ~~p2 >> 18;
  c23 = ~~p3 >> 5;
  c24 = (p4 & 4095) << 8;
  c2 = c22 + c23 + c24;
  c1 += ~~c0 >> 22;
  c0 &= 4194303;
  c2 += ~~c1 >> 22;
  c1 &= 4194303;
  c2 &= 1048575;
  return create0(c0, c1, c2);
}

function neg(a){
  var neg0, neg1, neg2;
  neg0 = ~a.l + 1 & 4194303;
  neg1 = ~a.m + (neg0 == 0?1:0) & 4194303;
  neg2 = ~a.h + (neg0 == 0 && neg1 == 0?1:0) & 1048575;
  return create0(neg0, neg1, neg2);
}

function neq(a, b){
  return a.l != b.l || a.m != b.m || a.h != b.h;
}

function or(a, b){
  return create0(a.l | b.l, a.m | b.m, a.h | b.h);
}

function shl(a, n){
  var res0, res1, res2;
  n &= 63;
  if (n < 22) {
    res0 = a.l << n;
    res1 = a.m << n | ~~a.l >> 22 - n;
    res2 = a.h << n | ~~a.m >> 22 - n;
  }
   else if (n < 44) {
    res0 = 0;
    res1 = a.l << n - 22;
    res2 = a.m << n - 22 | ~~a.l >> 44 - n;
  }
   else {
    res0 = 0;
    res1 = 0;
    res2 = a.l << n - 44;
  }
  return create0(res0 & 4194303, res1 & 4194303, res2 & 1048575);
}

function shr(a, n){
  var a2, negative, res0, res1, res2;
  n &= 63;
  a2 = a.h;
  negative = (a2 & 524288) != 0;
  negative && (a2 |= -1048576);
  if (n < 22) {
    res2 = ~~a2 >> n;
    res1 = ~~a.m >> n | a2 << 22 - n;
    res0 = ~~a.l >> n | a.m << 22 - n;
  }
   else if (n < 44) {
    res2 = negative?1048575:0;
    res1 = ~~a2 >> n - 22;
    res0 = ~~a.m >> n - 22 | a2 << 44 - n;
  }
   else {
    res2 = negative?1048575:0;
    res1 = negative?4194303:0;
    res0 = ~~a2 >> n - 44;
  }
  return create0(res0 & 4194303, res1 & 4194303, res2 & 1048575);
}

function shru(a, n){
  var a2, res0, res1, res2;
  n &= 63;
  a2 = a.h & 1048575;
  if (n < 22) {
    res2 = ~~a2 >>> n;
    res1 = ~~a.m >> n | a2 << 22 - n;
    res0 = ~~a.l >> n | a.m << 22 - n;
  }
   else if (n < 44) {
    res2 = 0;
    res1 = ~~a2 >>> n - 22;
    res0 = ~~a.m >> n - 22 | a.h << 44 - n;
  }
   else {
    res2 = 0;
    res1 = 0;
    res0 = ~~a2 >>> n - 44;
  }
  return create0(res0 & 4194303, res1 & 4194303, res2 & 1048575);
}

function sub(a, b){
  var sum0, sum1, sum2;
  sum0 = a.l - b.l;
  sum1 = a.m - b.m + (~~sum0 >> 22);
  sum2 = a.h - b.h + (~~sum1 >> 22);
  return create0(sum0 & 4194303, sum1 & 4194303, sum2 & 1048575);
}

function toDouble(a){
  if (eq(a, ($clinit_LongLib$Const() , MIN_VALUE))) {
    return -9223372036854775808;
  }
  if (!gte_0(a, ZERO)) {
    return -toDoubleHelper(neg(a));
  }
  return a.l + a.m * 4194304 + a.h * 17592186044416;
}

function toInt(a){
  return a.l | a.m << 22;
}

function toString_12(a){
  var digits, rem, res, tenPowerLong, zeroesNeeded;
  if (a.l == 0 && a.m == 0 && a.h == 0) {
    return '0';
  }
  if (a.h == 524288 && a.m == 0 && a.l == 0) {
    return '-9223372036854775808';
  }
  if (~~a.h >> 19 != 0) {
    return '-' + toString_12(neg(a));
  }
  rem = a;
  res = '';
  while (!(rem.l == 0 && rem.m == 0 && rem.h == 0)) {
    tenPowerLong = fromInt(1000000000);
    rem = divMod(rem, tenPowerLong, true);
    digits = '' + toInt(remainder);
    if (!(rem.l == 0 && rem.m == 0 && rem.h == 0)) {
      zeroesNeeded = 9 - digits.length;
      for (; zeroesNeeded > 0; --zeroesNeeded) {
        digits = '0' + digits;
      }
    }
    res = digits + res;
  }
  return res;
}

function xor(a, b){
  return create0(a.l ^ b.l, a.m ^ b.m, a.h ^ b.h);
}

var boxedValues = null;
function $clinit_LongLib$Const(){
  $clinit_LongLib$Const = nullMethod;
  MAX_VALUE = create0(4194303, 4194303, 524287);
  MIN_VALUE = create0(0, 0, 524288);
  ONE = fromInt(1);
  fromInt(2);
  ZERO = fromInt(0);
}

var MAX_VALUE, MIN_VALUE, ONE, ZERO;
function LongLibBase$LongEmul_0(){
}

defineSeed(180, 1, makeCastMap([Q$LongLibBase$LongEmul]), LongLibBase$LongEmul_0);
function onModuleStart(mainClassName){
  return $stats({moduleName:$moduleName, sessionId:$sessionId, subSystem:'startup', evtGroup:'moduleStartup', millis:(new Date).getTime(), type:'onModuleLoadStart', className:mainClassName});
}

function $sinkBitlessEvent(this$static, eventTypeName){
  sinkBitlessEvent(this$static.element, eventTypeName);
}

defineSeed(188, 1, makeCastMap([Q$HasVisibility, Q$UIObject]));
_.toString$ = function toString_13(){
  if (!this.element) {
    return '(null handle)';
  }
  return this.element.outerHTML;
}
;
_.element = null;
function $addBitlessDomHandler(this$static, handler, type){
  $sinkBitlessEvent(this$static, type.name_0);
  return $addHandler(!this$static.handlerManager?(this$static.handlerManager = new HandlerManager_0(this$static)):this$static.handlerManager, type, handler);
}

function $fireEvent_0(this$static, event_0){
  !!this$static.handlerManager && $fireEvent(this$static.handlerManager, event_0);
}

function $onAttach(this$static){
  var bitsToAdd;
  if (this$static.attached) {
    throw new IllegalStateException_1("Should only call onAttach when the widget is detached from the browser's document");
  }
  this$static.attached = true;
  $setEventListener(this$static.element, this$static);
  bitsToAdd = this$static.eventsToSink;
  this$static.eventsToSink = -1;
  bitsToAdd > 0 && (this$static.eventsToSink == -1?sinkEvents(this$static.element, bitsToAdd | (this$static.element.__eventBits || 0)):(this$static.eventsToSink |= bitsToAdd));
  this$static.doAttachChildren();
}

function $onDetach(this$static){
  if (!this$static.attached) {
    throw new IllegalStateException_1("Should only call onDetach when the widget is attached to the browser's document");
  }
  try {
    this$static.doDetachChildren();
  }
   finally {
    this$static.element.__listener = null;
    this$static.attached = false;
  }
}

function $removeFromParent(this$static){
  if (!this$static.parent_0) {
    ($clinit_RootPanel() , $contains_2(widgetsToDetach, this$static)) && detachNow(this$static);
  }
   else if (this$static.parent_0) {
    $remove_4(this$static.parent_0, this$static);
  }
   else if (this$static.parent_0) {
    throw new IllegalStateException_1("This widget's parent does not implement HasWidgets");
  }
}

function $setParent(this$static, parent_0){
  var oldParent;
  oldParent = this$static.parent_0;
  if (!parent_0) {
    try {
      !!oldParent && oldParent.attached && $onDetach(this$static);
    }
     finally {
      this$static.parent_0 = null;
    }
  }
   else {
    if (oldParent) {
      throw new IllegalStateException_1('Cannot set a new parent without first clearing the old parent');
    }
    this$static.parent_0 = parent_0;
    parent_0.attached && this$static.onAttach();
  }
}

defineSeed(187, 188, makeCastMap([Q$HasAttachHandlers, Q$HasHandlers, Q$EventListener, Q$HasVisibility, Q$IsWidget, Q$UIObject, Q$Widget]));
_.doAttachChildren = function doAttachChildren(){
}
;
_.doDetachChildren = function doDetachChildren(){
}
;
_.onAttach = function onAttach(){
  $onAttach(this);
}
;
_.onBrowserEvent = function onBrowserEvent(event_0){
  var related;
  switch ($eventGetTypeInt(event_0.type)) {
    case 16:
    case 32:
      related = event_0.relatedTarget;
      if (!!related && $isOrHasChild(this.element, related)) {
        return;
      }

  }
  fireNativeEvent(event_0, this, this.element);
}
;
_.attached = false;
_.eventsToSink = 0;
_.handlerManager = null;
_.parent_0 = null;
defineSeed(186, 187, makeCastMap([Q$HasAttachHandlers, Q$HasHandlers, Q$EventListener, Q$HasVisibility, Q$IsWidget, Q$UIObject, Q$Widget]));
_.onAttach = function onAttach_0(){
  var tabIndex;
  $onAttach(this);
  tabIndex = $getTabIndex(this.element);
  -1 == tabIndex && (this.element.tabIndex = 0 , undefined);
}
;
defineSeed(185, 186, makeCastMap([Q$HasAttachHandlers, Q$HasHandlers, Q$EventListener, Q$HasVisibility, Q$IsWidget, Q$UIObject, Q$Widget]));
function Audio_0(element){
  this.element = element;
}

function createIfSupported(){
  var element;
  !detector && (detector = new Audio$AudioElementSupportDetectedMaybe_0);
  element = $doc.createElement('audio');
  if (!element.canPlayType) {
    return null;
  }
  return new Audio_0(element);
}

function isSupported(){
  var element;
  !detector && (detector = new Audio$AudioElementSupportDetectedMaybe_0);
  element = $doc.createElement('audio');
  if (!element.canPlayType) {
    return false;
  }
  return true;
}

defineSeed(184, 185, makeCastMap([Q$HasAttachHandlers, Q$HasHandlers, Q$EventListener, Q$HasVisibility, Q$IsWidget, Q$UIObject, Q$Widget]), Audio_0);
var detector = null;
defineSeed(190, 1, {});
function Audio$AudioElementSupportDetectedMaybe_0(){
}

defineSeed(189, 190, {}, Audio$AudioElementSupportDetectedMaybe_0);
function $exec(this$static, input){
  return this$static.exec(input);
}

function $getItem(this$static, key){
  return $getItem_0(this$static.storage, key);
}

function $key(this$static, index){
  return $key_0(this$static.storage, index);
}

function $removeItem(this$static, key){
  $removeItem_0(this$static.storage, key);
}

function $setItem(this$static, key, data){
  $setItem_0(this$static.storage, key, data);
}

function Storage_0(){
  this.storage = 'localStorage';
}

function getLocalStorageIfSupported(){
  if ((!supportDetectorImpl && (supportDetectorImpl = new Storage$StorageSupportDetector_0) , supportDetectorImpl).isLocalStorageSupported) {
    !localStorage_0 && (localStorage_0 = new Storage_0);
    return localStorage_0;
  }
  return null;
}

defineSeed(193, 1, {}, Storage_0);
_.storage = null;
var localStorage_0 = null, supportDetectorImpl = null;
function Storage$StorageSupportDetector_0(){
  this.isLocalStorageSupported = $wnd.localStorage != null;
  $wnd.sessionStorage != null;
}

defineSeed(194, 1, {}, Storage$StorageSupportDetector_0);
function $getItem_0(storage, key){
  return $wnd[storage].getItem(key);
}

function $getLength(storage){
  return $wnd[storage].length;
}

function $key_0(storage, index){
  return index >= 0 && index < $wnd[storage].length?$wnd[storage].key(index):null;
}

function $removeItem_0(storage, key){
  $wnd[storage].getItem(key);
  $wnd[storage].removeItem(key);
}

function $setItem_0(storage, key, data){
  $wnd[storage].getItem(key);
  $wnd[storage].setItem(key, data);
}

function $implFindEntry(this$static, key, remove){
  var entry, iter, k;
  for (iter = this$static.entrySet_0().iterator_0(); iter.hasNext();) {
    entry = iter.next_0();
    k = entry.getKey();
    if (key == null?k == null:equals__devirtual$(key, k)) {
      remove && iter.remove_2();
      return entry;
    }
  }
  return null;
}

function $keySet(this$static){
  var entrySet;
  entrySet = this$static.entrySet_0();
  return new AbstractMap$1_0(this$static, entrySet);
}

function $toString_3(this$static){
  var comma, entry, iter, s;
  s = '{';
  comma = false;
  for (iter = this$static.entrySet_0().iterator_0(); iter.hasNext();) {
    entry = iter.next_0();
    comma?(s += ', '):(comma = true);
    s += '' + entry.getKey();
    s += '=';
    s += '' + entry.getValue();
  }
  return s + '}';
}

function $values(this$static){
  var entrySet;
  entrySet = this$static.entrySet_0();
  return new AbstractMap$2_0(this$static, entrySet);
}

defineSeed(198, 1, makeCastMap([Q$Map]));
_.containsKey = function containsKey(key){
  return !!$implFindEntry(this, key, false);
}
;
_.containsValue = function containsValue(value){
  var entry, iter, v;
  for (iter = this.entrySet_0().iterator_0(); iter.hasNext();) {
    entry = iter.next_0();
    v = entry.getValue();
    if (value == null?v == null:equals__devirtual$(value, v)) {
      return true;
    }
  }
  return false;
}
;
_.equals$ = function equals_2(obj){
  var entry, entry$iterator, otherKey, otherMap, otherValue;
  if (obj === this) {
    return true;
  }
  if (!instanceOf(obj, Q$Map)) {
    return false;
  }
  otherMap = obj;
  if (this.size_0() != otherMap.size_0()) {
    return false;
  }
  for (entry$iterator = otherMap.entrySet_0().iterator_0(); entry$iterator.hasNext();) {
    entry = entry$iterator.next_0();
    otherKey = entry.getKey();
    otherValue = entry.getValue();
    if (!this.containsKey(otherKey)) {
      return false;
    }
    if (!equalsWithNullCheck(otherValue, this.get_1(otherKey))) {
      return false;
    }
  }
  return true;
}
;
_.get_1 = function get_7(key){
  var entry;
  entry = $implFindEntry(this, key, false);
  return !entry?null:entry.getValue();
}
;
_.hashCode$ = function hashCode_4(){
  var entry, entry$iterator, hashCode;
  hashCode = 0;
  for (entry$iterator = this.entrySet_0().iterator_0(); entry$iterator.hasNext();) {
    entry = entry$iterator.next_0();
    hashCode += entry.hashCode$();
    hashCode = ~~hashCode;
  }
  return hashCode;
}
;
_.isEmpty = function isEmpty_1(){
  return this.size_0() == 0;
}
;
_.put = function put(key, value){
  throw new UnsupportedOperationException_1('Put not supported on this map');
}
;
_.remove_1 = function remove_4(key){
  var entry;
  entry = $implFindEntry(this, key, true);
  return !entry?null:entry.getValue();
}
;
_.size_0 = function size_1(){
  return this.entrySet_0().size_0();
}
;
_.toString$ = function toString_14(){
  return $toString_3(this);
}
;
function $containsKey(this$static, key){
  return $getItem(this$static.storage, toString__devirtual$(key)) != null;
}

function $eq(a, b){
  if (maskUndefined(a) === maskUndefined(b)) {
    return true;
  }
  if (a == null) {
    return false;
  }
  return $equals_0(a, b);
}

function $get_0(this$static, key){
  if (key == null) {
    return null;
  }
  return $getItem(this$static.storage, toString__devirtual$(key));
}

function $put(this$static, key, value){
  var old;
  if (key == null || value == null) {
    throw new IllegalArgumentException_1('Key and value cannot be null!');
  }
  old = $getItem(this$static.storage, key);
  $setItem(this$static.storage, key, value);
  return old;
}

function $remove_2(this$static, key){
  var old;
  old = $getItem(this$static.storage, key);
  $removeItem(this$static.storage, key);
  return old;
}

function StorageMap_0(storage){
  this.storage = storage;
}

defineSeed(197, 198, makeCastMap([Q$Map]), StorageMap_0);
_.containsKey = function containsKey_0(key){
  return $containsKey(this, key);
}
;
_.containsValue = function containsValue_0(value){
  var i, s;
  s = $getLength(this.storage.storage);
  for (i = 0; i < s; ++i) {
    if (equals__devirtual$(value, $getItem(this.storage, $key(this.storage, i)))) {
      return true;
    }
  }
  return false;
}
;
_.entrySet_0 = function entrySet_0(){
  !this.entrySet && (this.entrySet = new StorageMap$StorageEntrySet_0(this));
  return this.entrySet;
}
;
_.get_1 = function get_8(key){
  return $get_0(this, key);
}
;
_.put = function put_0(key, value){
  return $put(this, key, value);
}
;
_.remove_1 = function remove_5(key){
  return $remove_2(this, key);
}
;
_.size_0 = function size_2(){
  return $getLength(this.storage.storage);
}
;
_.entrySet = null;
_.storage = null;
function StorageMap$StorageEntry_0(this$0, key){
  this.this$0 = this$0;
  this.key_0 = key;
}

defineSeed(199, 1, makeCastMap([Q$Map$Entry]), StorageMap$StorageEntry_0);
_.equals$ = function equals_3(obj){
  var e;
  if (obj == null) {
    return false;
  }
   else if (obj === this) {
    return true;
  }
   else if (!instanceOf(obj, Q$Map$Entry)) {
    return false;
  }
  e = obj;
  return $eq(this.key_0, e.getKey()) && $eq($getItem(this.this$0.storage, this.key_0), e.getValue());
}
;
_.getKey = function getKey(){
  return this.key_0;
}
;
_.getValue = function getValue(){
  return $getItem(this.this$0.storage, this.key_0);
}
;
_.hashCode$ = function hashCode_5(){
  var value;
  value = $getItem(this.this$0.storage, this.key_0);
  return (this.key_0 == null?0:getHashCode_0(this.key_0)) ^ (value == null?0:getHashCode_0(value));
}
;
_.setValue = function setValue(value){
  var oldValue;
  return oldValue = $getItem(this.this$0.storage, this.key_0) , $setItem(this.this$0.storage, this.key_0, value) , oldValue;
}
;
_.key_0 = null;
_.this$0 = null;
function $next(this$static){
  if (this$static.index_0 < $getLength(this$static.this$0.storage.storage) - 1) {
    ++this$static.index_0;
    this$static.removed = false;
    return new StorageMap$StorageEntry_0(this$static.this$0, $key(this$static.this$0.storage, this$static.index_0));
  }
  throw new NoSuchElementException_0;
}

function StorageMap$StorageEntryIterator_0(this$0){
  this.this$0 = this$0;
}

defineSeed(200, 1, {}, StorageMap$StorageEntryIterator_0);
_.hasNext = function hasNext(){
  return this.index_0 < $getLength(this.this$0.storage.storage) - 1;
}
;
_.next_0 = function next_0(){
  return $next(this);
}
;
_.remove_2 = function remove_6(){
  if (this.index_0 >= 0 && this.index_0 < $getLength(this.this$0.storage.storage)) {
    if (this.removed) {
      throw new IllegalStateException_1('Cannot remove() Entry - already removed!');
    }
    $removeItem(this.this$0.storage, $key(this.this$0.storage, this.index_0));
    this.removed = true;
    --this.index_0;
  }
   else {
    throw new IllegalStateException_1('Cannot remove() Entry - index=' + this.index_0 + ', size=' + $getLength(this.this$0.storage.storage));
  }
}
;
_.index_0 = -1;
_.removed = false;
_.this$0 = null;
function $hashCode(this$static){
  var hashCode, iter, next;
  hashCode = 0;
  for (iter = this$static.iterator_0(); iter.hasNext();) {
    next = iter.next_0();
    if (next != null) {
      hashCode += hashCode__devirtual$(next);
      hashCode = ~~hashCode;
    }
  }
  return hashCode;
}

defineSeed(202, 21, makeCastMap([Q$Set]));
_.equals$ = function equals_4(o){
  var iter, other, otherItem;
  if (o === this) {
    return true;
  }
  if (!instanceOf(o, Q$Set)) {
    return false;
  }
  other = o;
  if (other.size_0() != this.size_0()) {
    return false;
  }
  for (iter = other.iterator_0(); iter.hasNext();) {
    otherItem = iter.next_0();
    if (!this.contains_0(otherItem)) {
      return false;
    }
  }
  return true;
}
;
_.hashCode$ = function hashCode_6(){
  return $hashCode(this);
}
;
function StorageMap$StorageEntrySet_0(this$0){
  this.this$0 = this$0;
}

defineSeed(201, 202, makeCastMap([Q$Set]), StorageMap$StorageEntrySet_0);
_.contains_0 = function contains_2(o){
  var e, key;
  if (o == null || !instanceOf(o, Q$Map$Entry)) {
    return false;
  }
  e = o;
  key = e.getKey();
  return key != null && $containsKey(this.this$0, key) && $eq($get_0(this.this$0, key), e.getValue());
}
;
_.iterator_0 = function iterator_1(){
  return new StorageMap$StorageEntryIterator_0(this.this$0);
}
;
_.remove = function remove_7(o){
  var e, key, value;
  if (o == null || !instanceOf(o, Q$Map$Entry)) {
    return false;
  }
  e = o;
  if (e.getKey() == null) {
    return false;
  }
  key = toString__devirtual$(e.getKey());
  value = $getItem(this.this$0.storage, key);
  if ($eq(value, e.getValue())) {
    return $remove_2(this.this$0, key) != null;
  }
  return false;
}
;
_.size_0 = function size_3(){
  return $getLength(this.this$0.storage.storage);
}
;
_.this$0 = null;
function $set_1(this$static, array, offset){
  this$static.set(array, offset);
}

function $set_2(this$static, array){
  this$static.set(array);
}

function create_1(buffer, byteOffset, length_0){
  return new Float32Array(buffer, byteOffset, length_0);
}

function create_2(buffer, byteOffset, length_0){
  return new Int16Array(buffer, byteOffset, length_0);
}

function create_3(buffer, byteOffset, length_0){
  return new Int32Array(buffer, byteOffset, length_0);
}

function create_4(buffer, byteOffset, length_0){
  return new Int8Array(buffer, byteOffset, length_0);
}

function createFloat32Array(array){
  return new Float32Array(array);
}

function createInt32Array(array){
  return new Int32Array(array);
}

function createUint16Array(array){
  return new Uint16Array(array);
}

function createUint8Array(array){
  return new Uint8Array(array);
}

function create_5(buffer, byteOffset, length_0){
  return new Uint16Array(buffer, byteOffset, length_0);
}

function create_6(buffer, byteOffset, length_0){
  return new Uint8Array(buffer, byteOffset, length_0);
}

function appendChild(parent_0, child){
  $appendChild(parent_0, ($clinit_PotentialElement() , $resolve(child)));
}

function dispatchEvent_0(evt, elem, listener){
  var prevCurrentEvent;
  prevCurrentEvent = currentEvent;
  currentEvent = evt;
  elem == sCaptureElem && $eventGetTypeInt(evt.type) == 8192 && (sCaptureElem = null);
  listener.onBrowserEvent(evt);
  currentEvent = prevCurrentEvent;
}

function sinkBitlessEvent(elem, eventTypeName){
  $maybeInitializeEventSystem();
  $sinkBitlessEventImpl(elem, eventTypeName);
}

function sinkEvents(elem, eventBits){
  $maybeInitializeEventSystem();
  $sinkEventsImpl(elem, eventBits);
}

var currentEvent = null, sCaptureElem = null;
function $onModuleLoad(){
  var allowedModes, currentMode, i;
  currentMode = $doc.compatMode;
  allowedModes = initValues(_3Ljava_lang_String_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$String, ['CSS1Compat']);
  for (i = 0; i < allowedModes.length; ++i) {
    if ($equals_0(allowedModes[i], currentMode)) {
      return;
    }
  }
  allowedModes.length == 1 && $equals_0('CSS1Compat', allowedModes[0]) && $equals_0('BackCompat', currentMode)?"GWT no longer supports Quirks Mode (document.compatMode=' BackCompat').<br>Make sure your application's host HTML page has a Standards Mode (document.compatMode=' CSS1Compat') doctype,<br>e.g. by using &lt;!doctype html&gt; at the start of your application's HTML page.<br><br>To continue using this unsupported rendering mode and risk layout problems, suppress this message by adding<br>the following line to your*.gwt.xml module file:<br>&nbsp;&nbsp;&lt;extend-configuration-property name=\"document.compatMode\" value=\"" + currentMode + '"/&gt;':"Your *.gwt.xml module configuration prohibits the use of the current doucment rendering mode (document.compatMode=' " + currentMode + "').<br>Modify your application's host HTML page doctype, or update your custom 'document.compatMode' configuration property settings.";
}

function addCloseHandler(handler){
  maybeInitializeCloseHandlers();
  return addHandler(TYPE_0?TYPE_0:(TYPE_0 = new GwtEvent$Type_0), handler);
}

function addHandler(type, handler){
  return $addHandler((!handlers_0 && (handlers_0 = new Window$WindowHandlers_0) , handlers_0), type, handler);
}

function alert_0(msg){
  $wnd.alert(msg);
}

function maybeInitializeCloseHandlers(){
  if (!closeHandlersInitialized) {
    $initWindowCloseHandler();
    closeHandlersInitialized = true;
  }
}

function onClosing(){
  var event_0;
  if (closeHandlersInitialized) {
    event_0 = new Window$ClosingEvent_0;
    !!handlers_0 && $fireEvent(handlers_0, event_0);
    return null;
  }
  return null;
}

var closeHandlersInitialized = false, handlers_0 = null;
function $clinit_Window$ClosingEvent(){
  $clinit_Window$ClosingEvent = nullMethod;
  TYPE_1 = new GwtEvent$Type_0;
}

function Window$ClosingEvent_0(){
  $clinit_Window$ClosingEvent();
}

defineSeed(217, 153, {}, Window$ClosingEvent_0);
_.dispatch = function dispatch_1(handler){
  null.nullMethod();
}
;
_.getAssociatedType = function getAssociatedType_1(){
  return TYPE_1;
}
;
var TYPE_1;
function ensureParameterMap(){
  var kv, kvPair, kvPair$array, kvPair$index, kvPair$max, qs, queryString, regexp;
  if (!paramMap) {
    paramMap = new HashMap_0;
    queryString = $wnd.location.search;
    if (queryString != null && queryString.length > 1) {
      qs = $substring(queryString, 1);
      for (kvPair$array = $split(qs, '&', 0) , kvPair$index = 0 , kvPair$max = kvPair$array.length; kvPair$index < kvPair$max; ++kvPair$index) {
        kvPair = kvPair$array[kvPair$index];
        kv = $split(kvPair, '=', 2);
        kv.length > 1?paramMap.put(kv[0], (throwIfNull(kv[1]) , regexp = /\+/g , decodeURIComponent(kv[1].replace(regexp, '%20')))):paramMap.put(kv[0], '');
      }
    }
  }
}

var paramMap = null;
function Window$WindowHandlers_0(){
  HandlerManager_0.call(this, null);
}

defineSeed(220, 162, makeCastMap([Q$HasHandlers]), Window$WindowHandlers_0);
function $eventGetTypeInt(eventType){
  switch (eventType) {
    case 'blur':
      return 4096;
    case 'change':
      return 1024;
    case 'click':
      return 1;
    case 'dblclick':
      return 2;
    case 'focus':
      return 2048;
    case 'keydown':
      return 128;
    case 'keypress':
      return 256;
    case 'keyup':
      return 512;
    case 'load':
      return 32768;
    case 'losecapture':
      return 8192;
    case 'mousedown':
      return 4;
    case 'mousemove':
      return 64;
    case 'mouseout':
      return 32;
    case 'mouseover':
      return 16;
    case 'mouseup':
      return 8;
    case 'scroll':
      return 16384;
    case 'error':
      return 65536;
    case 'DOMMouseScroll':
    case 'mousewheel':
      return 131072;
    case 'contextmenu':
      return 262144;
    case 'paste':
      return 524288;
    case 'touchstart':
      return 1048576;
    case 'touchmove':
      return 2097152;
    case 'touchend':
      return 4194304;
    case 'touchcancel':
      return 8388608;
    case 'gesturestart':
      return 16777216;
    case 'gesturechange':
      return 33554432;
    case 'gestureend':
      return 67108864;
    default:return -1;
  }
}

function $maybeInitializeEventSystem(){
  if (!eventSystemIsInitialized) {
    $initEventSystem();
    eventSystemIsInitialized = true;
  }
}

function $setEventListener(elem, listener){
  elem.__listener = listener;
}

function isMyListener(object){
  return !instanceOfJso(object) && instanceOf(object, Q$EventListener);
}

var eventSystemIsInitialized = false;
--></script>
<script><!--
function $initEventSystem(){
  dispatchCapturedEvent = $entry(function(evt){
    return true;
  }
  );
  dispatchEvent_1 = $entry(function(evt){
    var listener, curElem = this;
    while (curElem && !(listener = curElem.__listener)) {
      curElem = curElem.parentNode;
    }
    curElem && curElem.nodeType != 1 && (curElem = null);
    listener && isMyListener(listener) && dispatchEvent_0(evt, curElem, listener);
  }
  );
  dispatchDragEvent = $entry(function(evt){
    evt.preventDefault();
    dispatchEvent_1.call(this, evt);
  }
  );
  dispatchUnhandledEvent = $entry(function(evt){
    this.__gwtLastUnhandledEvent = evt.type;
    dispatchEvent_1.call(this, evt);
  }
  );
  dispatchCapturedMouseEvent = $entry(function(evt){
    var dispatchCapturedEventFn = dispatchCapturedEvent;
    if (dispatchCapturedEventFn(evt)) {
      var cap = captureElem;
      if (cap && cap.__listener) {
        if (isMyListener(cap.__listener)) {
          dispatchEvent_0(evt, cap, cap.__listener);
          evt.stopPropagation();
        }
      }
    }
  }
  );
  $wnd.addEventListener('click', dispatchCapturedMouseEvent, true);
  $wnd.addEventListener('dblclick', dispatchCapturedMouseEvent, true);
  $wnd.addEventListener('mousedown', dispatchCapturedMouseEvent, true);
  $wnd.addEventListener('mouseup', dispatchCapturedMouseEvent, true);
  $wnd.addEventListener('mousemove', dispatchCapturedMouseEvent, true);
  $wnd.addEventListener('mouseover', dispatchCapturedMouseEvent, true);
  $wnd.addEventListener('mouseout', dispatchCapturedMouseEvent, true);
  $wnd.addEventListener('mousewheel', dispatchCapturedMouseEvent, true);
  $wnd.addEventListener('keydown', dispatchCapturedEvent, true);
  $wnd.addEventListener('keyup', dispatchCapturedEvent, true);
  $wnd.addEventListener('keypress', dispatchCapturedEvent, true);
  $wnd.addEventListener('touchstart', dispatchCapturedMouseEvent, true);
  $wnd.addEventListener('touchmove', dispatchCapturedMouseEvent, true);
  $wnd.addEventListener('touchend', dispatchCapturedMouseEvent, true);
  $wnd.addEventListener('touchcancel', dispatchCapturedMouseEvent, true);
  $wnd.addEventListener('gesturestart', dispatchCapturedMouseEvent, true);
  $wnd.addEventListener('gesturechange', dispatchCapturedMouseEvent, true);
  $wnd.addEventListener('gestureend', dispatchCapturedMouseEvent, true);
}

function $sinkBitlessEventImpl(elem, eventTypeName){
  switch (eventTypeName) {
    case 'drag':
      elem.ondrag = dispatchEvent_1;
      break;
    case 'dragend':
      elem.ondragend = dispatchEvent_1;
      break;
    case 'dragenter':
      elem.ondragenter = dispatchDragEvent;
      break;
    case 'dragleave':
      elem.ondragleave = dispatchEvent_1;
      break;
    case 'dragover':
      elem.ondragover = dispatchDragEvent;
      break;
    case 'dragstart':
      elem.ondragstart = dispatchEvent_1;
      break;
    case 'drop':
      elem.ondrop = dispatchEvent_1;
      break;
    case 'canplaythrough':
    case 'ended':
    case 'progress':
      elem.removeEventListener(eventTypeName, dispatchEvent_1, false);
      elem.addEventListener(eventTypeName, dispatchEvent_1, false);
      break;
    default:throw 'Trying to sink unknown event type ' + eventTypeName;
  }
}

function $sinkEventsImpl(elem, bits){
  var chMask = (elem.__eventBits || 0) ^ bits;
  elem.__eventBits = bits;
  if (!chMask)
    return;
  chMask & 1 && (elem.onclick = bits & 1?dispatchEvent_1:null);
  chMask & 2 && (elem.ondblclick = bits & 2?dispatchEvent_1:null);
  chMask & 4 && (elem.onmousedown = bits & 4?dispatchEvent_1:null);
  chMask & 8 && (elem.onmouseup = bits & 8?dispatchEvent_1:null);
  chMask & 16 && (elem.onmouseover = bits & 16?dispatchEvent_1:null);
  chMask & 32 && (elem.onmouseout = bits & 32?dispatchEvent_1:null);
  chMask & 64 && (elem.onmousemove = bits & 64?dispatchEvent_1:null);
  chMask & 128 && (elem.onkeydown = bits & 128?dispatchEvent_1:null);
  chMask & 256 && (elem.onkeypress = bits & 256?dispatchEvent_1:null);
  chMask & 512 && (elem.onkeyup = bits & 512?dispatchEvent_1:null);
  chMask & 1024 && (elem.onchange = bits & 1024?dispatchEvent_1:null);
  chMask & 2048 && (elem.onfocus = bits & 2048?dispatchEvent_1:null);
  chMask & 4096 && (elem.onblur = bits & 4096?dispatchEvent_1:null);
  chMask & 8192 && (elem.onlosecapture = bits & 8192?dispatchEvent_1:null);
  chMask & 16384 && (elem.onscroll = bits & 16384?dispatchEvent_1:null);
  chMask & 32768 && (elem.onload = bits & 32768?dispatchUnhandledEvent:null);
  chMask & 65536 && (elem.onerror = bits & 65536?dispatchEvent_1:null);
  chMask & 131072 && (elem.onmousewheel = bits & 131072?dispatchEvent_1:null);
  chMask & 262144 && (elem.oncontextmenu = bits & 262144?dispatchEvent_1:null);
  chMask & 524288 && (elem.onpaste = bits & 524288?dispatchEvent_1:null);
  chMask & 1048576 && (elem.ontouchstart = bits & 1048576?dispatchEvent_1:null);
  chMask & 2097152 && (elem.ontouchmove = bits & 2097152?dispatchEvent_1:null);
  chMask & 4194304 && (elem.ontouchend = bits & 4194304?dispatchEvent_1:null);
  chMask & 8388608 && (elem.ontouchcancel = bits & 8388608?dispatchEvent_1:null);
  chMask & 16777216 && (elem.ongesturestart = bits & 16777216?dispatchEvent_1:null);
  chMask & 33554432 && (elem.ongesturechange = bits & 33554432?dispatchEvent_1:null);
  chMask & 67108864 && (elem.ongestureend = bits & 67108864?dispatchEvent_1:null);
}

var captureElem = null, dispatchCapturedEvent = null, dispatchCapturedMouseEvent = null, dispatchDragEvent = null, dispatchEvent_1 = null, dispatchUnhandledEvent = null;
function $initWindowCloseHandler(){
  var oldOnBeforeUnload = $wnd.onbeforeunload;
  var oldOnUnload = $wnd.onunload;
  $wnd.onbeforeunload = function(evt){
    var ret, oldRet;
    try {
      ret = $entry(onClosing)();
    }
     finally {
      oldRet = oldOnBeforeUnload && oldOnBeforeUnload(evt);
    }
    if (ret != null) {
      return ret;
    }
    if (oldRet != null) {
      return oldRet;
    }
  }
  ;
  $wnd.onunload = $entry(function(evt){
    try {
      closeHandlersInitialized && fire((!handlers_0 && (handlers_0 = new Window$WindowHandlers_0) , handlers_0));
    }
     finally {
      oldOnUnload && oldOnUnload(evt);
      $wnd.onresize = null;
      $wnd.onscroll = null;
      $wnd.onbeforeunload = null;
      $wnd.onunload = null;
    }
  }
  );
}

defineSeed(226, 187, makeCastMap([Q$HasAttachHandlers, Q$HasHandlers, Q$EventListener, Q$HasVisibility, Q$IsWidget, Q$UIObject, Q$Widget]));
_.doAttachChildren = function doAttachChildren_0(){
  tryCommand(this, ($clinit_AttachDetachException() , attachCommand));
}
;
_.doDetachChildren = function doDetachChildren_0(){
  tryCommand(this, ($clinit_AttachDetachException() , detachCommand));
}
;
function $add_2(this$static, child, container){
  $removeFromParent(child);
  $add_4(this$static.children, child);
  appendChild(container, child.element);
  $setParent(child, this$static);
}

function $remove_3(this$static, w){
  var elem, parent_0;
  if (w.parent_0 != this$static) {
    return false;
  }
  try {
    $setParent(w, null);
  }
   finally {
    elem = w.element;
    $removeChild((parent_0 = elem.parentNode , (!parent_0 || parent_0.nodeType != 1) && (parent_0 = null) , parent_0), elem);
    $remove_6(this$static.children, w);
  }
  return true;
}

defineSeed(225, 226, makeCastMap([Q$HasAttachHandlers, Q$HasHandlers, Q$EventListener, Q$HasVisibility, Q$IsWidget, Q$UIObject, Q$Widget]));
_.iterator_0 = function iterator_2(){
  return new WidgetCollection$WidgetIterator_0(this.children);
}
;
_.remove_3 = function remove_8(w){
  return $remove_3(this, w);
}
;
function $add_3(this$static, w){
  $add_2(this$static, w, this$static.element);
}

function $remove_4(this$static, w){
  var removed;
  removed = $remove_3(this$static, w);
  removed && changeToStaticPositioning(w.element);
  return removed;
}

function changeToStaticPositioning(elem){
  elem.style['left'] = '';
  elem.style['top'] = '';
  elem.style['position'] = '';
}

defineSeed(224, 225, makeCastMap([Q$HasAttachHandlers, Q$HasHandlers, Q$EventListener, Q$HasVisibility, Q$IsWidget, Q$UIObject, Q$Widget]));
_.remove_3 = function remove_9(w){
  return $remove_4(this, w);
}
;
function $clinit_AttachDetachException(){
  $clinit_AttachDetachException = nullMethod;
  attachCommand = new AttachDetachException$1_0;
  detachCommand = new AttachDetachException$2_0;
}

function AttachDetachException_0(causes){
  UmbrellaException_2.call(this, causes);
}

function tryCommand(hasWidgets, c){
  $clinit_AttachDetachException();
  var $e0, caught, e, w, w$iterator;
  caught = null;
  for (w$iterator = hasWidgets.iterator_0(); w$iterator.hasNext();) {
    w = w$iterator.next_0();
    try {
      c.execute_1(w);
    }
     catch ($e0) {
      $e0 = caught_0($e0);
      if (instanceOf($e0, Q$Throwable)) {
        e = $e0;
        !caught && (caught = new HashSet_0);
        $add_11(caught, e);
      }
       else 
        throw $e0;
    }
  }
  if (caught) {
    throw new AttachDetachException_0(caught);
  }
}

defineSeed(227, 167, makeCastMap([Q$UmbrellaException, Q$Serializable, Q$Exception, Q$RuntimeException, Q$Throwable]), AttachDetachException_0);
var attachCommand, detachCommand;
function AttachDetachException$1_0(){
}

defineSeed(228, 1, {}, AttachDetachException$1_0);
_.execute_1 = function execute_5(w){
  w.onAttach();
}
;
function AttachDetachException$2_0(){
}

defineSeed(229, 1, {}, AttachDetachException$2_0);
_.execute_1 = function execute_6(w){
  $onDetach(w);
}
;
function $clinit_PotentialElement(){
  $clinit_PotentialElement = nullMethod;
  declareShim();
}

function $resolve(this$static){
  return this$static.__gwt_resolve?this$static.__gwt_resolve():this$static;
}

function declareShim(){
  var shim = function(){
  }
  ;
  shim.prototype = {className:'', clientHeight:0, clientWidth:0, dir:'', getAttribute:function(name_0, value){
    return this[name_0];
  }
  , href:'', id:'', lang:'', nodeType:1, removeAttribute:function(name_0, value){
    this[name_0] = undefined;
  }
  , setAttribute:function(name_0, value){
    this[name_0] = value;
  }
  , src:'', style:{}, title:''};
  $wnd.GwtPotentialElementShim = shim;
}

function $clinit_RootPanel(){
  $clinit_RootPanel = nullMethod;
  maybeDetachCommand = new RootPanel$1_0;
  rootPanels = new HashMap_0;
  widgetsToDetach = new HashSet_0;
}

function RootPanel_0(elem){
  this.children = new WidgetCollection_0(this);
  this.element = elem;
  $onAttach(this);
}

function detachNow(widget){
  $clinit_RootPanel();
  try {
    $onDetach(widget);
  }
   finally {
    $remove_13(widgetsToDetach, widget);
  }
}

function detachWidgets(){
  $clinit_RootPanel();
  try {
    tryCommand(widgetsToDetach, maybeDetachCommand);
  }
   finally {
    widgetsToDetach.map.clear_0();
    rootPanels.clear_0();
  }
}

function get_9(){
  $clinit_RootPanel();
  var rp;
  rp = rootPanels.get_1(null);
  if (rp) {
    return rp;
  }
  rootPanels.size_0() == 0 && addCloseHandler(new RootPanel$2_0);
  rp = new RootPanel$DefaultRootPanel_0;
  rootPanels.put(null, rp);
  $add_11(widgetsToDetach, rp);
  return rp;
}

function getBodyElement(){
  $clinit_RootPanel();
  return $doc.body;
}

defineSeed(231, 224, makeCastMap([Q$HasAttachHandlers, Q$HasHandlers, Q$EventListener, Q$HasVisibility, Q$IsWidget, Q$UIObject, Q$Widget]));
var maybeDetachCommand, rootPanels, widgetsToDetach;
function RootPanel$1_0(){
}

defineSeed(232, 1, {}, RootPanel$1_0);
_.execute_1 = function execute_7(w){
  w.attached && $onDetach(w);
}
;
function RootPanel$2_0(){
}

defineSeed(233, 1, {}, RootPanel$2_0);
function RootPanel$DefaultRootPanel_0(){
  RootPanel_0.call(this, getBodyElement());
}

defineSeed(234, 231, makeCastMap([Q$HasAttachHandlers, Q$HasHandlers, Q$EventListener, Q$HasVisibility, Q$IsWidget, Q$UIObject, Q$Widget]), RootPanel$DefaultRootPanel_0);
function $add_4(this$static, w){
  $insert(this$static, w, this$static.size);
}

function $indexOf_1(this$static, w){
  var i;
  for (i = 0; i < this$static.size; ++i) {
    if (this$static.array[i] == w) {
      return i;
    }
  }
  return -1;
}

function $insert(this$static, w, beforeIndex){
  var i, newArray;
  if (beforeIndex < 0 || beforeIndex > this$static.size) {
    throw new IndexOutOfBoundsException_0;
  }
  if (this$static.size == this$static.array.length) {
    newArray = initDim(_3Lcom_google_gwt_user_client_ui_Widget_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Widget, this$static.array.length * 2, 0);
    for (i = 0; i < this$static.array.length; ++i) {
      setCheck(newArray, i, this$static.array[i]);
    }
    this$static.array = newArray;
  }
  ++this$static.size;
  for (i = this$static.size - 1; i > beforeIndex; --i) {
    setCheck(this$static.array, i, this$static.array[i - 1]);
  }
  setCheck(this$static.array, beforeIndex, w);
}

function $remove_5(this$static, index){
  var i;
  if (index < 0 || index >= this$static.size) {
    throw new IndexOutOfBoundsException_0;
  }
  --this$static.size;
  for (i = index; i < this$static.size; ++i) {
    setCheck(this$static.array, i, this$static.array[i + 1]);
  }
  setCheck(this$static.array, this$static.size, null);
}

function $remove_6(this$static, w){
  var index;
  index = $indexOf_1(this$static, w);
  if (index == -1) {
    throw new NoSuchElementException_0;
  }
  $remove_5(this$static, index);
}

function WidgetCollection_0(parent_0){
  this.parent_0 = parent_0;
  this.array = initDim(_3Lcom_google_gwt_user_client_ui_Widget_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Widget, 4, 0);
}

defineSeed(235, 1, {}, WidgetCollection_0);
_.iterator_0 = function iterator_3(){
  return new WidgetCollection$WidgetIterator_0(this);
}
;
_.array = null;
_.parent_0 = null;
_.size = 0;
function $next_0(this$static){
  if (this$static.index_0 >= this$static.this$0.size) {
    throw new NoSuchElementException_0;
  }
  return this$static.this$0.array[++this$static.index_0];
}

function WidgetCollection$WidgetIterator_0(this$0){
  this.this$0 = this$0;
}

defineSeed(236, 1, {}, WidgetCollection$WidgetIterator_0);
_.hasNext = function hasNext_0(){
  return this.index_0 < this.this$0.size - 1;
}
;
_.next_0 = function next_1(){
  return $next_0(this);
}
;
_.remove_2 = function remove_10(){
  if (this.index_0 < 0 || this.index_0 >= this.this$0.size) {
    throw new IllegalStateException_0;
  }
  this.this$0.parent_0.remove_3(this.this$0.array[this.index_0--]);
}
;
_.index_0 = -1;
_.this$0 = null;
function toJsArray(data){
  var i, jsan, len;
  jsan = [];
  len = data.length;
  for (i = len - 1; i >= 0; --i) {
    jsan[i] = data[i];
  }
  return jsan;
}

function toJsArray_0(data){
  var i, jsan, len;
  jsan = [];
  len = data.length;
  for (i = len - 1; i >= 0; --i) {
    jsan[i] = data[i];
  }
  return jsan;
}

function $attachShader(this$static, program, shader){
  this$static.attachShader(program, shader);
}

function $bindBuffer(this$static, target, buffer){
  this$static.bindBuffer(target, buffer);
}

function $bindFramebuffer(this$static, target, framebuffer){
  this$static.bindFramebuffer(target, framebuffer);
}

function $bindTexture(this$static, target, texture){
  this$static.bindTexture(target, texture);
}

function $bufferData(this$static, target, data, usage){
  this$static.bufferData(target, data, usage);
}

function $clear_1(this$static, mask){
  this$static.clear(mask);
}

function $clearColor(this$static, red, green, blue, alpha){
  this$static.clearColor(red, green, blue, alpha);
}

function $compileShader(this$static, shader){
  this$static.compileShader(shader);
}

function $createShader(this$static, type){
  return this$static.createShader(type);
}

function $deleteBuffer(this$static, buffer){
  this$static.deleteBuffer(buffer);
}

function $deleteFramebuffer(this$static, framebuffer){
  this$static.deleteFramebuffer(framebuffer);
}

function $deleteProgram(this$static, program){
  this$static.deleteProgram(program);
}

function $deleteRenderbuffer(this$static, renderbuffer){
  this$static.deleteRenderbuffer(renderbuffer);
}

function $deleteShader(this$static, shader){
  this$static.deleteShader(shader);
}

function $deleteTexture(this$static, texture){
  this$static.deleteTexture(texture);
}

function $disableVertexAttribArray(this$static, index){
  this$static.disableVertexAttribArray(index);
}

function $drawElements(this$static, mode, count, type, offset){
  this$static.drawElements(mode, count, type, offset);
}

function $enableVertexAttribArray(this$static, index){
  this$static.enableVertexAttribArray(index);
}

function $framebufferTexture2D(this$static, target, attachment, textarget, texture, level){
  this$static.framebufferTexture2D(target, attachment, textarget, texture, level);
}

function $getAttribLocation(this$static, program, name_0){
  return this$static.getAttribLocation(program, name_0);
}

function $getProgramInfoLog(this$static, program){
  return this$static.getProgramInfoLog(program);
}

function $getProgramParameterb(this$static, program, pname){
  return this$static.getProgramParameter(program, pname);
}

function $getShaderInfoLog(this$static, shader){
  return this$static.getShaderInfoLog(shader);
}

function $getShaderParameterb(this$static, shader, pname){
  return this$static.getShaderParameter(shader, pname);
}

function $getUniformLocation(this$static, program, name_0){
  return this$static.getUniformLocation(program, name_0);
}

function $linkProgram(this$static, program){
  this$static.linkProgram(program);
}

function $readPixels(this$static, x, y, width, height, format, type, pixels){
  this$static.readPixels(x, y, width, height, format, type, pixels);
}

function $shaderSource(this$static, shader, source){
  this$static.shaderSource(shader, source);
}

function $texImage2D(this$static, target, level, internalformat, width, height, border, format, type, pixels){
  this$static.texImage2D(target, level, internalformat, width, height, border, format, type, pixels);
}

function $texImage2D_0(this$static, target, level, internalformat, format, type, image){
  this$static.texImage2D(target, level, internalformat, format, type, image);
}

function $texParameteri(this$static, target, pname, param){
  this$static.texParameteri(target, pname, param);
}

function $uniform1i(this$static, location_0, x){
  this$static.uniform1i(location_0, x);
}

function $uniform2f(this$static, location_0, x, y){
  this$static.uniform2f(location_0, x, y);
}

function $uniform4fv(this$static, location_0, v){
  this$static.uniform4fv(location_0, v);
}

function $useProgram(this$static, program){
  this$static.useProgram(program);
}

function $vertexAttribPointer(this$static, indx, size, type, normalized, stride, offset){
  this$static.vertexAttribPointer(indx, size, type, normalized, stride, offset);
}

function $viewport(this$static, x, y, width, height){
  this$static.viewport(x, y, width, height);
}

function getContext(canvas, attributes){
  var names = ['experimental-webgl', 'webgl', 'moz-webgl', 'webkit-webgl', 'webkit-3d'];
  for (var i = 0; i < names.length; i++) {
    try {
      var ctx = canvas.getContext(names[i], attributes);
      if (ctx != null) {
        if ($wnd.WebGLDebugUtils) {
          $wnd.console && $wnd.console.log && console.log('WebGL debugging enabled');
          return $wnd.WebGLDebugUtils.makeDebugContext(ctx);
        }
        return ctx;
      }
    }
     catch (e) {
    }
  }
  return null;
}

function $setOnReadyStateChange(this$static, handler){
  var _this = this$static;
  this$static.onreadystatechange = $entry(function(){
    handler.onReadyStateChange(_this);
  }
  );
}

function create_7(){
  var xhr;
  if ($wnd.XMLHttpRequest) {
    xhr = new $wnd.XMLHttpRequest;
  }
   else {
    try {
      xhr = new $wnd.ActiveXObject('MSXML2.XMLHTTP.3.0');
    }
     catch (e) {
      xhr = new $wnd.ActiveXObject('Microsoft.XMLHTTP');
    }
  }
  return xhr;
}

function $removeHandler(this$static){
  $doRemove(this$static.this$0, this$static.val$type, this$static.val$source, this$static.val$handler);
}

function SimpleEventBus$1_0(this$0, val$type, val$handler){
  this.this$0 = this$0;
  this.val$type = val$type;
  this.val$source = null;
  this.val$handler = val$handler;
}

defineSeed(249, 1, {}, SimpleEventBus$1_0);
_.this$0 = null;
_.val$handler = null;
_.val$source = null;
_.val$type = null;
function SimpleEventBus$2_0(this$0, val$type, val$handler){
  this.this$0 = this$0;
  this.val$type = val$type;
  this.val$source = null;
  this.val$handler = val$handler;
}

defineSeed(250, 1, {}, SimpleEventBus$2_0);
_.execute = function execute_8(){
  $doAddNow(this.this$0, this.val$type, this.val$source, this.val$handler);
}
;
_.this$0 = null;
_.val$handler = null;
_.val$source = null;
_.val$type = null;
function SimpleEventBus$3_0(this$0, val$type, val$source, val$handler){
  this.this$0 = this$0;
  this.val$type = val$type;
  this.val$source = val$source;
  this.val$handler = val$handler;
}

defineSeed(251, 1, {}, SimpleEventBus$3_0);
_.execute = function execute_9(){
  $doRemoveNow(this.this$0, this.val$type, this.val$source, this.val$handler);
}
;
_.this$0 = null;
_.val$handler = null;
_.val$source = null;
_.val$type = null;
function $clinit_NuitLocale(){
  $clinit_NuitLocale = nullMethod;
  ENGLISH = new NuitLocale_0('ENGLISH', 0);
  FRENCH = new NuitLocale_0('FRENCH', 1);
  $VALUES_17 = initValues(_3Lim_bci_jnuit_NuitLocale_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$NuitLocale, [ENGLISH, FRENCH]);
}

function NuitLocale_0(enum$name, enum$ordinal){
  Enum_0.call(this, enum$name, enum$ordinal);
}

function values_18(){
  $clinit_NuitLocale();
  return $VALUES_17;
}

defineSeed(252, 11, makeCastMap([Q$NuitLocale, Q$Serializable, Q$Comparable, Q$Enum]), NuitLocale_0);
var $VALUES_17, ENGLISH, FRENCH;
function $getMenuActionList(this$static){
  return new Arrays$ArrayList_0(initValues(_3Lim_bci_jnuit_controls_Action_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Action, [this$static.menuUp.action, this$static.menuDown.action, this$static.menuLeft.action, this$static.menuRight.action, this$static.menuOK.action, this$static.menuCancel.action]));
}

function $getMessage(this$static, key){
  return $getMessage_0(this$static.translator, key);
}

function $getPressAnyKeyAction(this$static){
  !this$static.pressAnyKeyAction && (this$static.pressAnyKeyAction = new Action_1('nuit.action.press.any.key', $getPossibleControls(this$static.controls)));
  return this$static.pressAnyKeyAction;
}

function $resetInputPoll(this$static){
  this$static.menuUp.previousStates = null;
  this$static.menuDown.previousStates = null;
  this$static.menuLeft.previousStates = null;
  this$static.menuRight.previousStates = null;
  this$static.menuOK.previousStates = null;
  this$static.menuCancel.previousStates = null;
}

function $update(this$static, root){
  var isMouseButtonDown;
  $poll(this$static.menuUp);
  $poll(this$static.menuDown);
  $poll(this$static.menuLeft);
  $poll(this$static.menuRight);
  $poll(this$static.menuOK);
  $poll(this$static.menuCancel);
  this$static.menuUp.activated && $onUp(root);
  this$static.menuDown.activated && $onDown(root);
  this$static.menuLeft.activated && $onLeft(root);
  this$static.menuRight.activated && $onRight(root);
  this$static.menuOK.activated && $onOK(root);
  this$static.menuCancel.activated && $onCancel(root);
  $pollPointer(this$static.controls, root.width_0, root.height_0, this$static.pointer);
  (this$static.pointer.x != this$static.oldPointerX || this$static.pointer.y != this$static.oldPointerY) && $onMouseMove_0(root, this$static.pointer.x, this$static.pointer.y);
  this$static.oldPointerX = this$static.pointer.x;
  this$static.oldPointerY = this$static.pointer.y;
  isMouseButtonDown = this$static.pointer.down;
  isMouseButtonDown && ($clinit_Boolean() , FALSE) == this$static.oldIsMouseButtonDown && $onMouseClick(root, this$static.pointer.x, this$static.pointer.y);
  this$static.oldIsMouseButtonDown = ($clinit_Boolean() , isMouseButtonDown?TRUE:FALSE);
}

function NuitToolkit_0(controls, translator, font, renderer, audio){
  this.pointer = new Pointer_0;
  this.font_0 = font;
  this.translator = translator;
  this.renderer = renderer;
  this.controls = controls;
  this.audio = audio;
  this.menuUp = new ActionActivatedDetector_0(new Action_1('nuit.action.menu.up', $getDefaultMenuUpControls(controls)));
  this.menuDown = new ActionActivatedDetector_0(new Action_1('nuit.action.menu.down', $getDefaultMenuDownControls(controls)));
  this.menuLeft = new ActionActivatedDetector_0(new Action_1('nuit.action.menu.left', $getDefaultMenuLeftControls(controls)));
  this.menuRight = new ActionActivatedDetector_0(new Action_1('nuit.action.menu.right', $getDefaultMenuRightControls(controls)));
  this.menuOK = new ActionActivatedDetector_0(new Action_1('nuit.action.menu.ok', $getDefaultMenuOkControls(controls)));
  this.menuCancel = new ActionActivatedDetector_0(new Action_1('nuit.action.menu.cancel', $getDefaultMenuCancelControls(controls)));
}

defineSeed(253, 47, {}, NuitToolkit_0);
_.audio = null;
_.controls = null;
_.font_0 = null;
_.menuCancel = null;
_.menuDown = null;
_.menuLeft = null;
_.menuOK = null;
_.menuRight = null;
_.menuUp = null;
_.oldIsMouseButtonDown = null;
_.oldPointerX = 0;
_.oldPointerY = 0;
_.pressAnyKeyAction = null;
_.renderer = null;
_.translator = null;
function $addTranslation(this$static, locale, key, message){
  $get_8(this$static.translations, locale).put(key, message);
}

function $getMessage_0(this$static, key){
  var l$array, l$index, l$max, message;
  message = $get_8(this$static.translations, this$static.currentLocale).get_1(key);
  if (null == message) {
    for (l$array = ($clinit_NuitLocale() , $clinit_NuitLocale() , $VALUES_17) , l$index = 0 , l$max = l$array.length; l$index < l$max; ++l$index) {
      message = $get_8(this$static.translations, this$static.currentLocale).get_1(key);
      if (null != message) {
        break;
      }
    }
  }
  null == message && (message = key);
  return message;
}

--></script>
<script><!--
function NuitTranslator_0(){
  var l_0, l$array, l$index, l$max;
  this.translations = new EnumMap_0(Lim_bci_jnuit_NuitLocale_2_classLit);
  this.currentLocale = ($clinit_NuitLocale() , ENGLISH);
  for (l$array = $VALUES_17 , l$index = 0 , l$max = l$array.length; l$index < l$max; ++l$index) {
    l_0 = l$array[l$index];
    $put_4(this.translations, l_0, new HashMap_0);
  }
  $addTranslation(this, ENGLISH, 'nuit.action.menu.up', 'Up');
  $addTranslation(this, ENGLISH, 'nuit.action.menu.down', 'Down');
  $addTranslation(this, ENGLISH, 'nuit.action.menu.left', 'Left');
  $addTranslation(this, ENGLISH, 'nuit.action.menu.right', 'Right');
  $addTranslation(this, ENGLISH, 'nuit.action.menu.ok', 'OK');
  $addTranslation(this, ENGLISH, 'nuit.action.menu.cancel', 'Cancel');
  $addTranslation(this, ENGLISH, 'nuit.action.press.any.key', 'Press any key');
  $addTranslation(this, ENGLISH, 'nuit.video.configurator.mode', 'Mode');
  $addTranslation(this, ENGLISH, 'nuit.video.configurator.fullscreen', 'Fullscreen');
  $addTranslation(this, ENGLISH, 'nuit.video.configurator.apply', 'Apply');
  $addTranslation(this, ENGLISH, 'nuit.video.configurator.back', 'Back');
  $addTranslation(this, ENGLISH, 'nuit.audio.configurator.music.volume', 'Music volume');
  $addTranslation(this, ENGLISH, 'nuit.audio.configurator.effects.volume', 'Effects volume');
  $addTranslation(this, ENGLISH, 'nuit.audio.configurator.back', 'Back');
  $addTranslation(this, ENGLISH, 'nuit.language.configurator.texts', 'Texts');
  $addTranslation(this, ENGLISH, 'nuit.language.configurator.voices', 'Voices');
  $addTranslation(this, ENGLISH, 'nuit.language.configurator.back', 'Back');
  $addTranslation(this, ENGLISH, 'nuit.controls.configurator.action', 'Action');
  $addTranslation(this, ENGLISH, 'nuit.controls.configurator.control', 'Control');
  $addTranslation(this, ENGLISH, 'nuit.controls.configurator.alternative', 'Alternative');
  $addTranslation(this, ENGLISH, 'nuit.controls.configurator.back', 'Back');
  $addTranslation(this, ENGLISH, 'nuit.controls.configurator.resets', 'Resets');
  $addTranslation(this, ENGLISH, 'nuit.controls.configurator.defaults', 'Defaults');
  $addTranslation(this, ENGLISH, 'nuit.controls.configurator.press.key', 'Press a key...');
  $addTranslation(this, ENGLISH, 'nuit.controls.configurator.press.key.again', 'Press again...');
  $addTranslation(this, ENGLISH, 'nuit.toggle.yes', 'Yes');
  $addTranslation(this, ENGLISH, 'nuit.toggle.no', 'No');
  $addTranslation(this, FRENCH, 'nuit.action.menu.up', 'Haut');
  $addTranslation(this, FRENCH, 'nuit.action.menu.down', 'Bas');
  $addTranslation(this, FRENCH, 'nuit.action.menu.left', 'Gauche');
  $addTranslation(this, FRENCH, 'nuit.action.menu.right', 'Droite');
  $addTranslation(this, FRENCH, 'nuit.action.menu.ok', 'OK');
  $addTranslation(this, FRENCH, 'nuit.action.menu.cancel', 'Annuler');
  $addTranslation(this, FRENCH, 'nuit.action.press.any.key', 'Appuyer sur une touche');
  $addTranslation(this, FRENCH, 'nuit.video.configurator.mode', 'Mode');
  $addTranslation(this, FRENCH, 'nuit.video.configurator.fullscreen', 'Plein \xE9cran');
  $addTranslation(this, FRENCH, 'nuit.video.configurator.apply', 'Appliquer');
  $addTranslation(this, FRENCH, 'nuit.video.configurator.back', 'Retour');
  $addTranslation(this, FRENCH, 'nuit.audio.configurator.music.volume', 'Volume de la musique');
  $addTranslation(this, FRENCH, 'nuit.audio.configurator.effects.volume', 'Volume des effets');
  $addTranslation(this, FRENCH, 'nuit.audio.configurator.back', 'Retour');
  $addTranslation(this, FRENCH, 'nuit.language.configurator.texts', 'Textes');
  $addTranslation(this, FRENCH, 'nuit.language.configurator.voices', 'Voix');
  $addTranslation(this, FRENCH, 'nuit.language.configurator.back', 'Retour');
  $addTranslation(this, FRENCH, 'nuit.controls.configurator.action', 'Action');
  $addTranslation(this, FRENCH, 'nuit.controls.configurator.control', 'Contr\xF4le');
  $addTranslation(this, FRENCH, 'nuit.controls.configurator.alternative', 'Alternative');
  $addTranslation(this, FRENCH, 'nuit.controls.configurator.back', 'Retour');
  $addTranslation(this, FRENCH, 'nuit.controls.configurator.resets', 'R\xE9initialiser');
  $addTranslation(this, FRENCH, 'nuit.controls.configurator.defaults', 'D\xE9fauts');
  $addTranslation(this, FRENCH, 'nuit.controls.configurator.press.key', 'Appuyez...');
  $addTranslation(this, FRENCH, 'nuit.controls.configurator.press.key.again', 'R\xE9appuyez...');
  $addTranslation(this, FRENCH, 'nuit.toggle.yes', 'Oui');
  $addTranslation(this, FRENCH, 'nuit.toggle.no', 'Non');
}

defineSeed(254, 1, {});
function ColoredBackground_0(r, g, b, a){
  this.red = r;
  this.green = g;
  this.blue = b;
  this.alpha_0 = a;
}

defineSeed(255, 1, {}, ColoredBackground_0);
_.accept = function accept(widget, visitor){
  visitor.surface.setFillColor_0(round_int(255 * this.alpha_0) << 24 | round_int(255 * this.red) << 16 | round_int(255 * this.green) << 8 | round_int(255 * this.blue));
  visitor.surface.fillRect_1(widget.x, widget.y, widget.width_0, widget.height_0);
  visitor.surface.setFillColor_0(-1);
}
;
_.update = function update(delta){
}
;
_.alpha_0 = 0;
_.blue = 0;
_.green = 0;
_.red = 0;
function $clinit_NullBackground(){
  $clinit_NullBackground = nullMethod;
  INSTANCE_0 = new NullBackground_0;
}

function NullBackground_0(){
}

defineSeed(256, 1, {}, NullBackground_0);
_.accept = function accept_0(widget, visitor){
}
;
_.update = function update_0(delta){
}
;
var INSTANCE_0;
function ColoredBorder_0(){
  this.red = 0.699999988079071;
  this.green = 0.699999988079071;
  this.blue = 0.699999988079071;
  this.alpha_0 = 1;
  this.size = 2;
}

defineSeed(257, 1, {}, ColoredBorder_0);
_.accept_0 = function accept_1(widget, visitor){
  visitor.visit_10(widget, this);
}
;
_.update = function update_1(delta){
}
;
_.alpha_0 = 0;
_.blue = 0;
_.green = 0;
_.red = 0;
_.size = 0;
function $clinit_NullBorder(){
  $clinit_NullBorder = nullMethod;
  INSTANCE_1 = new NullBorder_0;
}

function $accept(this$static, widget, visitor){
  visitor.visit_11(widget, this$static);
}

function NullBorder_0(){
}

defineSeed(258, 1, {}, NullBorder_0);
_.accept_0 = function accept_2(widget, visitor){
  visitor.visit_11(widget, this);
}
;
_.update = function update_2(delta){
}
;
var INSTANCE_1;
function $setAlternativeControl(this$static, control){
  setCheck(this$static.controls, 1, control);
}

function $setMainControl(this$static, control){
  setCheck(this$static.controls, 0, control);
}

function Action_0(action){
  var i;
  this.name_0 = action.name_0;
  this.controls = initDim(_3Lim_bci_jnuit_controls_Control_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Control, action.controls.length, 0);
  for (i = 0; i < this.controls.length; ++i) {
    setCheck(this.controls, i, action.controls[i]);
  }
}

function Action_1(name_0, ctrls){
  var i, n;
  this.name_0 = name_0;
  this.controls = initDim(_3Lim_bci_jnuit_controls_Control_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Control, max_1(2, ctrls.length), 0);
  i = 0;
  for (n = min_0(this.controls.length, ctrls.length); i < n; ++i) {
    setCheck(this.controls, i, ctrls[i]);
  }
  for (; i < this.controls.length; ++i) {
    setCheck(this.controls, i, ($clinit_NullControl() , INSTANCE_2));
  }
}

defineSeed(259, 1, makeCastMap([Q$Action]), Action_0, Action_1);
_.controls = null;
_.name_0 = null;
function $isPressed(this$static){
  var control, control$array, control$index, control$max;
  for (control$array = this$static.action.controls , control$index = 0 , control$max = control$array.length; control$index < control$max; ++control$index) {
    control = control$array[control$index];
    if (control.getValue_0() > control.getDeadZone()) {
      return true;
    }
  }
  return false;
}

function $poll(this$static){
  var control, controls, i, nbControls, newState;
  controls = this$static.action.controls;
  nbControls = controls.length;
  (null == this$static.previousStates || nbControls != this$static.previousStates.length) && (this$static.previousStates = initDim(_3Ljava_lang_Float_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Float, nbControls, 0));
  this$static.activated = false;
  for (i = 0; i < nbControls; ++i) {
    control = controls[i];
    newState = control.getValue_0();
    !!this$static.previousStates[i] && newState > control.getDeadZone() && this$static.previousStates[i].value_0 <= control.getDeadZone() && (this$static.activated = true);
    this$static.previousStates[i] = new Float_0(newState);
  }
}

function ActionActivatedDetector_0(action){
  this.action = action;
}

defineSeed(260, 1, {}, ActionActivatedDetector_0);
_.action = null;
_.activated = false;
_.previousStates = null;
function ControlActivatedDetector_0(control){
  this.control = control;
}

defineSeed(261, 1, {}, ControlActivatedDetector_0);
_.activated = false;
_.control = null;
_.previousState = null;
function $clinit_NullControl(){
  $clinit_NullControl = nullMethod;
  INSTANCE_2 = new NullControl_0;
}

function NullControl_0(){
}

defineSeed(262, 1, makeCastMap([Q$Control]), NullControl_0);
_.getControllerName = function getControllerName(){
  return '';
}
;
_.getDeadZone = function getDeadZone(){
  return 0.10000000149011612;
}
;
_.getName = function getName(){
  return '';
}
;
_.getValue_0 = function getValue_0(){
  return 0;
}
;
var INSTANCE_2;
function $setDown(this$static, down){
  this$static.down = down;
}

function $setX(this$static, x){
  this$static.x = x;
}

function $setY(this$static, y){
  this$static.y = y;
}

function Pointer_0(){
}

defineSeed(263, 1, {}, Pointer_0);
_.down = false;
_.x = 0;
_.y = 0;
function VideoResolution_0(width, height){
  this.width_0 = width;
  this.height_0 = height;
}

defineSeed(264, 1, makeCastMap([Q$VideoResolution, Q$Comparable]), VideoResolution_0);
_.compareTo$ = function compareTo_0(o){
  var nbPixels, nbPixelsO;
  return nbPixels = this.width_0 * this.height_0 , nbPixelsO = o.width_0 * o.height_0 , nbPixels < nbPixelsO?-1:nbPixels > nbPixelsO?1:0;
}
;
_.equals$ = function equals_5(obj){
  var other;
  if (obj == null) {
    return false;
  }
  if (Lim_bci_jnuit_display_VideoResolution_2_classLit != getClass__devirtual$(obj)) {
    return false;
  }
  other = obj;
  if (this.width_0 != other.width_0) {
    return false;
  }
  return this.height_0 == other.height_0;
}
;
_.hashCode$ = function hashCode_7(){
  var hash;
  hash = 497 + this.width_0;
  hash = 71 * hash + this.height_0;
  return hash;
}
;
_.toString$ = function toString_15(){
  return this.width_0 + ' x ' + this.height_0;
}
;
_.height_0 = 0;
_.width_0 = 0;
function $clinit_ColoredRectangleFocusCursor(){
  $clinit_ColoredRectangleFocusCursor = nullMethod;
  WHITE = new ColoredRectangleFocusCursor_0(1, 1, 1);
  GREY = new ColoredRectangleFocusCursor_0(0.5, 0.5, 0.5);
}

function $accept_0(this$static, focused, visitor){
  var x, y, w, h_0;
  x = focused.x;
  y = focused.y;
  w = focused.width_0;
  h_0 = focused.height_0;
  visitor.this$0.surface.setFillColor_0(round_int(255 * this$static.alpha_0) << 24 | round_int(255 * this$static.red) << 16 | round_int(255 * this$static.green) << 8 | round_int(255 * this$static.blue));
  visitor.this$0.surface.drawLine_0(x, y, x + w, y, 2);
  visitor.this$0.surface.drawLine_0(x, y + h_0, x + w, y + h_0, 2);
  visitor.this$0.surface.drawLine_0(x, y, x, y + h_0, 2);
  visitor.this$0.surface.drawLine_0(x + w, y, x + w, y + h_0, 2);
  visitor.this$0.surface.setFillColor_0(-1);
}

function ColoredRectangleFocusCursor_0(r, g, b){
  $clinit_ColoredRectangleFocusCursor();
  this.red = r;
  this.green = g;
  this.blue = b;
  this.alpha_0 = 1;
}

defineSeed(265, 1, {}, ColoredRectangleFocusCursor_0);
_.alpha_0 = 0;
_.blue = 0;
_.green = 0;
_.red = 0;
var GREY, WHITE;
function $getSound(this$static, name_0){
  var baseName, sound;
  baseName = $substring_0(name_0, 0, $lastIndexOf(name_0, fromCodePoint(46)));
  sound = $getSound_0(this$static.assets, baseName);
  $setVolume_2(sound, this$static.effectsVolume);
  return new PlaynNuitAudio$1_0(sound);
}

function $playMusic(this$static, name_0, loop){
  var baseName;
  !!this$static.music && $stop_2(this$static.music);
  baseName = $substring_0(name_0, 0, $lastIndexOf(name_0, fromCodePoint(46)));
  this$static.music = $getMusic(this$static.assets, baseName);
  $setLooping_0(this$static.music, loop);
  $setVolume_2(this$static.music, this$static.musicVolume);
  $play_0(this$static.music);
}

function $setEffectsVolume(this$static, v){
  this$static.effectsVolume = v;
}

function $setMusicVolume(this$static, v){
  this$static.musicVolume = v;
  !!this$static.music && $setVolume_2(this$static.music, this$static.musicVolume);
}

function $stopMusic(this$static){
  !!this$static.music && $stop_2(this$static.music);
}

function PlaynNuitAudio_0(){
  this.assets = new CachingAssets_0(platform_1.assets);
}

defineSeed(266, 1, {}, PlaynNuitAudio_0);
_.effectsVolume = 1;
_.music = null;
_.musicVolume = 1;
function PlaynNuitAudio$1_0(val$sound){
  this.val$sound = val$sound;
}

defineSeed(267, 1, {}, PlaynNuitAudio$1_0);
_.val$sound = null;
function $getHeight(this$static, str){
  return round_int($height($layoutText(platform_1.graphics, str, this$static.format)));
}

function $getWidth(this$static, str){
  return round_int($width($layoutText(platform_1.graphics, str, this$static.format)));
}

function PlaynNuitFont_0(style){
  this.font_0 = new HtmlFont_0('Arial', style, 24);
  this.format = new TextFormat_0(this.font_0);
}

defineSeed(268, 1, {}, PlaynNuitFont_0);
_.font_0 = null;
_.format = null;
function $getControl(this$static, name_0, defaultValue){
  var control, control$array, control$index, control$max, controlName, controllerName;
  controllerName = $getSystemOrStoreProperty(name_0 + '.controller', null);
  controlName = $getSystemOrStoreProperty(name_0 + '.control', null);
  for (control$array = $getPossibleControls(this$static.controls) , control$index = 0 , control$max = control$array.length; control$index < control$max; ++control$index) {
    control = control$array[control$index];
    if ($equals_0(control.getControllerName(), controllerName) && $equals_0(control.getName(), controlName)) {
      return control;
    }
  }
  return defaultValue;
}

function $getSystemOrStoreProperty(name_0, defaultValue){
  var value;
  value = $getItem_1(platform_1.storage, name_0);
  return null != value?value:defaultValue;
}

function $putBoolean(name_0, value){
  $setItem_1(platform_1.storage, name_0, '' + value);
}

function PlaynNuitPreferences_0(controls){
  this.controls = controls;
}

defineSeed(269, 1, {}, PlaynNuitPreferences_0);
_.controls = null;
function $drawBorders(this$static, widget){
  widget.topBorder.accept_0(widget, this$static.topBorderRenderer);
  widget.bottomBorder.accept_0(widget, this$static.bottomBorderRenderer);
  $accept(widget.leftBorder, widget, this$static.leftBorderRenderer);
  widget.rightBorder.accept_0(widget, this$static.rightBorderRenderer);
}

function $drawContainer(this$static, widget){
  var child, child$iterator, focused, focusedBackground, focusCursor;
  focused = (!widget.focusedChild && (widget.focusedChild = $getTopLeftFocusableChild(widget)) , widget.focusedChild);
  for (child$iterator = new AbstractList$IteratorImpl_0(widget.children); child$iterator.i < child$iterator.this$0_0.size_0();) {
    child = $next_2(child$iterator);
    child.background.accept(child, this$static);
    if (focused == child) {
      if ($isFocusSucked(widget)) {
        focusedBackground = child.suckedFocusedBackground;
        this$static.textColor = child.suckedFocusTextColor;
      }
       else {
        focusedBackground = child.focusedBackground;
        this$static.textColor = child.focusedTextColor;
      }
      !!focusedBackground && focusedBackground.accept(child, this$static);
    }
     else {
      this$static.textColor = child.textColor;
    }
    $drawBorders(this$static, child);
    child.accept_1(this$static);
  }
  !!focused && (focusCursor = $isFocusSucked(widget)?focused.suckedFocusCursor:focused.focusCursor , $accept_0(focusCursor, focused, this$static.focusRenderer) , undefined);
  this$static.textColor = null;
}

function $drawStack(this$static, widget){
  var child;
  child = $getFocusedChild(widget);
  if (child) {
    child.background.accept(child, this$static);
    $drawBorders(this$static, child);
    child.accept_1(this$static);
  }
}

function $drawText(this$static, widget, text, x, y){
  var c, color, textCanvasImage;
  if (text.length) {
    !this$static.textColor?(c = widget.textColor):(c = this$static.textColor);
    color = round_int(255 * c.alpha_0) << 24 | round_int(255 * c.red) << 16 | round_int(255 * c.green) << 8 | round_int(255 * c.blue);
    textCanvasImage = $getTextCanvasImage(this$static.textCache, text, color);
    this$static.surface.drawImage_3(textCanvasImage, x - (!textCanvasImage.img?0:$invScaled(textCanvasImage.scale_0, textCanvasImage.img.width)) / 2, y - (!textCanvasImage.img?0:$invScaled(textCanvasImage.scale_0, textCanvasImage.img.height)) / 2);
  }
}

function $render(this$static, root){
  this$static.surface.save_1();
  this$static.surface.translate_2(root.x, root.y);
  this$static.surface.scale_3(this$static.surface.width_1() / root.width_0, this$static.surface.height_1() / root.height_0);
  root.background.accept(root, this$static);
  $drawBorders(this$static, root);
  $drawStack(this$static, root);
  this$static.surface.restore_1();
  $clearUseless(this$static.textCache);
}

function $setSurface(this$static, surface){
  this$static.surface = surface;
}

function PlaynNuitRenderer_0(translator, font){
  this.topBorderRenderer = new PlaynNuitRenderer$TopBorderRenderer_0(this);
  this.bottomBorderRenderer = new PlaynNuitRenderer$BottomBorderRenderer_0(this);
  this.leftBorderRenderer = new PlaynNuitRenderer$LeftBorderRenderer_0(this);
  this.rightBorderRenderer = new PlaynNuitRenderer$RightBorderRenderer_0(this);
  this.focusRenderer = new PlaynNuitRenderer$FocusRenderer_0(this);
  this.translator = translator;
  this.textCache = new PlaynTextCache_0(font);
}

defineSeed(270, 1, {}, PlaynNuitRenderer_0);
_.visit = function visit(widget){
  $drawContainer(this, widget);
}
;
_.visit_0 = function visit_0(widget){
  $drawText(this, widget, $getMessage_0(this.translator, widget.text), widget.x + widget.width_0 / 2, widget.y + widget.height_0 / 2);
}
;
_.visit_1 = function visit_1(widget){
  $drawContainer(this, widget);
}
;
_.visit_2 = function visit_2(widget){
  var text, text_0;
  text = (text_0 = null , widget.suckFocus?widget.controlToBeConfirmed?(text_0 = $getMessage(widget.this$0.toolkit, 'nuit.controls.configurator.press.key.again')):(text_0 = $getMessage(widget.this$0.toolkit, 'nuit.controls.configurator.press.key')):!!widget.getControl() && (text_0 = $getMessage(widget.this$0.toolkit, widget.getControl().getName())) , text_0);
  null != text && $drawText(this, widget, text, widget.x + widget.width_0 / 2, widget.y + widget.height_0 / 2);
}
;
_.visit_3 = function visit_3(widget){
  $drawContainer(this, widget);
}
;
_.visit_4 = function visit_4(widget){
  var translatedText;
  translatedText = $getMessage_0(this.translator, widget.text);
  $drawText(this, widget, translatedText, widget.x + widget.width_0 / 2, widget.y + widget.height_0 / 2);
}
;
_.visit_5 = function visit_5(widget){
  var text;
  text = '' + (widget.possibleValues.isEmpty()?null:widget.possibleValues.get(widget.selected));
  $drawText(this, widget, text, widget.x + widget.width_0 / 2, widget.y + widget.height_0 / 2);
}
;
_.visit_6 = function visit_6(widget){
  $drawStack(this, widget);
}
;
_.visit_7 = function visit_7(widget){
  $drawContainer(this, widget);
}
;
_.visit_8 = function visit_8(widget){
  $drawText(this, widget, widget.enabled?$getMessage(widget.toolkit, 'nuit.toggle.yes'):$getMessage(widget.toolkit, 'nuit.toggle.no'), widget.x + widget.width_0 / 2, widget.y + widget.height_0 / 2);
}
;
_.visit_9 = function visit_9(widget){
  $drawContainer(this, widget);
}
;
_.surface = null;
_.textCache = null;
_.textColor = null;
_.translator = null;
function PlaynNuitRenderer$BottomBorderRenderer_0(this$0){
  this.this$0 = this$0;
}

defineSeed(271, 1, {}, PlaynNuitRenderer$BottomBorderRenderer_0);
_.visit_10 = function visit_10(widget, border){
  this.this$0.surface.setFillColor_0(round_int(255 * border.alpha_0) << 24 | round_int(255 * border.red) << 16 | round_int(255 * border.green) << 8 | round_int(255 * border.blue));
  this.this$0.surface.drawLine_0(widget.x, widget.y + widget.height_0, widget.x + widget.width_0, widget.y + widget.height_0, border.size);
  this.this$0.surface.setFillColor_0(-1);
}
;
_.visit_11 = function visit_11(widget, border){
}
;
_.this$0 = null;
function PlaynNuitRenderer$FocusRenderer_0(this$0){
  this.this$0 = this$0;
}

defineSeed(272, 1, {}, PlaynNuitRenderer$FocusRenderer_0);
_.this$0 = null;
function PlaynNuitRenderer$LeftBorderRenderer_0(this$0){
  this.this$0 = this$0;
}

defineSeed(273, 1, {}, PlaynNuitRenderer$LeftBorderRenderer_0);
_.visit_10 = function visit_12(widget, border){
  this.this$0.surface.setFillColor_0(round_int(255 * border.alpha_0) << 24 | round_int(255 * border.red) << 16 | round_int(255 * border.green) << 8 | round_int(255 * border.blue));
  this.this$0.surface.drawLine_0(widget.x, widget.y, widget.x, widget.y + widget.height_0, border.size);
  this.this$0.surface.setFillColor_0(-1);
}
;
_.visit_11 = function visit_13(widget, border){
}
;
_.this$0 = null;
function PlaynNuitRenderer$RightBorderRenderer_0(this$0){
  this.this$0 = this$0;
}

defineSeed(274, 1, {}, PlaynNuitRenderer$RightBorderRenderer_0);
_.visit_10 = function visit_14(widget, border){
  this.this$0.surface.setFillColor_0(round_int(255 * border.alpha_0) << 24 | round_int(255 * border.red) << 16 | round_int(255 * border.green) << 8 | round_int(255 * border.blue));
  this.this$0.surface.drawLine_0(widget.x + widget.width_0, widget.y, widget.x + widget.width_0, widget.y + widget.height_0, border.size);
  this.this$0.surface.setFillColor_0(-1);
}
;
_.visit_11 = function visit_15(widget, border){
}
;
_.this$0 = null;
function PlaynNuitRenderer$TopBorderRenderer_0(this$0){
  this.this$0 = this$0;
}

defineSeed(275, 1, {}, PlaynNuitRenderer$TopBorderRenderer_0);
_.visit_10 = function visit_16(widget, border){
  this.this$0.surface.setFillColor_0(round_int(255 * border.alpha_0) << 24 | round_int(255 * border.red) << 16 | round_int(255 * border.green) << 8 | round_int(255 * border.blue));
  this.this$0.surface.drawLine_0(widget.x, widget.y, widget.x + widget.width_0, widget.y, border.size);
  this.this$0.surface.setFillColor_0(-1);
}
;
_.visit_11 = function visit_17(widget, border){
}
;
_.this$0 = null;
function $clearUseless(this$static){
  var cached, currentTime, entry, it;
  it = this$static.cache.entrySet_0().iterator_0();
  currentTime = now_0();
  while (it.hasNext()) {
    entry = it.next_0();
    cached = entry.getValue();
    currentTime > cached.timeToDie && it.remove_2();
  }
}

function $getTextCanvasImage(this$static, text, color){
  var cached, currentTime, key, graphics, textLayout, textImage, canvas;
  key = new PlaynTextCache$CachedTextKey_0(text, color);
  cached = this$static.cache.get_1(key);
  if (!cached) {
    cached = new PlaynTextCache$CachedTextImage_0;
    cached.image = (graphics = platform_1.graphics , textLayout = $layoutText(graphics, text, this$static.font_0.format) , textImage = $createImage(graphics, max_0(textLayout.bounds.x, 0) + textLayout.bounds.width_0, 0.699999988079071 * textLayout.metrics.height_0 + $descent(textLayout.metrics)) , canvas = textImage.canvas , $setFillStyleWeb(canvas.ctx, cssColorString(8092539)) , $fillRect_0(canvas, 0, 0, canvas.width_0, canvas.height_0) , $setFillStyleWeb(canvas.ctx, cssColorString(color)) , $fill_0(textLayout, canvas.ctx) , canvas.isDirty = true , textImage);
    this$static.cache.put(key, cached);
  }
  currentTime = now_0();
  cached.timeToDie = currentTime + 1000;
  return cached.image;
}

function PlaynTextCache_0(font){
  this.cache = new HashMap_0;
  this.font_0 = font;
}

defineSeed(276, 1, {}, PlaynTextCache_0);
_.font_0 = null;
function PlaynTextCache$CachedTextImage_0(){
}

defineSeed(277, 1, {}, PlaynTextCache$CachedTextImage_0);
_.image = null;
_.timeToDie = 0;
function PlaynTextCache$CachedTextKey_0(text, color){
  this.text = text;
  this.color = color;
}

defineSeed(278, 1, {}, PlaynTextCache$CachedTextKey_0);
_.equals$ = function equals_6(obj){
  var other;
  if (obj == null) {
    return false;
  }
  if (Lim_bci_jnuit_playn_PlaynTextCache$CachedTextKey_2_classLit != getClass__devirtual$(obj)) {
    return false;
  }
  other = obj;
  if (this.text == null?other.text != null:!$equals_0(this.text, other.text)) {
    return false;
  }
  return this.color == other.color;
}
;
_.hashCode$ = function hashCode_8(){
  var hash;
  hash = 87 + (this.text != null?getHashCode_0(this.text):0);
  hash = 29 * hash + this.color;
  return hash;
}
;
_.color = 0;
_.text = null;
function KeyControl_0(controls, key){
  this.key_0 = key;
  this.controls = controls;
}

defineSeed(279, 1, makeCastMap([Q$Control]), KeyControl_0);
_.equals$ = function equals_7(obj){
  var other;
  if (obj == null) {
    return false;
  }
  if (Lim_bci_jnuit_playn_controls_KeyControl_2_classLit != getClass__devirtual$(obj)) {
    return false;
  }
  other = obj;
  return this.key_0 == other.key_0;
}
;
_.getControllerName = function getControllerName_0(){
  return 'Keyboard';
}
;
_.getDeadZone = function getDeadZone_0(){
  return 0.10000000149011612;
}
;
_.getName = function getName_0(){
  return this.key_0.name_0;
}
;
_.getValue_0 = function getValue_1(){
  return this.controls.keysDown[this.key_0.ordinal]?1:0;
}
;
_.hashCode$ = function hashCode_9(){
  var hash;
  hash = 329 + getHashCode(this.key_0);
  return hash;
}
;
_.controls = null;
_.key_0 = null;
function MouseButtonControl_0(name_0, button){
  this.button_0 = button;
  this.name_0 = name_0;
}

defineSeed(280, 1, makeCastMap([Q$Control]));
_.equals$ = function equals_8(obj){
  var other;
  if (obj == null) {
    return false;
  }
  if (this.___clazz$ != getClass__devirtual$(obj)) {
    return false;
  }
  other = obj;
  return this.button_0 == other.button_0;
}
;
_.getControllerName = function getControllerName_1(){
  return 'Mouse';
}
;
_.getDeadZone = function getDeadZone_1(){
  return 0.10000000149011612;
}
;
_.getName = function getName_1(){
  return this.name_0;
}
;
_.hashCode$ = function hashCode_10(){
  var hash;
  hash = 413 + this.button_0;
  return hash;
}
;
_.button_0 = 0;
_.name_0 = null;
function $getDefaultMenuCancelControls(this$static){
  var controls;
  controls = initDim(_3Lim_bci_jnuit_controls_Control_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Control, 2, 0);
  setCheck(controls, 0, new KeyControl_0(this$static, ($clinit_Key() , ESCAPE)));
  setCheck(controls, 1, ($clinit_NullControl() , INSTANCE_2));
  return controls;
}

function $getDefaultMenuDownControls(this$static){
  var controls;
  controls = initDim(_3Lim_bci_jnuit_controls_Control_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Control, 2, 0);
  setCheck(controls, 0, new KeyControl_0(this$static, ($clinit_Key() , DOWN_1)));
  setCheck(controls, 1, ($clinit_NullControl() , INSTANCE_2));
  return controls;
}

function $getDefaultMenuLeftControls(this$static){
  var controls;
  controls = initDim(_3Lim_bci_jnuit_controls_Control_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Control, 2, 0);
  setCheck(controls, 0, new KeyControl_0(this$static, ($clinit_Key() , LEFT_2)));
  setCheck(controls, 1, ($clinit_NullControl() , INSTANCE_2));
  return controls;
}

function $getDefaultMenuOkControls(this$static){
  var controls;
  controls = initDim(_3Lim_bci_jnuit_controls_Control_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Control, 2, 0);
  setCheck(controls, 0, new KeyControl_0(this$static, ($clinit_Key() , ENTER)));
  setCheck(controls, 1, ($clinit_NullControl() , INSTANCE_2));
  return controls;
}

function $getDefaultMenuRightControls(this$static){
  var controls;
  controls = initDim(_3Lim_bci_jnuit_controls_Control_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Control, 2, 0);
  setCheck(controls, 0, new KeyControl_0(this$static, ($clinit_Key() , RIGHT_2)));
  setCheck(controls, 1, ($clinit_NullControl() , INSTANCE_2));
  return controls;
}

function $getDefaultMenuUpControls(this$static){
  var controls;
  controls = initDim(_3Lim_bci_jnuit_controls_Control_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Control, 2, 0);
  setCheck(controls, 0, new KeyControl_0(this$static, ($clinit_Key() , UP_1)));
  setCheck(controls, 1, ($clinit_NullControl() , INSTANCE_2));
  return controls;
}

function $getPossibleControls(this$static){
  var key, key$array, key$index, key$max, possibleControls;
  possibleControls = new ArrayList_0;
  for (key$array = ($clinit_Key() , $clinit_Key() , $VALUES_27) , key$index = 0 , key$max = key$array.length; key$index < key$max; ++key$index) {
    key = key$array[key$index];
    $add_0(possibleControls, new KeyControl_0(this$static, key));
  }
  $add_0(possibleControls, new PlaynNuitControls$6_0(this$static));
  if ($hasMouse(platform_1)) {
    $add_0(possibleControls, new PlaynNuitControls$5_0(this$static));
    $add_0(possibleControls, new PlaynNuitControls$4_0(this$static));
  }
  return $toArray_0(possibleControls, initDim(_3Lim_bci_jnuit_controls_Control_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Control, possibleControls.size, 0));
}

function $pollPointer(this$static, virtualResolutionWidth, virtualResolutionHeight, p){
  $setX(p, this$static.pointer.x * virtualResolutionWidth / platform_1.graphics.width_2());
  $setY(p, this$static.pointer.y * virtualResolutionHeight / platform_1.graphics.height_2());
  $setDown(p, this$static.pointer.down);
}

--></script>
<script><!--
function PlaynNuitControls_0(){
  this.pointer = new Pointer_0;
  this.keysDown = initDim(_3Z_classLit, makeCastMap([Q$Serializable]), -1, ($clinit_Key() , $clinit_Key() , $VALUES_27).length, 2);
  $setListener_1(platform_1.keyboard, new PlaynNuitControls$1_0(this));
  $hasMouse(platform_1)?$setListener(platform_1.mouse, new PlaynNuitControls$2_0(this)):$setListener_0(platform_1.pointer, new PlaynNuitControls$3_0(this));
}

defineSeed(281, 1, {}, PlaynNuitControls_0);
_.isMouseButtonMiddleDown = false;
_.isMouseButtonRightDown = false;
defineSeed(283, 1, {});
function $onKeyDown(this$static, event_0){
  this$static.this$0.keysDown[event_0.key_0.ordinal] = true;
}

function $onKeyUp(this$static, event_0){
  this$static.this$0.keysDown[event_0.key_0.ordinal] = false;
}

function PlaynNuitControls$1_0(this$0){
  this.this$0 = this$0;
}

defineSeed(282, 283, {}, PlaynNuitControls$1_0);
_.this$0 = null;
defineSeed(285, 1, {});
function $onMouseDown(this$static, be){
  var button;
  button = be.button_0;
  0 == button?(this$static.this$0.pointer.down = true , undefined):2 == be.button_0?(this$static.this$0.isMouseButtonRightDown = true):1 == be.button_0 && (this$static.this$0.isMouseButtonMiddleDown = true);
}

function $onMouseMove(this$static, me){
  $setX(this$static.this$0.pointer, me.x);
  $setY(this$static.this$0.pointer, me.y);
}

function $onMouseUp(this$static, be){
  var button;
  button = be.button_0;
  0 == button?(this$static.this$0.pointer.down = false , undefined):2 == be.button_0?(this$static.this$0.isMouseButtonRightDown = false):1 == be.button_0 && (this$static.this$0.isMouseButtonMiddleDown = false);
}

function PlaynNuitControls$2_0(this$0){
  this.this$0 = this$0;
}

defineSeed(284, 285, {}, PlaynNuitControls$2_0);
_.this$0 = null;
function $onPointerDrag(this$static, event_0){
  $setX(this$static.this$0.pointer, event_0.x);
  $setY(this$static.this$0.pointer, event_0.y);
}

function $onPointerEnd(this$static, event_0){
  $setX(this$static.this$0.pointer, event_0.x);
  $setY(this$static.this$0.pointer, event_0.y);
  this$static.this$0.pointer.down = false;
}

function $onPointerStart(this$static, event_0){
  $setX(this$static.this$0.pointer, event_0.x);
  $setY(this$static.this$0.pointer, event_0.y);
  this$static.this$0.pointer.down = true;
}

function PlaynNuitControls$3_0(this$0){
  this.this$0 = this$0;
}

defineSeed(286, 1, {}, PlaynNuitControls$3_0);
_.this$0 = null;
function PlaynNuitControls$4_0(this$0){
  this.this$0 = this$0;
  MouseButtonControl_0.call(this, 'Middle click', 1);
}

defineSeed(287, 280, makeCastMap([Q$Control]), PlaynNuitControls$4_0);
_.getValue_0 = function getValue_2(){
  return this.this$0.isMouseButtonMiddleDown?1:0;
}
;
_.this$0 = null;
function PlaynNuitControls$5_0(this$0){
  this.this$0 = this$0;
  MouseButtonControl_0.call(this, 'Right click', 2);
}

defineSeed(288, 280, makeCastMap([Q$Control]), PlaynNuitControls$5_0);
_.getValue_0 = function getValue_3(){
  return this.this$0.isMouseButtonRightDown?1:0;
}
;
_.this$0 = null;
function PlaynNuitControls$6_0(this$0){
  this.this$0 = this$0;
  MouseButtonControl_0.call(this, 'Left click', 0);
}

defineSeed(289, 280, makeCastMap([Q$Control]), PlaynNuitControls$6_0);
_.getValue_0 = function getValue_4(){
  return this.this$0.pointer.down?1:0;
}
;
_.this$0 = null;
function $clinit_TextColor(){
  $clinit_TextColor = nullMethod;
  WHITE_0 = new TextColor_0(1, 1);
}

function TextColor_0(green, blue){
  $clinit_TextColor();
  this.red = 1;
  this.green = green;
  this.blue = blue;
  this.alpha_0 = 1;
}

defineSeed(290, 1, {}, TextColor_0);
_.alpha_0 = 0;
_.blue = 0;
_.green = 0;
_.red = 0;
var WHITE_0;
function $add_5(this$static, child){
  $remove_1(this$static.children, child);
  $add_0(this$static.children, child);
  child.parent_0 = this$static;
}

function $close(this$static){
  !!this$static.parent_0 && $remove_7(this$static.parent_0, this$static);
}

function $findClosestDownFocusableWidget(this$static, widget){
  var closestLeftChild, closestLeftChildLengthSquared, lenghtSquared, w, w$iterator;
  closestLeftChild = null;
  if (widget) {
    closestLeftChildLengthSquared = 3.4028234663852886E38;
    for (w$iterator = new AbstractList$IteratorImpl_0(this$static.children); w$iterator.i < w$iterator.this$0_0.size_0();) {
      w = $next_2(w$iterator);
      if (w.isFocusable() && w.y + w.height_0 / 2 > widget.y + widget.height_0 / 2) {
        lenghtSquared = distanceSquared(w, widget);
        if (!closestLeftChild || lenghtSquared < closestLeftChildLengthSquared) {
          closestLeftChildLengthSquared = lenghtSquared;
          closestLeftChild = w;
        }
      }
    }
  }
  return closestLeftChild;
}

function $findClosestLeftFocusableWidget(this$static, widget){
  var closestLeftChild, closestLeftChildLengthSquared, lenghtSquared, w, w$iterator;
  closestLeftChild = null;
  if (widget) {
    closestLeftChildLengthSquared = 3.4028234663852886E38;
    for (w$iterator = new AbstractList$IteratorImpl_0(this$static.children); w$iterator.i < w$iterator.this$0_0.size_0();) {
      w = $next_2(w$iterator);
      if (w.isFocusable() && w.x + w.width_0 / 2 < widget.x + widget.width_0 / 2) {
        lenghtSquared = distanceSquared(w, widget);
        if (!closestLeftChild || lenghtSquared < closestLeftChildLengthSquared) {
          closestLeftChildLengthSquared = lenghtSquared;
          closestLeftChild = w;
        }
      }
    }
  }
  return closestLeftChild;
}

function $findClosestRightFocusableWidget(this$static, widget){
  var closestLeftChild, closestLeftChildLengthSquared, lenghtSquared, w, w$iterator;
  closestLeftChild = null;
  if (widget) {
    closestLeftChildLengthSquared = 3.4028234663852886E38;
    for (w$iterator = new AbstractList$IteratorImpl_0(this$static.children); w$iterator.i < w$iterator.this$0_0.size_0();) {
      w = $next_2(w$iterator);
      if (w.isFocusable() && w.x + w.width_0 / 2 > widget.x + widget.width_0 / 2) {
        lenghtSquared = distanceSquared(w, widget);
        if (!closestLeftChild || lenghtSquared < closestLeftChildLengthSquared) {
          closestLeftChildLengthSquared = lenghtSquared;
          closestLeftChild = w;
        }
      }
    }
  }
  return closestLeftChild;
}

function $findClosestUpFocusableWidget(this$static, widget){
  var closestLeftChild, closestLeftChildLengthSquared, lenghtSquared, w, w$iterator;
  closestLeftChild = null;
  if (widget) {
    closestLeftChildLengthSquared = 3.4028234663852886E38;
    for (w$iterator = new AbstractList$IteratorImpl_0(this$static.children); w$iterator.i < w$iterator.this$0_0.size_0();) {
      w = $next_2(w$iterator);
      if (w.isFocusable() && w.y + w.height_0 / 2 < widget.y + widget.height_0 / 2) {
        lenghtSquared = distanceSquared(w, widget);
        if (!closestLeftChild || lenghtSquared < closestLeftChildLengthSquared) {
          closestLeftChildLengthSquared = lenghtSquared;
          closestLeftChild = w;
        }
      }
    }
  }
  return closestLeftChild;
}

function $getFocusableChildren(this$static){
  var result, w, w$iterator;
  result = new ArrayList_0;
  for (w$iterator = new AbstractList$IteratorImpl_0(this$static.children); w$iterator.i < w$iterator.this$0_0.size_0();) {
    w = $next_2(w$iterator);
    w.isFocusable() && (setCheck(result.array, result.size++, w) , true);
  }
  return result;
}

function $getTopLeftFocusableChild(this$static){
  var focusableChildren;
  focusableChildren = $getFocusableChildren(this$static);
  return focusableChildren.size == 0?null:($clinit_Collections() , max_2(focusableChildren, reverseOrder(new Widget$1_0)));
}

function $onCancel(this$static){
  var child;
  child = this$static.getFocusedChild();
  !!child && child.onCancel();
}

function $onDown(this$static){
  var child;
  child = this$static.getFocusedChild();
  !!child && child.onDown();
}

function $onLeft(this$static){
  var child;
  child = this$static.getFocusedChild();
  !!child && child.onLeft();
}

function $onOK(this$static){
  var child;
  child = this$static.getFocusedChild();
  !!child && child.onOK();
}

function $onRight(this$static){
  var child;
  child = this$static.getFocusedChild();
  !!child && child.onRight();
}

function $onUp(this$static){
  var child;
  child = this$static.getFocusedChild();
  !!child && child.onUp();
}

function $remove_7(this$static, child){
  if (child) {
    $remove_1(this$static.children, child);
    child.parent_0 = null;
  }
}

function $setBackground(this$static, background){
  this$static.background = background;
}

function $setBottomBorder(this$static, bottomBorder){
  this$static.bottomBorder = bottomBorder;
}

function $setFocusCursor(this$static, focusCursor){
  this$static.focusCursor = focusCursor;
}

function $setFocusedBackground(this$static, focusedBackground){
  this$static.focusedBackground = focusedBackground;
}

function $setFocusedTextColor(this$static, focusedTextColor){
  this$static.focusedTextColor = focusedTextColor;
}

function $setSuckedFocusCursor(this$static, suckedFocusCursor){
  this$static.suckedFocusCursor = suckedFocusCursor;
}

function $setSuckedFocusedBackground(this$static, suckedFocusedBackground){
  this$static.suckedFocusedBackground = suckedFocusedBackground;
}

function $setTopBorder(this$static, topBorder){
  this$static.topBorder = topBorder;
}

function Widget_1(){
  this.focusCursor = ($clinit_ColoredRectangleFocusCursor() , WHITE);
  this.suckedFocusCursor = GREY;
  this.background = ($clinit_NullBackground() , INSTANCE_0);
  this.focusedBackground = INSTANCE_0;
  this.suckedFocusedBackground = INSTANCE_0;
  this.topBorder = ($clinit_NullBorder() , INSTANCE_1);
  this.bottomBorder = INSTANCE_1;
  this.leftBorder = INSTANCE_1;
  this.rightBorder = INSTANCE_1;
  this.children = new ArrayList_0;
  this.focusedTextColor = ($clinit_TextColor() , WHITE_0);
  this.suckedFocusTextColor = WHITE_0;
  this.textColor = WHITE_0;
}

function distanceSquared(w1, w2){
  var dx, dy;
  dx = w1.x + w1.width_0 / 2 - (w2.x + w2.width_0 / 2);
  dy = w1.y + w1.height_0 / 2 - (w2.y + w2.height_0 / 2);
  return dx * dx + dy * dy;
}

defineSeed(294, 1, {});
_.getFocusedChild = function getFocusedChild(){
  return null;
}
;
_.getMinHeight = function getMinHeight(){
  return 0;
}
;
_.getMinWidth = function getMinWidth(){
  return 0;
}
;
_.isFocusWhore = function isFocusWhore(){
  return false;
}
;
_.isFocusable = function isFocusable(){
  return true;
}
;
_.isSuckingFocus = function isSuckingFocus(){
  return false;
}
;
_.onCancel = function onCancel(){
  $onCancel(this);
}
;
_.onDown = function onDown(){
  $onDown(this);
}
;
_.onLeft = function onLeft(){
  $onLeft(this);
}
;
_.onMouseClick = function onMouseClick(mouseX, mouseY){
  var child, child$iterator;
  for (child$iterator = new AbstractList$IteratorImpl_0(this.children); child$iterator.i < child$iterator.this$0_0.size_0();) {
    child = $next_2(child$iterator);
    mouseX >= child.x && mouseX <= child.x + child.width_0 && mouseY >= child.y && mouseY <= child.y + child.height_0 && child.onMouseClick(mouseX, mouseY);
  }
}
;
_.onMouseMove = function onMouseMove(mouseX, mouseY){
  var child, child$iterator;
  for (child$iterator = new AbstractList$IteratorImpl_0(this.children); child$iterator.i < child$iterator.this$0_0.size_0();) {
    child = $next_2(child$iterator);
    mouseX >= child.x && mouseX <= child.x + child.width_0 && mouseY >= child.y && mouseY <= child.y + child.height_0 && child.onMouseMove(mouseX, mouseY);
  }
}
;
_.onOK = function onOK(){
  $onOK(this);
}
;
_.onRight = function onRight(){
  $onRight(this);
}
;
_.onShow = function onShow(){
}
;
_.onUp = function onUp(){
  $onUp(this);
}
;
_.setHeight = function setHeight(height){
  this.height_0 = height;
}
;
_.setWidth = function setWidth(width){
  this.width_0 = width;
}
;
_.setX = function setX(x){
  this.x = x;
}
;
_.setY = function setY(y){
  this.y = y;
}
;
_.suckFocus_0 = function suckFocus(){
}
;
_.update = function update_3(delta){
  var child, child$iterator;
  this.background.update(delta);
  this.focusedBackground.update(delta);
  this.rightBorder.update(delta);
  this.topBorder.update(delta);
  this.bottomBorder.update(delta);
  for (child$iterator = new AbstractList$IteratorImpl_0(this.children); child$iterator.i < child$iterator.this$0_0.size_0();) {
    child = $next_2(child$iterator);
    child.update(delta);
  }
}
;
_.height_0 = 0;
_.parent_0 = null;
_.width_0 = 0;
_.x = 0;
_.y = 0;
function $isFocusSucked(this$static){
  var currentFocusedChild;
  currentFocusedChild = (!this$static.focusedChild && (this$static.focusedChild = $getTopLeftFocusableChild(this$static)) , this$static.focusedChild);
  return !currentFocusedChild || currentFocusedChild.isSuckingFocus();
}

defineSeed(293, 294, {});
_.accept_1 = function accept_3(visitor){
  visitor.visit_1(this);
}
;
_.getFocusedChild = function getFocusedChild_0(){
  return !this.focusedChild && (this.focusedChild = $getTopLeftFocusableChild(this)) , this.focusedChild;
}
;
_.onCancel = function onCancel_0(){
  $isFocusSucked(this) && $onCancel(this);
}
;
_.onDown = function onDown_0(){
  var closest, currentFocusedChild;
  if ($isFocusSucked(this)) {
    $onDown(this);
  }
   else {
    currentFocusedChild = (!this.focusedChild && (this.focusedChild = $getTopLeftFocusableChild(this)) , this.focusedChild);
    closest = $findClosestDownFocusableWidget(this, currentFocusedChild);
    !!closest && (this.focusedChild = closest);
  }
}
;
_.onLeft = function onLeft_0(){
  var closest, currentFocusedChild;
  if ($isFocusSucked(this)) {
    $onLeft(this);
  }
   else {
    currentFocusedChild = (!this.focusedChild && (this.focusedChild = $getTopLeftFocusableChild(this)) , this.focusedChild);
    closest = $findClosestLeftFocusableWidget(this, currentFocusedChild);
    !!closest && (this.focusedChild = closest);
  }
}
;
_.onMouseMove = function onMouseMove_0(mouseX, mouseY){
  var child, child$iterator;
  for (child$iterator = new AbstractList$IteratorImpl_0(this.children); child$iterator.i < child$iterator.this$0_0.size_0();) {
    child = $next_2(child$iterator);
    if (mouseX >= child.x && mouseX <= child.x + child.width_0 && mouseY >= child.y && mouseY <= child.y + child.height_0) {
      child.isFocusable() && !$isFocusSucked(this) && (this.focusedChild = child);
      child.onMouseMove(mouseX, mouseY);
    }
  }
}
;
_.onOK = function onOK_0(){
  var currentFocusedChild;
  currentFocusedChild = (!this.focusedChild && (this.focusedChild = $getTopLeftFocusableChild(this)) , this.focusedChild);
  if (currentFocusedChild) {
    if (currentFocusedChild.isFocusWhore() && !currentFocusedChild.isSuckingFocus()) {
      currentFocusedChild.suckFocus_0();
      return;
    }
  }
  $onOK(this);
}
;
_.onRight = function onRight_0(){
  var closest, currentFocusedChild;
  if ($isFocusSucked(this)) {
    $onRight(this);
  }
   else {
    currentFocusedChild = (!this.focusedChild && (this.focusedChild = $getTopLeftFocusableChild(this)) , this.focusedChild);
    closest = $findClosestRightFocusableWidget(this, currentFocusedChild);
    !!closest && (this.focusedChild = closest);
  }
}
;
_.onUp = function onUp_0(){
  var closest, currentFocusedChild;
  if ($isFocusSucked(this)) {
    $onUp(this);
  }
   else {
    currentFocusedChild = (!this.focusedChild && (this.focusedChild = $getTopLeftFocusableChild(this)) , this.focusedChild);
    closest = $findClosestUpFocusableWidget(this, currentFocusedChild);
    !!closest && (this.focusedChild = closest);
  }
}
;
_.focusedChild = null;
function $cell(this$static, widget){
  $add_5(this$static, widget);
  return $add_1(this$static.layout, widget);
}

function $layout_0(this$static){
  var c, cellWidget, cells, i, n;
  $layout(this$static.layout, this$static.x, this$static.y, this$static.width_0, this$static.height_0);
  cells = this$static.layout.cells;
  for (i = 0 , n = cells.size; i < n; ++i) {
    c = (checkIndex(i, cells.size) , cells.array[i]);
    if (!!c.ignore && c.ignore.value_0) {
      continue;
    }
    cellWidget = c.widget;
    cellWidget.setX(c.widgetX);
    cellWidget.setY(c.widgetY);
    cellWidget.setWidth(c.widgetWidth);
    cellWidget.setHeight(c.widgetHeight);
  }
}

function Table_1(){
  Widget_1.call(this);
  this.layout = new TableLayout_0;
  this.layout.table = this;
}

defineSeed(292, 293, {}, Table_1);
_.accept_1 = function accept_4(visitor){
  visitor.visit_7(this);
}
;
_.setHeight = function setHeight_0(height){
  this.height_0 = height;
  $layout_0(this);
}
;
_.setWidth = function setWidth_0(width){
  this.width_0 = width;
  $layout_0(this);
}
;
_.setX = function setX_0(x){
  this.x = x;
  $layout_0(this);
}
;
_.setY = function setY_0(y){
  this.y = y;
  $layout_0(this);
}
;
_.layout = null;
function $changeEffectsVolume(this$static, f){
  $setEffectsVolume(this$static.toolkit.audio, f);
}

function $changeMusicVolume(this$static, f){
  $setMusicVolume(this$static.toolkit.audio, f);
}

function AudioConfigurator_0(toolkit){
  var l_0, possibleVolumes;
  Table_1.call(this);
  this.toolkit = toolkit;
  possibleVolumes = new ArrayList_0;
  for (l_0 = 0; l_0 <= 100; l_0 += 10) {
    $add_0(possibleVolumes, new AudioConfigurator$Volume_0(l_0));
  }
  $expand(this.layout.cellDefaults);
  $cell(this, new Label_0(toolkit, 'nuit.audio.configurator.music.volume'));
  this.musicSelect = new AudioConfigurator$1_0(this, toolkit, possibleVolumes);
  $setSelected(this.musicSelect, new AudioConfigurator$Volume_0(Math.round(10) * 10));
  $cell(this, this.musicSelect);
  $row(this.layout);
  $cell(this, new Label_0(toolkit, 'nuit.audio.configurator.effects.volume'));
  this.effectsSelect = new AudioConfigurator$2_0(this, toolkit, possibleVolumes);
  $setSelected(this.effectsSelect, new AudioConfigurator$Volume_0(round(toolkit.audio.effectsVolume * 10) * 10));
  $cell(this, this.effectsSelect);
  $row(this.layout);
  $colspan($cell(this, new AudioConfigurator$3_0(this, toolkit)), valueOf_3(2));
}

defineSeed(291, 292, {}, AudioConfigurator_0);
_.accept_1 = function accept_5(visitor){
  visitor.visit(this);
}
;
_.effectsSelect = null;
_.musicSelect = null;
_.toolkit = null;
function $getSelected(this$static){
  return this$static.possibleValues.isEmpty()?null:this$static.possibleValues.get(this$static.selected);
}

function $setSelected(this$static, value){
  this$static.selected = this$static.possibleValues.indexOf_0(value);
  this$static.selected < 0 && (this$static.selected = 0);
}

function Select_1(toolkit, possibleValues){
  Widget_1.call(this);
  this.toolkit = toolkit;
  this.possibleValues = possibleValues;
}

defineSeed(296, 294, {}, Select_1);
_.accept_1 = function accept_6(visitor){
  visitor.visit_5(this);
}
;
_.getMinHeight = function getMinHeight_0(){
  var minHeight, value, value$iterator;
  minHeight = 0;
  for (value$iterator = this.possibleValues.iterator_0(); value$iterator.hasNext();) {
    value = value$iterator.next_0();
    minHeight = max_0($getHeight(this.toolkit.font_0, toString__devirtual$(value)), minHeight);
  }
  return minHeight;
}
;
_.getMinWidth = function getMinWidth_0(){
  var minWidth, value, value$iterator;
  minWidth = 0;
  for (value$iterator = this.possibleValues.iterator_0(); value$iterator.hasNext();) {
    value = value$iterator.next_0();
    minWidth = max_0($getWidth(this.toolkit.font_0, toString__devirtual$(value)), minWidth);
  }
  return minWidth;
}
;
_.isFocusWhore = function isFocusWhore_0(){
  return true;
}
;
_.isSuckingFocus = function isSuckingFocus_0(){
  return this.suckFocus;
}
;
_.onCancel = function onCancel_1(){
  this.selected = this.oldSelected;
  this.suckFocus = false;
}
;
_.onLeft = function onLeft_1(){
  --this.selected;
  this.selected < 0 && (this.selected = this.possibleValues.size_0() - 1);
}
;
_.onMouseClick = function onMouseClick_0(mouseX, mouseY){
  this.onRight();
}
;
_.onOK = function onOK_1(){
  this.suckFocus = false;
}
;
_.onRight = function onRight_1(){
  ++this.selected;
  this.selected >= this.possibleValues.size_0() && (this.selected = 0);
}
;
_.suckFocus_0 = function suckFocus_0(){
  this.suckFocus = true;
  this.oldSelected = this.selected;
}
;
_.oldSelected = 0;
_.possibleValues = null;
_.selected = 0;
_.suckFocus = false;
_.toolkit = null;
function AudioConfigurator$1_0(this$0, $anonymous0, $anonymous1){
  this.this$0 = this$0;
  Select_1.call(this, $anonymous0, $anonymous1);
}

defineSeed(295, 296, {}, AudioConfigurator$1_0);
_.onLeft = function onLeft_2(){
  --this.selected;
  this.selected < 0 && (this.selected = this.possibleValues.size_0() - 1);
  $changeMusicVolume(this.this$0, (this.possibleValues.isEmpty()?null:this.possibleValues.get(this.selected)).level / 100);
}
;
_.onRight = function onRight_2(){
  ++this.selected;
  this.selected >= this.possibleValues.size_0() && (this.selected = 0);
  $changeMusicVolume(this.this$0, (this.possibleValues.isEmpty()?null:this.possibleValues.get(this.selected)).level / 100);
}
;
_.this$0 = null;
function AudioConfigurator$2_0(this$0, $anonymous0, $anonymous1){
  this.this$0 = this$0;
  Select_1.call(this, $anonymous0, $anonymous1);
}

defineSeed(297, 296, {}, AudioConfigurator$2_0);
_.onLeft = function onLeft_3(){
  --this.selected;
  this.selected < 0 && (this.selected = this.possibleValues.size_0() - 1);
  $changeEffectsVolume(this.this$0, (this.possibleValues.isEmpty()?null:this.possibleValues.get(this.selected)).level / 100);
}
;
_.onRight = function onRight_3(){
  ++this.selected;
  this.selected >= this.possibleValues.size_0() && (this.selected = 0);
  $changeEffectsVolume(this.this$0, (this.possibleValues.isEmpty()?null:this.possibleValues.get(this.selected)).level / 100);
}
;
_.this$0 = null;
function Button_0(toolkit, text){
  Widget_1.call(this);
  this.toolkit = toolkit;
  this.text = text;
}

defineSeed(299, 294, {});
_.accept_1 = function accept_7(visitor){
  visitor.visit_0(this);
}
;
_.getMinHeight = function getMinHeight_1(){
  return $getHeight(this.toolkit.font_0, $getMessage(this.toolkit, this.text));
}
;
_.getMinWidth = function getMinWidth_1(){
  return $getWidth(this.toolkit.font_0, $getMessage(this.toolkit, this.text));
}
;
_.onMouseClick = function onMouseClick_1(mouseX, mouseY){
  this.onOK();
}
;
_.text = null;
_.toolkit = null;
function AudioConfigurator$3_0(this$0, $anonymous0){
  this.this$0 = this$0;
  Button_0.call(this, $anonymous0, 'nuit.audio.configurator.back');
}

defineSeed(298, 299, {}, AudioConfigurator$3_0);
_.onOK = function onOK_2(){
  $close(this.this$0);
}
;
_.this$0 = null;
function AudioConfigurator$Volume_0(level){
  this.level = level;
}

defineSeed(300, 1, {}, AudioConfigurator$Volume_0);
_.equals$ = function equals_9(obj){
  var other;
  if (obj == null) {
    return false;
  }
  if (Lim_bci_jnuit_widgets_AudioConfigurator$Volume_2_classLit != getClass__devirtual$(obj)) {
    return false;
  }
  other = obj;
  return this.level == other.level;
}
;
_.hashCode$ = function hashCode_11(){
  var hash;
  hash = 177 + this.level;
  return hash;
}
;
_.toString$ = function toString_16(){
  return this.level + '%';
}
;
_.level = 0;
function $initPossibleControls(this$static){
  var control, control$array, control$index, control$max;
  this$static.possibleControls = new ArrayList_0;
  for (control$array = $getPossibleControls(this$static.toolkit.controls) , control$index = 0 , control$max = control$array.length; control$index < control$max; ++control$index) {
    control = control$array[control$index];
    $add_0(this$static.possibleControls, new ControlActivatedDetector_0(control));
  }
}

function $initResets(this$static){
  var action, action$iterator;
  this$static.resets = new ArrayList_0;
  for (action$iterator = new AbstractList$IteratorImpl_0(this$static.actions); action$iterator.i < action$iterator.this$0_0.size_0();) {
    action = $next_2(action$iterator);
    $add_0(this$static.resets, new Action_0(action));
  }
}

function $initUI(this$static, toolkit){
  var action, action$iterator, actionNameLabel, alternativeConfigurator, border, mainConfigurator;
  $expand(this$static.layout.cellDefaults);
  this$static.actionLabel = new Label_0(toolkit, 'nuit.controls.configurator.action');
  border = new ColoredBorder_0;
  $setBottomBorder(this$static.actionLabel, border);
  $fill($cell(this$static, this$static.actionLabel));
  this$static.controlLabel = new Label_0(toolkit, 'nuit.controls.configurator.control');
  $setBottomBorder(this$static.controlLabel, border);
  $fill($cell(this$static, this$static.controlLabel));
  this$static.alternativeLabel = new Label_0(toolkit, 'nuit.controls.configurator.alternative');
  $setBottomBorder(this$static.alternativeLabel, border);
  $fill($cell(this$static, this$static.alternativeLabel));
  $row(this$static.layout);
  for (action$iterator = new AbstractList$IteratorImpl_0(this$static.actions); action$iterator.i < action$iterator.this$0_0.size_0();) {
    action = $next_2(action$iterator);
    actionNameLabel = new Label_0(toolkit, action.name_0);
    actionNameLabel.rightBorder = border;
    $fill(($add_5(this$static, actionNameLabel) , $add_1(this$static.layout, actionNameLabel)));
    $add_0(this$static.actionNameLabels, actionNameLabel);
    mainConfigurator = new ControlsConfigurator$1_0(this$static, action);
    $fill(($add_5(this$static, mainConfigurator) , $add_1(this$static.layout, mainConfigurator)));
    $add_0(this$static.mainActionControls, mainConfigurator);
    alternativeConfigurator = new ControlsConfigurator$2_0(this$static, action);
    $fill(($add_5(this$static, alternativeConfigurator) , $add_1(this$static.layout, alternativeConfigurator)));
    $row(this$static.layout);
    $add_0(this$static.alternativeActionControls, alternativeConfigurator);
  }
  this$static.backButton = new ControlsConfigurator$3_0(this$static, toolkit);
  $setTopBorder(this$static.backButton, border);
  $fill($cell(this$static, this$static.backButton));
  this$static.resetButton = new ControlsConfigurator$4_0(this$static, toolkit);
  $fill($cell(this$static, this$static.resetButton));
  $setTopBorder(this$static.resetButton, border);
  this$static.defaultButton = new ControlsConfigurator$5_0(this$static, toolkit);
  $fill($cell(this$static, this$static.defaultButton));
  $setTopBorder(this$static.defaultButton, border);
}

function $onBack(this$static){
  !!this$static.parent_0 && $remove_7(this$static.parent_0, this$static);
}

function $onDefaults(this$static){
  var i;
  if (this$static.defaults) {
    for (i = 0; i < this$static.defaults.array.length; ++i) {
      $setMainControl($get_7(this$static.actions, i), $get_7(this$static.defaults, i).controls[0]);
      $setAlternativeControl($get_7(this$static.actions, i), $get_7(this$static.defaults, i).controls[1]);
    }
  }
}

function $onReset(this$static){
  var i;
  for (i = 0; i < this$static.resets.size; ++i) {
    $setMainControl($get_7(this$static.actions, i), $get(this$static.resets, i).controls[0]);
    $setAlternativeControl($get_7(this$static.actions, i), $get(this$static.resets, i).controls[1]);
  }
}

function ControlsConfigurator_0(toolkit, actions, defaults){
  Table_1.call(this);
  this.toolkit = toolkit;
  this.actions = actions;
  this.defaults = defaults;
  this.actionNameLabels = new ArrayList_1(actions.array.length);
  this.mainActionControls = new ArrayList_1(actions.array.length);
  this.alternativeActionControls = new ArrayList_1(actions.array.length);
  $initResets(this);
  $initPossibleControls(this);
  $initUI(this, toolkit);
}

defineSeed(301, 292, {}, ControlsConfigurator_0);
_.accept_1 = function accept_8(visitor){
  visitor.visit_3(this);
}
;
_.onShow = function onShow_0(){
  $initResets(this);
}
;
_.actionLabel = null;
_.actionNameLabels = null;
_.actions = null;
_.alternativeActionControls = null;
_.alternativeLabel = null;
_.backButton = null;
_.controlLabel = null;
_.defaultButton = null;
_.defaults = null;
_.mainActionControls = null;
_.possibleControls = null;
_.resetButton = null;
_.resets = null;
_.toolkit = null;
function $isCancelControl(this$static, control){
  var c, c$array, c$index, c$max;
  for (c$array = this$static.this$0.toolkit.menuCancel.action.controls , c$index = 0 , c$max = c$array.length; c$index < c$max; ++c$index) {
    c = c$array[c$index];
    if (c.equals$(control.control)) {
      return true;
    }
  }
  return false;
}

function $suckFocus(this$static){
  var control, control$iterator;
  for (control$iterator = new AbstractList$IteratorImpl_0(this$static.this$0.possibleControls); control$iterator.i < control$iterator.this$0_0.size_0();) {
    control = $next_2(control$iterator);
    control.previousState = null;
  }
  this$static.suckFocus = true;
}

function ControlsConfigurator$ControlConfigurator_0(this$0){
  this.this$0 = this$0;
  Widget_1.call(this);
}

defineSeed(303, 294, {});
_.accept_1 = function accept_9(visitor){
  visitor.visit_2(this);
}
;
_.getMinHeight = function getMinHeight_2(){
  var font;
  font = this.this$0.toolkit.font_0;
  return max_1($getHeight(font, $getMessage(this.this$0.toolkit, 'nuit.controls.configurator.press.key')), $getHeight(font, this.getControl().getName()));
}
;
_.getMinWidth = function getMinWidth_2(){
  var font;
  font = this.this$0.toolkit.font_0;
  return max_1($getWidth(font, $getMessage(this.this$0.toolkit, 'nuit.controls.configurator.press.key')), $getWidth(font, this.getControl().getName()));
}
;
_.isFocusWhore = function isFocusWhore_1(){
  return true;
}
;
_.isSuckingFocus = function isSuckingFocus_1(){
  return this.suckFocus;
}
;
_.onMouseClick = function onMouseClick_2(mouseX, mouseY){
  $suckFocus(this);
}
;
_.suckFocus_0 = function suckFocus_1(){
  $suckFocus(this);
}
;
--></script>
<script><!--
_.update = function update_4(delta){
  var control, control$iterator, newState;
  if (this.suckFocus) {
    for (control$iterator = new AbstractList$IteratorImpl_0(this.this$0.possibleControls); control$iterator.i < control$iterator.this$0_0.size_0();) {
      control = $next_2(control$iterator);
      newState = control.control.getValue_0();
      control.activated = false;
      !!control.previousState && newState > control.control.getDeadZone() && control.previousState.value_0 <= control.control.getDeadZone() && (control.activated = true);
      control.previousState = new Float_0(newState);
      if (control.activated) {
        if (!this.controlToBeConfirmed) {
          if ($isCancelControl(this, control)) {
            this.controlToBeConfirmed = control.control;
            $resetInputPoll(this.this$0.toolkit);
            return;
          }
        }
        this.suckFocus = false;
        !this.controlToBeConfirmed || this.controlToBeConfirmed.equals$(control.control)?this.setControl(control.control):this.setControl(($clinit_NullControl() , INSTANCE_2));
        this.controlToBeConfirmed = null;
        $resetInputPoll(this.this$0.toolkit);
      }
    }
  }
}
;
_.controlToBeConfirmed = null;
_.suckFocus = false;
_.this$0 = null;
function ControlsConfigurator$1_0(this$0, val$action){
  this.val$action = val$action;
  ControlsConfigurator$ControlConfigurator_0.call(this, this$0);
}

defineSeed(302, 303, {}, ControlsConfigurator$1_0);
_.getControl = function getControl(){
  return this.val$action.controls[0];
}
;
_.setControl = function setControl(control){
  $setMainControl(this.val$action, control);
}
;
_.val$action = null;
function ControlsConfigurator$2_0(this$0, val$action){
  this.val$action = val$action;
  ControlsConfigurator$ControlConfigurator_0.call(this, this$0);
}

defineSeed(304, 303, {}, ControlsConfigurator$2_0);
_.getControl = function getControl_0(){
  return this.val$action.controls[1];
}
;
_.setControl = function setControl_0(control){
  $setAlternativeControl(this.val$action, control);
}
;
_.val$action = null;
function ControlsConfigurator$3_0(this$0, $anonymous0){
  this.this$0 = this$0;
  Button_0.call(this, $anonymous0, 'nuit.controls.configurator.back');
}

defineSeed(305, 299, {}, ControlsConfigurator$3_0);
_.onOK = function onOK_3(){
  $onBack(this.this$0);
}
;
_.this$0 = null;
function ControlsConfigurator$4_0(this$0, $anonymous0){
  this.this$0 = this$0;
  Button_0.call(this, $anonymous0, 'nuit.controls.configurator.resets');
}

defineSeed(306, 299, {}, ControlsConfigurator$4_0);
_.onOK = function onOK_4(){
  $onReset(this.this$0);
}
;
_.this$0 = null;
function ControlsConfigurator$5_0(this$0, $anonymous0){
  this.this$0 = this$0;
  Button_0.call(this, $anonymous0, 'nuit.controls.configurator.defaults');
}

defineSeed(307, 299, {}, ControlsConfigurator$5_0);
_.onOK = function onOK_5(){
  $onDefaults(this.this$0);
}
;
_.this$0 = null;
function Label_0(toolkit, text){
  Widget_1.call(this);
  this.toolkit = toolkit;
  this.text = text;
}

defineSeed(308, 294, {}, Label_0);
_.accept_1 = function accept_10(visitor){
  visitor.visit_4(this);
}
;
_.getMinHeight = function getMinHeight_3(){
  return $getHeight(this.toolkit.font_0, $getMessage(this.toolkit, this.text));
}
;
_.getMinWidth = function getMinWidth_3(){
  return $getWidth(this.toolkit.font_0, $getMessage(this.toolkit, this.text));
}
;
_.isFocusable = function isFocusable_0(){
  return false;
}
;
_.text = null;
_.toolkit = null;
function $getFocusedChild(this$static){
  var children, size;
  children = this$static.children;
  size = children.size;
  return size > 0?(checkIndex(size - 1, children.size) , children.array[size - 1]):null;
}

function $onMouseClick(this$static, mouseX, mouseY){
  var child;
  child = $getFocusedChild(this$static);
  !!child && child.onMouseClick(mouseX, mouseY);
}

function $onMouseMove_0(this$static, mouseX, mouseY){
  var child;
  child = $getFocusedChild(this$static);
  !!child && child.onMouseMove(mouseX, mouseY);
}

function $setHeight_0(this$static, height){
  var child, child$iterator;
  this$static.height_0 = height;
  for (child$iterator = new AbstractList$IteratorImpl_0(this$static.children); child$iterator.i < child$iterator.this$0_0.size_0();) {
    child = $next_2(child$iterator);
    child.setHeight(height);
  }
}

function $setWidth_0(this$static, width){
  var child, child$iterator;
  this$static.width_0 = width;
  for (child$iterator = new AbstractList$IteratorImpl_0(this$static.children); child$iterator.i < child$iterator.this$0_0.size_0();) {
    child = $next_2(child$iterator);
    child.setWidth(width);
  }
}

function $show(this$static, w){
  $add_5(this$static, w);
  w.setX(this$static.x);
  w.setY(this$static.y);
  w.setWidth(this$static.width_0);
  w.setHeight(this$static.height_0);
  w.onShow();
}

function Stack_0(){
  Widget_1.call(this);
}

defineSeed(310, 294, {});
_.accept_1 = function accept_11(visitor){
  visitor.visit_6(this);
}
;
_.getFocusedChild = function getFocusedChild_1(){
  return $getFocusedChild(this);
}
;
_.onMouseClick = function onMouseClick_3(mouseX, mouseY){
  $onMouseClick(this, mouseX, mouseY);
}
;
_.onMouseMove = function onMouseMove_1(mouseX, mouseY){
  $onMouseMove_0(this, mouseX, mouseY);
}
;
_.setHeight = function setHeight_1(height){
  $setHeight_0(this, height);
}
;
_.setWidth = function setWidth_1(width){
  $setWidth_0(this, width);
}
;
_.setX = function setX_1(x){
  var child, child$iterator;
  this.x = x;
  for (child$iterator = new AbstractList$IteratorImpl_0(this.children); child$iterator.i < child$iterator.this$0_0.size_0();) {
    child = $next_2(child$iterator);
    child.setX(x);
  }
}
;
_.setY = function setY_1(y){
  var child, child$iterator;
  this.y = y;
  for (child$iterator = new AbstractList$IteratorImpl_0(this.children); child$iterator.i < child$iterator.this$0_0.size_0();) {
    child = $next_2(child$iterator);
    child.setY(y);
  }
}
;
function $update_0(this$static, delta){
  var child, child$iterator;
  $update(this$static.toolkit, this$static);
  for (child$iterator = new AbstractList$IteratorImpl_0(this$static.children); child$iterator.i < child$iterator.this$0_0.size_0();) {
    child = $next_2(child$iterator);
    child.update(delta);
  }
}

function Root_0(tk){
  Stack_0.call(this);
  this.toolkit = tk;
  $setWidth_0(this, 1920);
  $setHeight_0(this, 1080);
}

defineSeed(309, 310, {}, Root_0);
_.accept_1 = function accept_12(visitor){
  visitor.visit_6(this);
}
;
_.update = function update_5(delta){
  $update_0(this, delta);
}
;
_.toolkit = null;
function TableLayout_0(){
  this.cells = new ArrayList_1(4);
  this.columnDefaults = new ArrayList_1(2);
  this.cellDefaults = new Cell_0;
  $defaults(this.cellDefaults);
}

defineSeed(311, 36, {}, TableLayout_0);
function $setEnabled(this$static, enabled){
  this$static.enabled = enabled;
}

function Toggle_0(toolkit){
  Widget_1.call(this);
  this.toolkit = toolkit;
}

defineSeed(312, 294, {}, Toggle_0);
_.accept_1 = function accept_13(visitor){
  visitor.visit_8(this);
}
;
_.getMinHeight = function getMinHeight_4(){
  return max_1($getHeight(this.toolkit.font_0, $getMessage(this.toolkit, 'nuit.toggle.yes')), $getHeight(this.toolkit.font_0, $getMessage(this.toolkit, 'nuit.toggle.no')));
}
;
_.getMinWidth = function getMinWidth_4(){
  return max_1($getWidth(this.toolkit.font_0, $getMessage(this.toolkit, 'nuit.toggle.yes')), $getWidth(this.toolkit.font_0, $getMessage(this.toolkit, 'nuit.toggle.no')));
}
;
_.onMouseClick = function onMouseClick_4(mouseX, mouseY){
  this.enabled = !this.enabled;
}
;
_.onOK = function onOK_6(){
  this.enabled = !this.enabled;
}
;
_.enabled = false;
_.toolkit = null;
function VideoConfigurator_0(toolkit){
  Table_1.call(this);
  $expand(this.layout.cellDefaults);
  $cell(this, new Label_0(toolkit, 'nuit.video.configurator.mode'));
  this.mode = new Select_1(toolkit, new Arrays$ArrayList_0(initValues(_3Lim_bci_jnuit_display_VideoResolution_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$VideoResolution, [new VideoResolution_0(platform_1.graphics.width_2(), platform_1.graphics.height_2())])));
  $cell(this, this.mode);
  $row(this.layout);
  $cell(this, new Label_0(toolkit, 'nuit.video.configurator.fullscreen'));
  this.fullscreen = new Toggle_0(toolkit);
  $cell(this, this.fullscreen);
  $row(this.layout);
  $colspan($cell(this, new VideoConfigurator$1_0(this, toolkit)), valueOf_3(2));
  $row(this.layout);
  $colspan($cell(this, new VideoConfigurator$2_0(this, toolkit)), valueOf_3(2));
}

defineSeed(313, 292, {}, VideoConfigurator_0);
_.accept_1 = function accept_14(visitor){
  visitor.visit_9(this);
}
;
_.onShow = function onShow_1(){
  $setSelected(this.mode, new VideoResolution_0(platform_1.graphics.width_2(), platform_1.graphics.height_2()));
  this.fullscreen.enabled = false;
}
;
_.fullscreen = null;
_.mode = null;
function VideoConfigurator$1_0(this$0, $anonymous0){
  this.this$0 = this$0;
  Button_0.call(this, $anonymous0, 'nuit.video.configurator.apply');
}

defineSeed(314, 299, {}, VideoConfigurator$1_0);
_.onOK = function onOK_7(){
  $getSelected(this.this$0.mode);
  $close(this.this$0);
}
;
_.this$0 = null;
function VideoConfigurator$2_0(this$0, $anonymous0){
  this.this$0 = this$0;
  Button_0.call(this, $anonymous0, 'nuit.video.configurator.back');
}

defineSeed(315, 299, {}, VideoConfigurator$2_0);
_.onOK = function onOK_8(){
  $close(this.this$0);
}
;
_.this$0 = null;
function $compare(w1, w2){
  var result;
  return result = compare_3(w1.y + w1.height_0 / 2, w2.y + w2.height_0 / 2) , result == 0 && (result = compare_3(w1.x + w1.width_0 / 2, w2.x + w2.width_0 / 2)) , result;
}

function Widget$1_0(){
}

defineSeed(316, 1, {}, Widget$1_0);
_.compare = function compare(w1, w2){
  return $compare(w1, w2);
}
;
function $cheatSetAllCompleted(this$static){
  var l_0, l$iterator, q, q$iterator;
  for (q$iterator = new AbstractList$IteratorImpl_0(this$static.data.questsConfig.visibleQuests); q$iterator.i < q$iterator.this$0_0.size_0();) {
    q = $next_2(q$iterator);
    for (l$iterator = new AbstractList$IteratorImpl_0($listQuestLevels(this$static.data, q)); l$iterator.i < l$iterator.this$0_0.size_0();) {
      l_0 = $next_2(l$iterator);
      $getLevel($getQuest(this$static.progression, q), l_0).completed = true;
    }
  }
}

function $getButtonFile(this$static, baseName){
  var localizedButton;
  localizedButton = baseName + '_en_US.png';
  return $fileExists(this$static.data, localizedButton)?localizedButton:baseName + '.png';
}

function $goToNextBonusLevel(this$static, currentQuestName){
  var i;
  if (this$static.bonusSequences.size != 0) {
    i = $indexOf_0(this$static.bonusSequences, this$static.lastBonusSequence, 0) + 1;
    (i < 0 || i >= this$static.bonusSequences.size) && (i = 0);
    this$static.lastBonusSequence = $get(this$static.bonusSequences, i);
    $setCurrentQuestName(this$static.lastBonusSequence, currentQuestName);
    $setNextSequence(this$static.lastBonusSequence, this$static.currentSequence);
    throw new Sequence$ResumableTransitionException_0(new PreloaderFadeSequence_0(this$static, this$static.lastBonusSequence));
  }
}

function $goToRandomBonusLevel(this$static, currentQuestName){
  var bonusSequence;
  if (this$static.bonusSequences.size != 0) {
    bonusSequence = $get(this$static.bonusSequences, $nextInt(this$static.frameTimeInfos.random_0, this$static.bonusSequences.size));
    bonusSequence.currentQuestName = currentQuestName;
    $setNextSequence(bonusSequence, this$static.currentSequence);
    throw new Sequence$ResumableTransitionException_0(new PreloaderFadeSequence_0(this$static, bonusSequence));
  }
}

function $gotoQuestMenu(this$static){
  throw new Sequence$NormalTransitionException_0(this$static.questMenuSequence);
}

function $isLevelBlocked(this$static, questName, levelName){
  var l_0, l$iterator, previousLevelName;
  previousLevelName = null;
  for (l$iterator = new AbstractList$IteratorImpl_0($listQuestLevels(this$static.data, questName)); l$iterator.i < l$iterator.this$0_0.size_0();) {
    l_0 = $next_2(l$iterator);
    if ($equals_0(l_0, levelName)) {
      return null != previousLevelName && !$getLevel($getQuest(this$static.progression, questName), previousLevelName).completed;
    }
    previousLevelName = l_0;
  }
  return false;
}

function $isQuestBlocked(this$static, questName){
  var questToComplete, questToComplete$iterator;
  for (questToComplete$iterator = new AbstractList$IteratorImpl_0($listQuestsToCompleteToUnlockQuest(this$static.data, questName)); questToComplete$iterator.i < questToComplete$iterator.this$0_0.size_0();) {
    questToComplete = $next_2(questToComplete$iterator);
    if (!$isQuestCompleted(this$static, questToComplete)) {
      return true;
    }
  }
  return false;
}

function $isQuestCompleted(this$static, questName){
  var levelName, levelName$iterator;
  for (levelName$iterator = new AbstractList$IteratorImpl_0($listQuestLevels(this$static.data, questName)); levelName$iterator.i < levelName$iterator.this$0_0.size_0();) {
    levelName = $next_2(levelName$iterator);
    if ($isLevelBlocked(this$static, questName, levelName)) {
      return false;
    }
  }
  return true;
}

function $loadBonusSequences(this$static){
  var levelName, levelName$iterator, levelNames, levelSequence;
  this$static.bonusSequences = new ArrayList_0;
  levelNames = this$static.data.questsConfig.quests.get_1('bonus').levels;
  for (levelName$iterator = new AbstractList$IteratorImpl_0(levelNames); levelName$iterator.i < levelName$iterator.this$0_0.size_0();) {
    levelName = $next_2(levelName$iterator);
    levelSequence = new BonusSequence_0(this$static, levelName);
    $add_0(this$static.bonusSequences, levelSequence);
  }
}

function $setLevelCompleted(this$static, questName, completedLevelName){
  $getLevel($getQuest(this$static.progression, questName), completedLevelName).completed = true;
}

function $showHelp(this$static){
  throw new Sequence$ResumableTransitionException_0(new StoryboardSequence_0(this$static, 'help.png', null, new Sequence$ResumeTransitionException_0(this$static.currentSequence)));
}

function $start(this$static){
  var outroSequence, introSequence;
  this$static.currentSequence = (outroSequence = new StoryboardSequence_0(this$static, 'outro.png', 'The_End.ogg', new Sequence$NormalTransitionException_0(null)) , this$static.questMenuSequence = new QuestMenuSequence_0(this$static) , this$static.mainMenuSequence = new MainMenuSequence_0(this$static, this$static.questMenuSequence, outroSequence, this$static.optionsSequence) , $setNextSequence_0(this$static.questMenuSequence, this$static.mainMenuSequence) , !!this$static.optionsSequence && $setNextSequence_2(this$static.optionsSequence, this$static.mainMenuSequence) , $loadBonusSequences(this$static) , introSequence = new StoryboardSequence_1(this$static, 'intro/devnewton.json', 'intro/devnewton.ogg', new Sequence$NormalTransitionException_0(new FadeSequence_0(this$static, new Sequence$NormalTransitionException_0(this$static.mainMenuSequence))), false) , introSequence.backgroundPlayMode = 0 , introSequence.musicLoop = false , introSequence.backgroundX1 = 384 , introSequence.backgroundX2 = 896 , introSequence.backgroundY1 = 458 , introSequence.backgroundY2 = 342 , introSequence);
  this$static.currentSequence.start_2();
}

function $tick(this$static){
  var $e0, e, ex;
  try {
    if (this$static.bShowMainMenu) {
      this$static.bShowMainMenu = false;
      if (this$static.currentSequence != this$static.mainMenuSequence) {
        $setResumeSequence(this$static.mainMenuSequence, this$static.currentSequence);
        this$static.currentSequence = this$static.mainMenuSequence;
        $start_5(this$static.mainMenuSequence);
      }
    }
    $update_5(this$static.frameTimeInfos, mul(fromInt($tick_1(platform_1)), Pf4240_longLit));
    this$static.currentSequence.draw();
    $poll_0(this$static.input);
    this$static.currentSequence != this$static.optionsSequence && this$static.input.returnToMenu.activated && (this$static.bShowMainMenu = true);
    this$static.currentSequence.processInputs();
    this$static.currentSequence.update_0();
  }
   catch ($e0) {
    $e0 = caught_0($e0);
    if (instanceOf($e0, Q$Sequence$NormalTransitionException)) {
      ex = $e0;
      this$static.currentSequence.stop_0();
      this$static.currentSequence = ex.nextSequence;
      if (!this$static.currentSequence) {
        this$static.running = false;
        $stopMusic(this$static.platform.toolkit.audio);
      }
       else {
        this$static.currentSequence.start_2();
      }
    }
     else if (instanceOf($e0, Q$Sequence$ResumeTransitionException)) {
      ex = $e0;
      this$static.currentSequence.stop_0();
      this$static.currentSequence = ex.nextSequence;
      this$static.currentSequence.resume();
    }
     else if (instanceOf($e0, Q$Sequence$ResumableTransitionException)) {
      e = $e0;
      this$static.currentSequence = e.nextSequence;
      this$static.currentSequence.start_2();
    }
     else 
      throw $e0;
  }
}

function Game_0(platform){
  this.frameTimeInfos = new FrameTimeInfos_0;
  this.data = platform.data;
  this.score = new GameScore_0;
  this.progression = new GameProgression_0;
  this.view = platform.gameView;
  this.input = platform.input;
  this.optionsSequence = new OptionsSequence_0(platform);
  this.platform = platform;
}

defineSeed(317, 1, {}, Game_0);
_.bShowMainMenu = false;
_.bonusSequences = null;
_.currentSequence = null;
_.data = null;
_.input = null;
_.lastBonusSequence = null;
_.mainMenuSequence = null;
_.optionsSequence = null;
_.platform = null;
_.progression = null;
_.questMenuSequence = null;
_.running = true;
_.score = null;
_.view = null;
function $getQuest(this$static, questName){
  var quest;
  quest = this$static.quests.get_1(questName);
  if (!quest) {
    quest = new QuestProgression_0;
    this$static.quests.put(questName, quest);
  }
  return quest;
}

function GameProgression_0(){
  this.quests = new HashMap_0;
}

defineSeed(318, 1, makeCastMap([Q$Serializable]), GameProgression_0);
function LevelProgression_0(){
}

defineSeed(319, 1, makeCastMap([Q$Serializable]), LevelProgression_0);
_.completed = false;
function $getLevel(this$static, levelName){
  var level;
  level = this$static.levels.get_1(levelName);
  if (!level) {
    level = new LevelProgression_0;
    this$static.levels.put(levelName, level);
  }
  return level;
}

function QuestProgression_0(){
  this.levels = new HashMap_0;
}

defineSeed(320, 1, makeCastMap([Q$Serializable]), QuestProgression_0);
function $addFrame(this$static, image, duration, u1, v1, u2, v2){
  var frame;
  this$static.totalDuration = add_4(this$static.totalDuration, duration);
  frame = new AnimationFrame_0(image, this$static.totalDuration, u1, v1, u2, v2);
  $add_0(this$static.frames_0, frame);
  return frame;
}

function $start_0(this$static, mode){
  var play;
  if (this$static.frames_0.size == 0) {
    return null;
  }
   else {
    play = new Play_0(this$static);
    $start_2(play, mode);
    return play;
  }
}

function Animation_0(name_0){
  this.frames_0 = new ArrayList_0;
  this.name_0 = name_0;
}

defineSeed(321, 1, {}, Animation_0);
_.getFrame = function getFrame(i){
  return $get(this.frames_0, i);
}
;
_.getFrameCount = function getFrameCount(){
  return this.frames_0.size;
}
;
_.getName = function getName_2(){
  return this.name_0;
}
;
_.getTotalDuration = function getTotalDuration(){
  return this.totalDuration;
}
;
_.start_0 = function start_0(){
  return $start_0(this, 1);
}
;
_.start_1 = function start_1(mode){
  return $start_0(this, mode);
}
;
_.name_0 = null;
_.totalDuration = P0_longLit;
function $addAnimation(this$static, animation){
  $put_5(this$static.animations, animation.name_0, animation);
}

function $getAnimationByName(this$static, name_0){
  return this$static.animations.map.size_0() == 0?new AnimationCollection$NotReadyAnimationWithName_0(this$static, name_0):$get_9(this$static.animations, name_0);
}

function $getFirst(this$static){
  return this$static.animations.map.size_0() == 0?new AnimationCollection$NotReadyFirstAnimation_0(this$static):$iterator_0($values(this$static.animations)).val$outerIter.next_0().getValue();
}

function AnimationCollection_0(){
  this.animations = new LinkedHashMap_0;
  this.ready_0 = false;
}

function AnimationCollection_1(texture){
  var animation;
  this.animations = new LinkedHashMap_1;
  animation = new Animation_0('' + texture);
  $addFrame(animation, texture, P7fffffff_longLit, 0, 0, 1, 1);
  $put_5(this.animations, animation.name_0, animation);
  this.ready_0 = true;
}

function AnimationCollection_2(texture, u1, v1, u2, v2){
  var animation;
  this.animations = new LinkedHashMap_1;
  animation = new Animation_0('' + texture);
  $addFrame(animation, texture, P7fffffff_longLit, u1, v1, u2, v2);
  $put_5(this.animations, animation.name_0, animation);
  this.ready_0 = true;
}

defineSeed(322, 1, {}, AnimationCollection_0, AnimationCollection_1, AnimationCollection_2);
_.animations = null;
_.ready_0 = false;
function $start_1(this$static, mode){
  var play;
  play = new Play_0(this$static);
  $start_2(play, mode);
  return play;
}

defineSeed(323, 1, {});
_.getFrame = function getFrame_0(i){
  var a;
  a = this.getWhenReady();
  return a?$get(a.frames_0, i):null;
}
;
_.getFrameCount = function getFrameCount_0(){
  var a;
  a = this.getWhenReady();
  return a?a.frames_0.size:0;
}
;
_.getTotalDuration = function getTotalDuration_0(){
  var a;
  a = this.getWhenReady();
  return a?a.totalDuration:P0_longLit;
}
;
_.start_0 = function start_2(){
  return $start_1(this, 1);
}
;
_.start_1 = function start_3(mode){
  return $start_1(this, mode);
}
;
function AnimationCollection$NotReadyAnimationWithName_0(this$0, name_0){
  this.this$0 = this$0;
  this.name_0 = name_0;
}

defineSeed(324, 323, {}, AnimationCollection$NotReadyAnimationWithName_0);
_.getName = function getName_3(){
  return this.name_0;
}
;
_.getWhenReady = function getWhenReady(){
  return this.this$0.ready_0?$get_9(this.this$0.animations, this.name_0):null;
}
;
_.name_0 = null;
_.this$0 = null;
function AnimationCollection$NotReadyFirstAnimation_0(this$0){
  this.this$0 = this$0;
}

defineSeed(325, 323, {}, AnimationCollection$NotReadyFirstAnimation_0);
_.getName = function getName_4(){
  var a;
  a = this.this$0.ready_0?$iterator_0($values(this.this$0.animations)).val$outerIter.next_0().getValue():null;
  return a?a.name_0:'';
}
;
_.getWhenReady = function getWhenReady_0(){
  return this.this$0.ready_0?$iterator_0($values(this.this$0.animations)).val$outerIter.next_0().getValue():null;
}
;
_.this$0 = null;
function AnimationFrame_0(image, endTime, u1, v1, u2, v2){
  this.image = image;
  this.endTime = endTime;
  this.u1 = u1;
  this.v1 = v1;
  this.u2 = u2;
  this.v2 = v2;
}

defineSeed(326, 1, {}, AnimationFrame_0);
_.endTime = P0_longLit;
_.image = null;
_.u1 = 0;
_.u2 = 0;
_.v1 = 0;
_.v2 = 0;
function $getCurrentFrame(this$static){
  return this$static.animation.getFrame(this$static.currentFrameIndex);
}

function $start_2(this$static, mode){
  this$static.state = 0;
  this$static.mode = mode;
  this$static.currentTime_0 = P0_longLit;
  this$static.currentFrameIndex = 0;
}

function $stop_0(this$static){
  this$static.state = 1;
  this$static.currentTime_0 = P0_longLit;
  this$static.currentFrameIndex = 0;
}

function $update_1(this$static, elapsedTime){
  var totalDuration;
  if (this$static.state == 1) {
    return;
  }
  if (this$static.animation.getFrameCount() > 0) {
    this$static.currentTime_0 = add_4(this$static.currentTime_0, elapsedTime);
    totalDuration = this$static.animation.getTotalDuration();
    if (gte_0(this$static.currentTime_0, totalDuration)) {
      switch (this$static.mode) {
        case 0:
          this$static.currentFrameIndex = this$static.animation.getFrameCount() - 1;
          this$static.state = 1;
          return;
        case 1:
          gt(totalDuration, P0_longLit)?(this$static.currentTime_0 = mod(this$static.currentTime_0, totalDuration)):(this$static.currentTime_0 = P0_longLit);
          this$static.currentFrameIndex = 0;
      }
    }
    while (gt(this$static.currentTime_0, this$static.animation.getFrame(this$static.currentFrameIndex).endTime)) {
      ++this$static.currentFrameIndex;
    }
  }
}

function Play_0(animation){
  this.animation = animation;
}

defineSeed(327, 1, {}, Play_0);
_.animation = null;
_.currentFrameIndex = 0;
_.currentTime_0 = P0_longLit;
_.mode = 1;
_.state = 1;
function $addExcludedBody(this$static, other){
  if ($equals(other, this$static)) {
    return;
  }
  if (!$contains_5(this$static.excluded, other)) {
    $add_16(this$static.excluded, other);
    $addExcludedBody(other, this$static);
  }
}

function $addForce(this$static, f){
  $add_14(this$static.force_0, f);
}

function $adjustAngularVelocity(this$static, delta){
  if (!this$static.isRotatable()) {
    return;
  }
  this$static.angularVelocity += delta;
}

function $adjustBiasedAngularVelocity(this$static, delta){
  if (!this$static.isRotatable()) {
    return;
  }
  this$static.biasedAngularVelocity += delta;
}

function $adjustBiasedVelocity(this$static, delta){
  if (!this$static.isMoveable()) {
    return;
  }
  $add_14(this$static.biasedVelocity, delta);
}

function $adjustPosition(this$static, delta){
  $set_5(this$static.lastPosition, this$static.position_0);
  this$static.position_0.x += delta.x * 0.01666666753590107;
  this$static.position_0.y += delta.y * 0.01666666753590107;
}

function $adjustRotation(this$static, delta){
  this$static.rotation += delta;
}

function $adjustVelocity(this$static, delta){
  if (!this$static.isMoveable()) {
    return;
  }
  $set_5(this$static.lastVelocity, this$static.velocity);
  $add_14(this$static.velocity, delta);
}

function $configureRestingBodyDetection(this$static, hitTolerance){
  this$static.hitTolerance = hitTolerance;
  this$static.restingBodyDetection = true;
}

function $equals(this$static, other){
  if (getClass__devirtual$(other) == this$static.___clazz$) {
    return other.id_0 == this$static.id_0;
  }
  return false;
}

function $removeExcludedBody(this$static, other){
  if ($equals(other, this$static)) {
    return;
  }
  if ($contains_5(this$static.excluded, other)) {
    $remove_18(this$static.excluded, other);
    $removeExcludedBody(other, this$static);
  }
}

function $setFriction(this$static, friction){
  this$static.surfaceFriction = friction;
}

function $setMass(this$static, m_0){
  this$static.mass = m_0;
  if (this$static.mass < 3.4028234663852886E38) {
    this$static.invMass = 1 / this$static.mass;
    this$static.I = this$static.mass * this$static.shape.getSurfaceFactor() / 12;
    this$static.invI = 1 / this$static.I;
  }
   else {
    this$static.invMass = 0;
    this$static.I = 3.4028234663852886E38;
    this$static.invI = 0;
  }
}

function $setPosition(this$static, x, y){
  $set_4(this$static.position_0, x, y);
  $set_4(this$static.lastPosition, x, y);
}

function $setShape(this$static, shape){
  this$static.shape = shape;
}

function Body_0(shape, m_0){
  this.position_0 = new Vector2f_0;
  this.lastPosition = new Vector2f_0;
  this.velocity = new Vector2f_0;
  this.lastVelocity = new Vector2f_0;
  this.biasedVelocity = new Vector2f_0;
  this.force_0 = new Vector2f_0;
  this.excluded = new BodyList_0;
  this.touching = new BodyList_0;
  this.name_0 = 'UnnamedBody';
  this.id_0 = NEXT_ID++;
  $set_4(this.position_0, 0, 0);
  $set_4(this.lastPosition, 0, 0);
  this.rotation = 0;
  $set_4(this.velocity, 0, 0);
  this.angularVelocity = 0;
  $set_4(this.force_0, 0, 0);
  this.torque = 0;
  this.surfaceFriction = 0.20000000298023224;
  this.mass = 3.4028234663852886E38;
  this.invMass = 0;
  this.I = 3.4028234663852886E38;
  this.invI = 0;
  this.originalMass = m_0;
  $set_4(this.position_0, 0, 0);
  $set_4(this.lastPosition, 0, 0);
  this.rotation = 0;
  $set_4(this.velocity, 0, 0);
  this.angularVelocity = 0;
  $set_4(this.force_0, 0, 0);
  this.torque = 0;
  this.surfaceFriction = 0.20000000298023224;
  this.shape = shape;
  $setMass(this, m_0);
}

defineSeed(329, 1, {});
_.collided = function collided(other){
  if (!this.restingBodyDetection) {
    return;
  }
  $contains_5(this.touching, other) || $add_16(this.touching, other);
  this.isResting_0() && (other.isResting_0() || $lengthSquared(other.velocity) > this.hitTolerance && $setMass(this, this.originalMass));
  ++this.hitCount;
}
;
_.equals$ = function equals_10(other){
  return $equals(this, other);
}
;
_.hashCode$ = function hashCode_12(){
  return this.id_0;
}
;
_.isMoveable = function isMoveable(){
  if (!this.enabled) {
    return false;
  }
  return this.moveable;
}
;
_.isResting_0 = function isResting(){
  return this.isResting;
}
;
_.isRotatable = function isRotatable(){
  if (!this.enabled) {
    return false;
  }
  return this.rotatable;
}
;
_.isStatic = function isStatic(){
  return false;
}
;
_.toString$ = function toString_17(){
  return "[Body '" + this.name_0 + "' id: " + this.id_0 + ' pos: ' + this.position_0 + ' vel: ' + this.velocity + ' (' + this.angularVelocity + ')]';
}
;
_.I = 0;
_.added = false;
_.angularVelocity = 0;
_.biasedAngularVelocity = 0;
_.bitmask = P0_longLit;
_.damping = 0;
_.enabled = true;
_.gravity = true;
_.hitCount = 0;
_.hitTolerance = 0;
_.id_0 = 0;
_.invI = 0;
_.invMass = 0;
_.isResting = false;
_.mass = 0;
_.moveable = true;
_.name_0 = null;
_.originalMass = 0;
_.restingBodyDetection = false;
_.rotDamping = 0;
_.rotatable = true;
_.rotation = 0;
_.shape = null;
_.surfaceFriction = 0;
_.torque = 0;
var NEXT_ID = 0;
function $setZOrder(this$static, z){
  this$static.zorder = z;
}

function AbstractDrawableBody_0(shape, m_0){
  Body_0.call(this, shape, m_0);
}

defineSeed(328, 329, makeCastMap([Q$Drawable]));
_.getZOrder = function getZOrder(){
  return this.zorder;
}
;
_.zorder = 0;
function StaticBody_0(shape){
  Body_0.call(this, shape, 3.4028234663852886E38);
}

--></script>
<script><!--
defineSeed(331, 329, makeCastMap([Q$StaticBody]));
_.isMoveable = function isMoveable_0(){
  return false;
}
;
_.isResting_0 = function isResting_0(){
  return true;
}
;
_.isRotatable = function isRotatable_0(){
  return false;
}
;
_.isStatic = function isStatic_0(){
  return true;
}
;
function $setZOrder_0(this$static, z){
  this$static.zorder = z;
}

function AbstractDrawableStaticBody_0(shape){
  StaticBody_0.call(this, shape);
}

defineSeed(330, 331, makeCastMap([Q$Drawable, Q$StaticBody]));
_.getZOrder = function getZOrder_0(){
  return this.zorder;
}
;
_.zorder = 0;
defineSeed(332, 1, {});
_.getZOrder = function getZOrder_1(){
  return this.zorder;
}
;
_.zorder = 0;
function $processMovingInput(this$static){
  var heroIsMoving;
  heroIsMoving = false;
  if ($isPressed(this$static.game.input.left_0)) {
    $moveLeft(this$static.world.hero);
    heroIsMoving = true;
  }
  if ($isPressed(this$static.game.input.right)) {
    $moveRight(this$static.world.hero);
    heroIsMoving = true;
  }
  if ($isPressed(this$static.game.input.jump)) {
    $jump(this$static.world.hero);
    heroIsMoving = true;
  }
  heroIsMoving || $setCurrentMovement(this$static.world.hero, 2);
}

function $setNextSequence(this$static, nextSequence){
  this$static.nextSequence = nextSequence;
}

function $start_3(this$static){
  this$static.cheatCodeGotoNextLevel = false;
  this$static.cheatCodeGotoNextBonusLevel = false;
  this$static.frameTimeInfos = this$static.game.frameTimeInfos;
}

function $update_2(this$static){
  var $e0, i;
  try {
    if (this$static.world.hero.dyingTimedAction) {
      $update_8(this$static.world.hero, this$static.frameTimeInfos);
      return;
    }
    this$static.stepTime = add_4(this$static.stepTime, this$static.frameTimeInfos.elapsedTime);
    if (gte_0(this$static.stepTime, Pfe502a_longLit)) {
      this$static.stepTime = sub(this$static.stepTime, Pfe502a_longLit);
      for (i = 0; i < 5; ++i) {
        $step_1(this$static.world);
      }
    }
    $update_10(this$static.world);
    if (this$static.world.objectivesCompleted || this$static.cheatCodeGotoNextLevel) {
      $setLevelScore(this$static.game.score, this$static.questName, this$static.levelName, this$static.world.hero.levelScore);
      $setLevelCompleted(this$static.game, this$static.questName, this$static.levelName);
      if (instanceOf(this$static.nextSequence, Q$PreloadableSequence)) {
        throw new Sequence$NormalTransitionException_0(new PreloaderFadeSequence_0(this$static.game, this$static.nextSequence));
      }
       else {
        throw new Sequence$NormalTransitionException_0(new FadeSequence_0(this$static.game, new Sequence$NormalTransitionException_0(this$static.nextSequence)));
      }
    }
    this$static.cheatCodeGotoNextBonusLevel && $goToNextBonusLevel(this$static.game, this$static.questName);
  }
   catch ($e0) {
    $e0 = caught_0($e0);
    if (instanceOf($e0, Q$GameOverException)) {
      throw new Sequence$NormalTransitionException_0(new GameOverSequence_0(this$static.game, this$static));
    }
     else 
      throw $e0;
  }
}

function LevelSequence_0(game, questName, levelName){
  this.game = game;
  this.questName = questName;
  this.levelName = levelName;
}

defineSeed(334, 1, makeCastMap([Q$LevelSequence, Q$PreloadableSequence]), LevelSequence_0);
_.draw = function draw(){
  $draw_1(this.world);
  $drawFPS(this.game.view, this.game.frameTimeInfos.fps);
  this.drawIndicators();
  !!this.minimapTexture && $drawMinimap(this.game.view, this.world, this.minimapTexture);
}
;
_.drawIndicators = function drawIndicators(){
  var b, deadClock, hero, remainingSeconds, seconds;
  b = new StringBuilder_0;
  hero = this.world.hero;
  $append_9(b, hero.nbApple);
  b.impl.string += '$ ';
  deadClock = hero.deadClock;
  if (deadClock) {
    seconds = div(gte_0(deadClock.time, deadClock.duration_0)?P0_longLit:sub(deadClock.duration_0, deadClock.time), P3b9aca00_longLit);
    $appendNonNull(b.impl, '' + toString_12(div(seconds, P3c_longLit)));
    b.impl.string += ':';
    remainingSeconds = mod(seconds, P3c_longLit);
    lt(remainingSeconds, Pa_longLit) && (b.impl.string += '0' , b);
    $appendNonNull(b.impl, '' + toString_12(remainingSeconds));
  }
}
;
_.finishPreload = function finishPreload(){
  var minimapPath;
  $finishLoading(this.worldLoader);
  this.worldLoader = null;
  minimapPath = $getLevelFilePath(this.game.data, this.questName, this.levelName, 'minimap.png');
  $fileExists(this.game.data, minimapPath)?(this.minimapTexture = $getTexture(this.game.view.textureCache, minimapPath)):(this.minimapTexture = null);
}
;
_.preloadSomeAndCheckIfTerminated = function preloadSomeAndCheckIfTerminated(){
  var $e0, currentLoadingTime, elapsedLoadingDuration, ex, startLoadingTime;
  try {
    if (!this.world) {
      if (this.worldLoader.map.ready_0) {
        this.world = new World_2(this.game, this.questName);
        $startLoading(this.worldLoader, this.world);
      }
      return false;
    }
     else {
      startLoadingTime = mul(fromInt($tick_1(platform_1)), Pf4240_longLit);
      for (;;) {
        if ($hasNext(this.worldLoader.iterator)) {
          $loadSome(this.worldLoader);
          currentLoadingTime = mul(fromInt($tick_1(platform_1)), Pf4240_longLit);
          elapsedLoadingDuration = sub(currentLoadingTime, startLoadingTime);
          if (gt(elapsedLoadingDuration, P27bc86a_longLit)) {
            return false;
          }
        }
         else {
          return true;
        }
      }
    }
  }
   catch ($e0) {
    $e0 = caught_0($e0);
    if (instanceOf($e0, Q$Exception)) {
      ex = $e0;
      throw new RuntimeException_2('Cannot load level ' + this.levelName + ' of quest ' + this.questName, ex);
    }
     else 
      throw $e0;
  }
}
;
_.processInputs = function processInputs(){
  if (this.world.hero.dyingTimedAction) {
    return;
  }
  $isPressed(this.game.input.rotateClockwise) && $progressiveRotateGravity(this.world, 0.05000000074505806);
  $isPressed(this.game.input.rotateCounterClockwise) && $progressiveRotateGravity(this.world, -0.05000000074505806);
  $isPressed(this.game.input.rotate90Clockwise) && $rotateGravity(this.world, 0.7853981852531433);
  $isPressed(this.game.input.rotate90CounterClockwise) && $rotateGravity(this.world, -0.7853981852531433);
  $processMovingInput(this);
  this.game.input.cheatActivateAll.activated && $cheatActivateAll(this.world);
  this.game.input.cheatGotoNextLevel.activated && (this.cheatCodeGotoNextLevel = true);
  this.game.input.cheatGotoNextBonusLevel.activated && (this.cheatCodeGotoNextBonusLevel = true);
  this.game.input.cheatGetWorldMap.activated && (this.world.hero.hasMap = true);
  this.game.input.cheatGetCompass.activated && (this.world.hero.hasCompass = true);
}
;
_.resume = function resume(){
  this.cheatCodeGotoNextBonusLevel = false;
  this.cheatCodeGotoNextLevel = false;
  $resume(this.world);
}
;
_.start_2 = function start_4(){
  $start_3(this);
}
;
_.startPreload = function startPreload(){
  var $e0, ex;
  try {
    this.world = null;
    this.worldLoader = new TmxLoader_0(this.game, this.questName, this.levelName);
    $preloading(this.worldLoader);
  }
   catch ($e0) {
    $e0 = caught_0($e0);
    if (instanceOf($e0, Q$Exception)) {
      ex = $e0;
      throw new RuntimeException_2('Error during preloading', ex);
    }
     else 
      throw $e0;
  }
}
;
_.stop_0 = function stop_4(){
  this.world = null;
}
;
_.update_0 = function update_6(){
  $update_2(this);
}
;
_.cheatCodeGotoNextBonusLevel = false;
_.cheatCodeGotoNextLevel = false;
_.frameTimeInfos = null;
_.game = null;
_.levelName = null;
_.minimapTexture = null;
_.nextSequence = null;
_.questName = null;
_.stepTime = P0_longLit;
_.world = null;
_.worldLoader = null;
function $setCurrentQuestName(this$static, currentQuestName){
  this$static.currentQuestName = currentQuestName;
}

function BonusSequence_0(game, levelName){
  LevelSequence_0.call(this, game, 'bonus', levelName);
}

defineSeed(333, 334, makeCastMap([Q$LevelSequence, Q$PreloadableSequence]), BonusSequence_0);
_.drawIndicators = function drawIndicators_0(){
  var b, remainingSeconds, seconds;
  b = new StringBuilder_0;
  $append_9(b, this.world.hero.nbApple);
  b.impl.string += '$ ';
  seconds = div(sub(this.endTime, this.game.frameTimeInfos.currentTime_0), P3b9aca00_longLit);
  $appendNonNull(b.impl, '' + toString_12(div(seconds, P3c_longLit)));
  b.impl.string += ':';
  remainingSeconds = mod(seconds, P3c_longLit);
  lt(remainingSeconds, Pa_longLit) && (b.impl.string += '0' , b);
  $appendNonNull(b.impl, '' + toString_12(remainingSeconds));
}
;
_.start_2 = function start_5(){
  $start_3(this);
  this.endTime = add_4(this.game.frameTimeInfos.currentTime_0, Pdf8475800_longLit);
}
;
_.update_0 = function update_7(){
  $update_2(this);
  if (gt(this.game.frameTimeInfos.currentTime_0, this.endTime)) {
    $setLevelScore(this.game.score, this.currentQuestName, this.levelName, this.world.hero.levelScore);
    throw new Sequence$NormalTransitionException_0(new FadeSequence_0(this.game, new Sequence$ResumeTransitionException_0(this.nextSequence)));
  }
}
;
_.currentQuestName = null;
_.endTime = P0_longLit;
function $clinit_Drawable(){
  $clinit_Drawable = nullMethod;
  comparator = new DrawableComparator_0;
}

var comparator;
function DrawableComparator_0(){
}

defineSeed(335, 1, {}, DrawableComparator_0);
_.compare = function compare_0(o1, o2){
  var z1, z2;
  return z1 = o1.getZOrder() , z2 = o2.getZOrder() , z1 < z2?-1:z2 < z1?1:0;
}
;
function $add_6(this$static, e){
  var entitiesWithSameZ, zOrder;
  zOrder = e.zorder;
  entitiesWithSameZ = $get_1(this$static.entities, valueOf_3(zOrder));
  if (!entitiesWithSameZ) {
    entitiesWithSameZ = new LinkedList_0;
    $put_0(this$static.entities, valueOf_3(zOrder), entitiesWithSameZ);
  }
  entitiesWithSameZ.add(e);
}

function $draw(this$static){
  var e, e$iterator, entry, entry$iterator;
  for (entry$iterator = new TreeMap$EntryIterator_0((new TreeMap$EntrySet_0(this$static.entities)).this$0); $hasNext_0(entry$iterator.iter);) {
    entry = entry$iterator.last = $next_2(entry$iterator.iter);
    for (e$iterator = entry.getValue().iterator_0(); e$iterator.hasNext();) {
      e = e$iterator.next_0();
      e.draw();
    }
  }
}

function $update_3(this$static, frameTimeInfos){
  var e, entry, entry$iterator, it;
  for (entry$iterator = new TreeMap$EntryIterator_0((new TreeMap$EntrySet_0(this$static.entities)).this$0); $hasNext_0(entry$iterator.iter);) {
    entry = entry$iterator.last = $next_2(entry$iterator.iter);
    it = entry.getValue().iterator_0();
    while (it.hasNext()) {
      e = it.next_0();
      e.update_1(frameTimeInfos);
      e.isDead_0() && it.remove_2();
    }
  }
}

function EntityList_0(){
  this.entities = new TreeMap_0;
}

defineSeed(336, 1, {}, EntityList_0);
function $update_4(this$static){
  var frameTimeInfos, remaining;
  frameTimeInfos = this$static.game.frameTimeInfos;
  lt(this$static.endTime, P0_longLit) && (this$static.endTime = add_4(this$static.game.frameTimeInfos.currentTime_0, this$static.duration_0));
  $update_1(this$static.loadingPlay, div(frameTimeInfos.elapsedTime, Pf4240_longLit));
  remaining = sub(this$static.endTime, frameTimeInfos.currentTime_0);
  lte(remaining, P0_longLit) && this$static.fadeDone();
  1 - toDouble(remaining) / toDouble(this$static.duration_0);
}

function FadeSequence_0(game, transition){
  this.game = game;
  this.duration_0 = P3b9aca00_longLit;
  this.transition = transition;
}

defineSeed(337, 1, {}, FadeSequence_0);
_.draw = function draw_0(){
  $drawFadeSequence(this.game.view, this.loadingPlay);
}
;
_.fadeDone = function fadeDone(){
  this.transition.throwMe();
}
;
_.processInputs = function processInputs_0(){
}
;
_.resume = function resume_0(){
}
;
_.start_2 = function start_6(){
  this.loadingPlay = $getFirst($loadFromAnimation(this.game.view, 'loading.json')).start_0();
}
;
_.stop_0 = function stop_5(){
  this.loadingPlay = null;
}
;
_.update_0 = function update_8(){
  $update_4(this);
}
;
_.duration_0 = P0_longLit;
_.endTime = N1_longLit;
_.game = null;
_.loadingPlay = null;
_.transition = null;
function $update_5(this$static, nanoTime){
  gt(this$static.lastNanoTime, P0_longLit) && (this$static.currentTime_0 = add_4(this$static.currentTime_0, sub(nanoTime, this$static.lastNanoTime)));
  this$static.lastNanoTime = nanoTime;
  this$static.elapsedTime = sub(this$static.currentTime_0, this$static.startTime);
  this$static.startTime = this$static.currentTime_0;
  this$static.totalTime = add_4(this$static.totalTime, this$static.elapsedTime);
  if (gt(this$static.totalTime, P3b9aca00_longLit)) {
    this$static.totalTime = sub(this$static.totalTime, P3b9aca00_longLit);
    this$static.fps = this$static.frames_0;
    this$static.frames_0 = 0;
  }
  ++this$static.frames_0;
}

function FrameTimeInfos_0(){
  this.random_0 = new Random_0;
}

defineSeed(338, 1, {}, FrameTimeInfos_0);
_.currentTime_0 = P0_longLit;
_.elapsedTime = P0_longLit;
_.fps = 0;
_.frames_0 = 0;
_.lastNanoTime = N1_longLit;
_.startTime = P0_longLit;
_.totalTime = P0_longLit;
function $addButton(this$static, b){
  $add_0(this$static.buttons, b);
}

function $getBackgroundImage(this$static){
  var frame;
  if (this$static.backgroundTexture) {
    frame = $getCurrentFrame(this$static.backgroundTexture);
    if (frame) {
      return frame.image;
    }
  }
  return null;
}

function $processInputs(this$static){
  var button, button$iterator, mousePos, mouseX, mouseY, oldButtonIndex, viewHeight, viewWidth;
  if (this$static.buttons.size != 0) {
    oldButtonIndex = this$static.currentButtonIndex;
    if (this$static.game.input.menuRight.activated) {
      $get(this$static.buttons, this$static.currentButtonIndex).on = false;
      this$static.currentButtonIndex += 1;
      this$static.currentButtonIndex >= this$static.buttons.size && (this$static.currentButtonIndex = 0);
      $get(this$static.buttons, this$static.currentButtonIndex).on = true;
    }
    if (this$static.game.input.menuLeft.activated) {
      $get(this$static.buttons, this$static.currentButtonIndex).on = false;
      this$static.currentButtonIndex -= 1;
      this$static.currentButtonIndex < 0 && (this$static.currentButtonIndex = this$static.buttons.size - 1);
      $get(this$static.buttons, this$static.currentButtonIndex).on = true;
    }
    if (this$static.game.input.menuDown.activated) {
      $get(this$static.buttons, this$static.currentButtonIndex).on = false;
      this$static.currentButtonIndex += this$static.verticalIncrement;
      this$static.currentButtonIndex >= this$static.buttons.size && (this$static.currentButtonIndex = 0);
      $get(this$static.buttons, this$static.currentButtonIndex).on = true;
    }
    if (this$static.game.input.menuUp.activated) {
      $get(this$static.buttons, this$static.currentButtonIndex).on = false;
      this$static.currentButtonIndex -= this$static.verticalIncrement;
      this$static.currentButtonIndex < 0 && (this$static.currentButtonIndex = this$static.buttons.size - 1);
      $get(this$static.buttons, this$static.currentButtonIndex).on = true;
    }
    if (this$static.game.input.menuOk.activated) {
      $play_0($getSound(this$static.game.platform.toolkit.audio, (this$static.game , 'select.wav')).val$sound);
      $get(this$static.buttons, this$static.currentButtonIndex).activate();
    }
    mousePos = $getMousePos(this$static.game.input);
    if (mousePos) {
      viewWidth = platform_1.graphics.width_2();
      viewHeight = platform_1.graphics.height_2();
      if (viewWidth != 0 && viewHeight != 0) {
        mouseX = mousePos.x * 1280 / viewWidth;
        mouseY = 800 - mousePos.y * 800 / viewHeight;
        for (button$iterator = new AbstractList$IteratorImpl_0(this$static.buttons); button$iterator.i < button$iterator.this$0_0.size_0();) {
          button = $next_2(button$iterator);
          if (mouseX > button.x && mouseX < button.x + button.w && mouseY > button.y && mouseY < button.y + button.h_0) {
            if (this$static.oldMousePos.x != mousePos.x || this$static.oldMousePos.y != mousePos.y || $isMouseButtonDown(this$static.game.input)) {
              $get(this$static.buttons, this$static.currentButtonIndex).on = false;
              this$static.currentButtonIndex = $indexOf_0(this$static.buttons, button, 0);
              button.on = true;
            }
            if (!this$static.mouseActivateCurrentButton) {
              $isMouseButtonDown(this$static.game.input) || (this$static.mouseActivateCurrentButton = ($clinit_Boolean() , $clinit_Boolean() , FALSE));
            }
             else {
              if ($isMouseButtonDown(this$static.game.input)) {
                this$static.mouseActivateCurrentButton = ($clinit_Boolean() , $clinit_Boolean() , TRUE);
              }
               else if (this$static.mouseActivateCurrentButton.value_0) {
                this$static.mouseActivateCurrentButton = ($clinit_Boolean() , $clinit_Boolean() , FALSE);
                $play_0($getSound(this$static.game.platform.toolkit.audio, (this$static.game , 'select.wav')).val$sound);
                button.activate();
              }
            }
            break;
          }
        }
      }
      $set_5(this$static.oldMousePos, mousePos);
    }
    oldButtonIndex != this$static.currentButtonIndex && $play_0($getSound(this$static.game.platform.toolkit.audio, (this$static.game , 'select.wav')).val$sound);
  }
}

function $setCurrentButton(this$static, button){
  var b, i;
  for (i = 0; i < this$static.buttons.size; ++i) {
    b = $get(this$static.buttons, i);
    if (b == button) {
      this$static.currentButtonIndex = i;
      b.on = true;
    }
     else {
      b.on = false;
    }
  }
}

function $start_4(this$static){
  var button, button$iterator, mousePos, textureCache;
  null != this$static.backgroundTexturePath && (this$static.backgroundTexture = $getFirst($loadFromAnimation(this$static.game.view, this$static.backgroundTexturePath)).start_1(this$static.backgroundPlayMode));
  this$static.currentButtonIndex = 0;
  this$static.mouseActivateCurrentButton = null;
  $indexOf_0(this$static.buttons, this$static.defaultButton, 0) != -1?$setCurrentButton(this$static, this$static.defaultButton):$setCurrentButton(this$static, this$static.buttons.size == 0?null:$get(this$static.buttons, 0));
  textureCache = this$static.game.view.textureCache;
  for (button$iterator = new AbstractList$IteratorImpl_0(this$static.buttons); button$iterator.i < button$iterator.this$0_0.size_0();) {
    button = $next_2(button$iterator);
    button.start_2();
    button.onTexture = $getTexture(textureCache, button.onTextureName);
    button.offTexture = $getTexture(this$static.game.view.textureCache, button.offTextureName);
  }
  mousePos = $getMousePos(this$static.game.input);
  !!mousePos && $set_5(this$static.oldMousePos, mousePos);
}

function $stop_1(this$static){
  var button, button$iterator;
  this$static.backgroundTexture = null;
  for (button$iterator = new AbstractList$IteratorImpl_0(this$static.buttons); button$iterator.i < button$iterator.this$0_0.size_0();) {
    button = $next_2(button$iterator);
    button.onTexture = null;
    button.offTexture = null;
  }
}

function MenuSequence_0(game){
  this.buttons = new ArrayList_0;
  this.oldMousePos = new Vector2f_0;
  this.game = game;
}

defineSeed(341, 1, {});
_.draw = function draw_1(){
  $doDrawMenuSequence(this.game.view, this);
}
;
_.processInputs = function processInputs_1(){
  $processInputs(this);
}
;
_.resume = function resume_1(){
  this.mouseActivateCurrentButton = null;
}
;
_.start_2 = function start_7(){
  $start_4(this);
}
;
_.stop_0 = function stop_6(){
  $stop_1(this);
}
;
_.update_0 = function update_9(){
  !!this.backgroundTexture && $update_1(this.backgroundTexture, div(this.game.frameTimeInfos.elapsedTime, Pf4240_longLit));
}
;
_.backgroundPlayMode = 1;
_.backgroundTexture = null;
_.backgroundTexturePath = null;
_.backgroundX1 = 0;
_.backgroundX2 = 1280;
_.backgroundY1 = 800;
_.backgroundY2 = 0;
_.currentButtonIndex = 0;
_.defaultButton = null;
_.game = null;
_.mouseActivateCurrentButton = null;
_.verticalIncrement = 1;
function $processInputs_0(this$static){
  $processInputs(this$static);
  if (this$static.skipActionActivatedDetector) {
    $poll(this$static.skipActionActivatedDetector);
    this$static.skipActionActivatedDetector.activated && this$static.transition.throwMe();
  }
}

function StoryboardSequence_0(game, texture, music, transition){
  StoryboardSequence_1.call(this, game, texture, music, transition, true);
}

function StoryboardSequence_1(game, texture, music, transition, withContinueButton){
  MenuSequence_0.call(this, game);
  this.backgroundTexturePath = texture;
  this.transition = transition;
  this.music = music;
  if (withContinueButton) {
    this.continueButton = new StoryboardSequence$1_0(this, transition);
    this.continueButton.offTextureName = $getButtonFile(game, 'bt-continue-off');
    this.continueButton.onTextureName = $getButtonFile(game, 'bt-continue-on');
    this.continueButton.x = 960;
    this.continueButton.y = 700;
    this.continueButton.w = 312;
    this.continueButton.h_0 = 90;
    $addButton(this, this.continueButton);
  }
   else {
    this.skipActionActivatedDetector = new ActionActivatedDetector_0($getPressAnyKeyAction(game.platform.toolkit));
  }
}

defineSeed(340, 341, {}, StoryboardSequence_0, StoryboardSequence_1);
_.processInputs = function processInputs_2(){
  $processInputs_0(this);
}
;
_.start_2 = function start_8(){
  $start_4(this);
  null != this.music && $playMusic(this.game.platform.toolkit.audio, this.music, this.musicLoop);
  !!this.skipActionActivatedDetector && (this.skipActionActivatedDetector.previousStates = null);
}
;
_.update_0 = function update_10(){
  !!this.backgroundTexture && $update_1(this.backgroundTexture, div(this.game.frameTimeInfos.elapsedTime, Pf4240_longLit));
  !!this.backgroundTexture && this.backgroundTexture.state == 1 && this.transition.throwMe();
}
;
_.continueButton = null;
_.music = null;
_.musicLoop = true;
_.skipActionActivatedDetector = null;
_.transition = null;
function GameOverSequence_0(game, level){
  var retryButton;
  StoryboardSequence_0.call(this, game, 'gameover.png', 'Game_Over.ogg', new Sequence$NormalTransitionException_0(game.mainMenuSequence));
  retryButton = new GameOverSequence$1_0(this, game, level);
  retryButton.offTextureName = $getButtonFile(game, 'bt-retry-off');
  retryButton.onTextureName = $getButtonFile(game, 'bt-retry-on');
  retryButton.x = 640;
  retryButton.y = 700;
  retryButton.w = 312;
  retryButton.h_0 = 90;
  $add_0(this.buttons, retryButton);
  this.defaultButton = retryButton;
}

defineSeed(339, 340, {}, GameOverSequence_0);
defineSeed(343, 1, {});
_.draw = function draw_2(){
  $drawButton(this.this$0_0.game.view, this);
}
;
_.start_2 = function start_9(){
}
;
_.h_0 = -1;
_.offTexture = null;
_.offTextureName = null;
_.on = false;
_.onTexture = null;
_.onTextureName = null;
_.this$0_0 = null;
_.w = -1;
_.x = 273;
_.y = 0;
function GameOverSequence$1_0(this$0_1, val$game, val$level){
  this.val$game = val$game;
  this.val$level = val$level;
  this.this$0_0 = this$0_1;
}

defineSeed(342, 343, {}, GameOverSequence$1_0);
_.activate = function activate(){
  throw new Sequence$NormalTransitionException_0(new PreloaderFadeSequence_0(this.val$game, this.val$level));
}
;
_.val$game = null;
_.val$level = null;
function HelpSequence_0(game, transition){
  StoryboardSequence_1.call(this, game, 'help.png', null, transition, true);
}

defineSeed(344, 340, {}, HelpSequence_0);
_.processInputs = function processInputs_3(){
  $processInputs_0(this);
  this.game.input.cheatSetAllCompleted.activated && $cheatSetAllCompleted(this.game);
}
;
function $loadLevels(this$static){
  var i, j, levelName, levelNamesIterator, isBlocked, questButton;
  $clear(this$static.buttons);
  levelNamesIterator = new AbstractList$IteratorImpl_0($listQuestLevels(this$static.game.data, this$static.questSequence.questName));
  for (j = 0; j < 3; ++j) {
    for (i = 0; i < 2; ++i) {
      if (levelNamesIterator.i >= levelNamesIterator.this$0_0.size_0()) {
        return;
      }
      levelName = $next_2(levelNamesIterator);
      isBlocked = $isLevelBlocked(this$static.game, this$static.questSequence.questName, levelName);
      questButton = new LevelMenuSequence$2_0(this$static, this$static, isBlocked, levelName);
      questButton.offTextureName = $getLevelFilePath(this$static.game.data, this$static.questSequence.questName, levelName, 'bt-level-off.png');
      isBlocked?(questButton.onTextureName = (this$static.game , 'bt-blocked.png')):(questButton.onTextureName = $getLevelFilePath(this$static.game.data, this$static.questSequence.questName, levelName, 'bt-level-on.png'));
      questButton.x = 60 + i * 610;
      questButton.y = 15 + j * 246.6666717529297;
      questButton.w = 550;
      questButton.h_0 = 186.6666717529297;
      $add_0(this$static.buttons, questButton);
    }
  }
}

function LevelMenuSequence_0(game, questSequence){
  MenuSequence_0.call(this, game);
  this.questSequence = questSequence;
  this.verticalIncrement = 2;
}

defineSeed(345, 341, {}, LevelMenuSequence_0);
_.start_2 = function start_10(){
  var returnToPreviousSequence;
  $loadLevels(this);
  returnToPreviousSequence = new LevelMenuSequence$1_0(this, this);
  returnToPreviousSequence.offTextureName = $getButtonFile(this.game, 'quest_menu/bt-menu-off');
  returnToPreviousSequence.onTextureName = $getButtonFile(this.game, 'quest_menu/bt-menu-on');
  returnToPreviousSequence.x = 670;
  returnToPreviousSequence.y = 728;
  returnToPreviousSequence.w = 550;
  returnToPreviousSequence.h_0 = 60;
  $add_0(this.buttons, returnToPreviousSequence);
  $start_4(this);
}
;
_.questSequence = null;
function LevelMenuSequence$1_0(this$0, this$0_1){
  this.this$0 = this$0;
  this.this$0_0 = this$0_1;
}

defineSeed(346, 343, {}, LevelMenuSequence$1_0);
_.activate = function activate_0(){
  $gotoQuestMenu(this.this$0.game);
}
;
_.this$0 = null;
function LevelMenuSequence$2_0(this$0, this$0_1, val$isBlocked, val$levelName){
  this.this$0 = this$0;
  this.val$isBlocked = val$isBlocked;
  this.val$levelName = val$levelName;
  this.this$0_0 = this$0_1;
}

defineSeed(347, 343, {}, LevelMenuSequence$2_0);
_.activate = function activate_1(){
  this.val$isBlocked || $gotoLevel(this.this$0.questSequence, this.val$levelName);
}
;
_.draw = function draw_3(){
  var levelScore, score, scoreLabel;
  scoreLabel = '';
  levelScore = $get_1($getQuestScore(this.this$0.game.score, this.this$0.questSequence.questName), this.val$levelName);
  if (levelScore) {
    score = levelScore.nbKilledMummy * 3 + levelScore.nbKilledBat * 4 + levelScore.nbKilledEgyptianBoss * 10 + levelScore.nbCoin * 5 + levelScore.nbApple + levelScore.nbLosedApple * -2;
    score > 0 && (scoreLabel += score);
  }
  $drawMenuButton(this.this$0.game.view, this, this.val$levelName, scoreLabel);
}
;
_.this$0 = null;
_.val$isBlocked = false;
_.val$levelName = null;
function $setResumeSequence(this$static, s){
  this$static.resumeSequence = s;
  this$static.resumeSequence?(this$static.resumeButton.onTextureName = $getButtonFile(this$static.game, 'main_menu/bt-resume-on')):(this$static.resumeButton.onTextureName = $getButtonFile(this$static.game, 'main_menu/bt-resume-impossible'));
}

function $start_5(this$static){
  $start_4(this$static);
  if (instanceOf(this$static.resumeSequence, Q$LevelSequence)) {
    $setCurrentButton(this$static, this$static.resumeButton);
  }
   else {
    $setCurrentButton(this$static, this$static.playButton);
    $playMusic(this$static.game.platform.toolkit.audio, (this$static.game , 'lovelace_0.ogg'), true);
  }
}

--></script>
<script><!--
function MainMenuSequence_0(game, playSeq, quitSeq, optSequence){
  var helpButton, optionsButton, quitButton, d;
  MenuSequence_0.call(this, game);
  this.specialOccasionLayer = (d = new Date_1 , d.jsdate.getMonth() == 11?new SnowLayer_0:new NullOccasionLayer_0);
  this.playSequence = playSeq;
  this.quitSequence = quitSeq;
  this.optionsSequence = optSequence;
  this.helpSequence = new HelpSequence_0(game, new Sequence$NormalTransitionException_0(this));
  this.backgroundTexturePath = 'main_menu/home.png';
  this.playButton = new MainMenuSequence$1_0(this, this);
  this.playButton.offTextureName = $getButtonFile(game, 'main_menu/bt-play-off');
  this.playButton.onTextureName = $getButtonFile(game, 'main_menu/bt-play-on');
  this.playButton.on = true;
  this.playButton.x = 480;
  this.playButton.y = 267;
  this.playButton.w = 312;
  this.playButton.h_0 = 90;
  $addButton(this, this.playButton);
  this.resumeButton = new MainMenuSequence$2_0(this, this);
  this.resumeButton.offTextureName = $getButtonFile(game, 'main_menu/bt-resume-off');
  this.resumeButton.onTextureName = $getButtonFile(game, 'main_menu/bt-resume-impossible');
  this.resumeButton.x = 480;
  this.resumeButton.y = 371;
  this.resumeButton.w = 312;
  this.resumeButton.h_0 = 90;
  $addButton(this, this.resumeButton);
  optionsButton = new MainMenuSequence$3_0(this, this);
  optionsButton.offTextureName = $getButtonFile(game, 'main_menu/bt-options-off');
  optionsButton.onTextureName = $getButtonFile(game, 'main_menu/bt-options-on');
  optionsButton.x = 480;
  optionsButton.y = 475;
  optionsButton.w = 312;
  optionsButton.h_0 = 90;
  $add_0(this.buttons, optionsButton);
  helpButton = new MainMenuSequence$4_0(this, this);
  helpButton.offTextureName = $getButtonFile(game, 'main_menu/bt-help-off');
  helpButton.onTextureName = $getButtonFile(game, 'main_menu/bt-help-on');
  helpButton.x = 480;
  helpButton.y = 579;
  helpButton.w = 312;
  helpButton.h_0 = 90;
  $add_0(this.buttons, helpButton);
  quitButton = new MainMenuSequence$5_0(this, this);
  quitButton.offTextureName = $getButtonFile(game, 'main_menu/bt-quit-off');
  quitButton.onTextureName = $getButtonFile(game, 'main_menu/bt-quit-on');
  quitButton.x = 480;
  quitButton.y = 683;
  quitButton.w = 312;
  quitButton.h_0 = 90;
  $add_0(this.buttons, quitButton);
}

defineSeed(348, 341, {}, MainMenuSequence_0);
_.draw = function draw_4(){
  $doDrawMenuSequence(this.game.view, this);
  this.specialOccasionLayer.draw();
}
;
_.start_2 = function start_11(){
  $start_5(this);
}
;
_.update_0 = function update_11(){
  !!this.backgroundTexture && $update_1(this.backgroundTexture, div(this.game.frameTimeInfos.elapsedTime, Pf4240_longLit));
  this.specialOccasionLayer.update_0();
}
;
_.helpSequence = null;
_.optionsSequence = null;
_.playButton = null;
_.playSequence = null;
_.quitSequence = null;
_.resumeButton = null;
_.resumeSequence = null;
_.specialOccasionLayer = null;
function MainMenuSequence$1_0(this$0, this$0_1){
  this.this$0 = this$0;
  this.this$0_0 = this$0_1;
}

defineSeed(349, 343, {}, MainMenuSequence$1_0);
_.activate = function activate_2(){
  $setResumeSequence(this.this$0, null);
  throw new Sequence$NormalTransitionException_0(this.this$0.playSequence);
}
;
_.this$0 = null;
function MainMenuSequence$2_0(this$0, this$0_1){
  this.this$0 = this$0;
  this.this$0_0 = this$0_1;
}

defineSeed(350, 343, {}, MainMenuSequence$2_0);
_.activate = function activate_3(){
  var ex;
  if (this.this$0.resumeSequence) {
    ex = new Sequence$ResumeTransitionException_0(this.this$0.resumeSequence);
    $setResumeSequence(this.this$0, null);
    throw ex;
  }
}
;
_.this$0 = null;
function MainMenuSequence$3_0(this$0, this$0_1){
  this.this$0 = this$0;
  this.this$0_0 = this$0_1;
}

defineSeed(351, 343, {}, MainMenuSequence$3_0);
_.activate = function activate_4(){
  if (this.this$0.optionsSequence) {
    throw new Sequence$ResumableTransitionException_0(this.this$0.optionsSequence);
  }
}
;
_.this$0 = null;
function MainMenuSequence$4_0(this$0, this$0_1){
  this.this$0 = this$0;
  this.this$0_0 = this$0_1;
}

defineSeed(352, 343, {}, MainMenuSequence$4_0);
_.activate = function activate_5(){
  if (this.this$0.helpSequence) {
    throw new Sequence$NormalTransitionException_0(this.this$0.helpSequence);
  }
}
;
_.this$0 = null;
function MainMenuSequence$5_0(this$0, this$0_1){
  this.this$0 = this$0;
  this.this$0_0 = this$0_1;
}

defineSeed(353, 343, {}, MainMenuSequence$5_0);
_.activate = function activate_6(){
  throw new Sequence$NormalTransitionException_0(this.this$0.quitSequence);
}
;
_.this$0 = null;
function PreloaderFadeSequence_0(game, preloableSequence){
  FadeSequence_0.call(this, game, new Sequence$NormalTransitionException_0(preloableSequence));
  this.preloableSequence = preloableSequence;
}

defineSeed(354, 337, {}, PreloaderFadeSequence_0);
_.draw = function draw_5(){
  $drawFadeSequence(this.game.view, this.loadingPlay);
}
;
_.fadeDone = function fadeDone_0(){
}
;
_.processInputs = function processInputs_4(){
}
;
_.resume = function resume_2(){
}
;
_.start_2 = function start_12(){
  this.loadingPlay = $getFirst($loadFromAnimation(this.game.view, 'loading.json')).start_0();
  this.preloableSequence.startPreload();
}
;
_.stop_0 = function stop_7(){
  this.loadingPlay = null;
  this.preloableSequence.finishPreload();
}
;
_.update_0 = function update_12(){
  $update_4(this);
  this.preloableSequence.preloadSomeAndCheckIfTerminated() && this.transition.throwMe();
}
;
_.preloableSequence = null;
function $$init_0(this$static){
  this$static.questMenuSequences = new ArrayList_0;
}

function $createNavigateButton(this$static, i, j, sequence, textureBaseName){
  var button;
  button = new QuestMenuSequence$1_0(this$static, sequence);
  button.offTextureName = $getButtonFile(this$static.game, 'quest_menu/' + textureBaseName + '-off');
  button.onTextureName = $getButtonFile(this$static.game, 'quest_menu/' + textureBaseName + '-on');
  button.x = 60 + i * 610;
  button.y = 60 + j * 246.6666717529297;
  button.w = 550;
  button.h_0 = 186.6666717529297;
  $add_0(this$static.buttons, button);
}

function $loadQuests(this$static, questNamesIterator, previousSequence){
  var i, j, maxQuestButtons, nbQuestButtonCreated, nextQuestMenu, questName, questSequence, levelMenuSequence, questButton, returnToMenuButton;
  this$static.quests = new ArrayList_0;
  nbQuestButtonCreated = 0;
  maxQuestButtons = 6 - (!previousSequence?1:2);
  for (j = 0; j < 3; ++j) {
    for (i = 0; i < 2; ++i) {
      if (questNamesIterator.hasNext() && nbQuestButtonCreated < maxQuestButtons) {
        questName = questNamesIterator.next_0();
        questSequence = new QuestSequence_0(this$static.game, questName);
        $add_0(this$static.quests, questSequence);
        levelMenuSequence = new LevelMenuSequence_0(this$static.game, questSequence);
        questButton = new QuestMenuSequence$3_0(this$static, this$static, questName, levelMenuSequence);
        questButton.offTextureName = 'quests/' + (this$static.game , questName) + '/bt-quest-off.png';
        questButton.onTextureName = 'quests/' + (this$static.game , questName) + '/bt-quest-on.png';
        questButton.x = 60 + i * 610;
        questButton.y = 60 + j * 246.6666717529297;
        questButton.w = 550;
        questButton.h_0 = 186.6666717529297;
        $add_0(this$static.buttons, questButton);
        ++nbQuestButtonCreated;
      }
       else if (previousSequence) {
        $createNavigateButton(this$static, i, j, previousSequence, 'bt-previous');
        previousSequence = null;
      }
       else if (questNamesIterator.hasNext()) {
        nextQuestMenu = new QuestMenuSequence_1(this$static.game, this$static, questNamesIterator);
        $add_0(this$static.questMenuSequences, nextQuestMenu);
        $createNavigateButton(this$static, i, j, nextQuestMenu, 'bt-next');
        return;
      }
       else {
        returnToMenuButton = new QuestMenuSequence$2_0(this$static, this$static);
        returnToMenuButton.offTextureName = $getButtonFile(this$static.game, 'quest_menu/bt-menu-off');
        returnToMenuButton.onTextureName = $getButtonFile(this$static.game, 'quest_menu/bt-menu-on');
        returnToMenuButton.x = 60 + i * 610;
        returnToMenuButton.y = 60 + j * 246.6666717529297;
        returnToMenuButton.w = 550;
        returnToMenuButton.h_0 = 186.6666717529297;
        $add_0(this$static.buttons, returnToMenuButton);
        return;
      }
    }
  }
}

function $setNextSequence_0(this$static, sequence){
  var quest, quest$iterator, questMenu, questMenu$iterator;
  for (quest$iterator = new AbstractList$IteratorImpl_0(this$static.quests); quest$iterator.i < quest$iterator.this$0_0.size_0();) {
    quest = $next_2(quest$iterator);
    quest.nextSequence = sequence;
    !!quest.scoreSequence && $setNextSequence_1(quest.scoreSequence, quest.nextSequence);
  }
  for (questMenu$iterator = new AbstractList$IteratorImpl_0(this$static.questMenuSequences); questMenu$iterator.i < questMenu$iterator.this$0_0.size_0();) {
    questMenu = $next_2(questMenu$iterator);
    $setNextSequence_0(questMenu, sequence);
  }
}

function QuestMenuSequence_0(game){
  MenuSequence_0.call(this, game);
  $$init_0(this);
  this.verticalIncrement = 2;
  $loadQuests(this, new AbstractList$IteratorImpl_0(game.data.questsConfig.visibleQuests), null);
}

function QuestMenuSequence_1(game, previousSequence, questNamesIterator){
  MenuSequence_0.call(this, game);
  $$init_0(this);
  this.verticalIncrement = 2;
  $loadQuests(this, questNamesIterator, previousSequence);
}

defineSeed(355, 341, {}, QuestMenuSequence_0, QuestMenuSequence_1);
_.quests = null;
function QuestMenuSequence$1_0(this$0_1, val$sequence){
  this.val$sequence = val$sequence;
  this.this$0_0 = this$0_1;
}

defineSeed(356, 343, {}, QuestMenuSequence$1_0);
_.activate = function activate_7(){
  throw new Sequence$NormalTransitionException_0(this.val$sequence);
}
;
_.val$sequence = null;
function QuestMenuSequence$2_0(this$0, this$0_1){
  this.this$0 = this$0;
  this.this$0_0 = this$0_1;
}

defineSeed(357, 343, {}, QuestMenuSequence$2_0);
_.activate = function activate_8(){
  throw new Sequence$NormalTransitionException_0(this.this$0.game.mainMenuSequence);
}
;
_.this$0 = null;
function QuestMenuSequence$3_0(this$0, this$0_1, val$questName, val$levelMenuSequence){
  this.this$0 = this$0;
  this.val$questName = val$questName;
  this.val$levelMenuSequence = val$levelMenuSequence;
  this.this$0_0 = this$0_1;
}

defineSeed(358, 343, {}, QuestMenuSequence$3_0);
_.activate = function activate_9(){
  if (!$isQuestBlocked(this.this$0.game, this.val$questName)) {
    throw new Sequence$NormalTransitionException_0(this.val$levelMenuSequence);
  }
}
;
_.draw = function draw_6(){
  var score, scoreLabel;
  scoreLabel = '';
  score = $computeScore_0($getQuestScore(this.this$0.game.score, this.val$questName));
  score > 0 && (scoreLabel += score);
  $drawMenuButton(this.this$0.game.view, this, this.val$questName, scoreLabel);
}
;
_.start_2 = function start_13(){
  $isQuestBlocked(this.this$0.game, this.val$questName)?(this.onTextureName = (this.this$0.game , 'bt-blocked.png')):(this.onTextureName = 'quests/' + (this.this$0.game , this.val$questName) + '/bt-quest-on.png');
}
;
_.this$0 = null;
_.val$levelMenuSequence = null;
_.val$questName = null;
function $gotoLevel(this$static, newLevelName){
  var level, level$iterator;
  for (level$iterator = new AbstractList$IteratorImpl_0(this$static.levels); level$iterator.i < level$iterator.this$0_0.size_0();) {
    level = $next_2(level$iterator);
    if ($equals_0(level.levelName, newLevelName)) {
      throw new Sequence$NormalTransitionException_0(new PreloaderFadeSequence_0(this$static.game, level));
    }
  }
}

function $loadLevels_0(this$static, questName){
  var completedSequence, lastSequence, levelName, levelName$iterator, levelNames, levelSequence;
  this$static.levels = new ArrayList_0;
  levelNames = $listQuestLevels(this$static.game.data, questName);
  lastSequence = null;
  for (levelName$iterator = new AbstractList$IteratorImpl_0(levelNames); levelName$iterator.i < levelName$iterator.this$0_0.size_0();) {
    levelName = $next_2(levelName$iterator);
    levelSequence = new LevelSequence_0(this$static.game, questName, levelName);
    $add_0(this$static.levels, levelSequence);
    !!lastSequence && (lastSequence.nextSequence = levelSequence);
    lastSequence = levelSequence;
  }
  if (lastSequence) {
    this$static.scoreSequence = new ScoreSequence_0(this$static.game, questName, this$static.nextSequence);
    completedSequence = new StoryboardSequence_0(this$static.game, 'quests/' + (this$static.game , questName) + '/completed.png', (this$static.game , 'story_time.ogg'), new Sequence$NormalTransitionException_0(this$static.scoreSequence));
    lastSequence.nextSequence = completedSequence;
  }
}

function QuestSequence_0(game, questName){
  this.game = game;
  this.questName = questName;
  $loadLevels_0(this, questName);
}

defineSeed(359, 1, {}, QuestSequence_0);
_.draw = function draw_7(){
}
;
_.processInputs = function processInputs_5(){
}
;
_.resume = function resume_3(){
}
;
_.start_2 = function start_14(){
}
;
_.stop_0 = function stop_8(){
}
;
_.update_0 = function update_13(){
  throw new Sequence$NormalTransitionException_0(this.levels.size == 0?this.nextSequence:$get(this.levels, 0));
}
;
_.game = null;
_.levels = null;
_.nextSequence = null;
_.questName = null;
_.scoreSequence = null;
function $setNextSequence_1(this$static, nextSequence){
  this$static.nextSequence = nextSequence;
}

function ScoreSequence_0(game, questName, nextSequence){
  var continueButton;
  MenuSequence_0.call(this, game);
  this.questScore = $getQuestScore(game.score, questName);
  this.nextSequence = nextSequence;
  continueButton = new ScoreSequence$1_0(this, this);
  continueButton.offTextureName = $getButtonFile(game, 'bt-continue-off');
  continueButton.onTextureName = $getButtonFile(game, 'bt-continue-on');
  continueButton.x = 960;
  continueButton.y = 700;
  continueButton.w = 312;
  continueButton.h_0 = 90;
  $add_0(this.buttons, continueButton);
}

defineSeed(360, 341, {}, ScoreSequence_0);
_.draw = function draw_8(){
  $drawScoreSequence(this.game.view, this, this.questScore, this.scorePerCentToShow);
}
;
_.start_2 = function start_15(){
  $start_4(this);
  this.timeInfos = new FrameTimeInfos_0;
  this.scorePerCentToShow = P0_longLit;
}
;
_.stop_0 = function stop_9(){
  $stop_1(this);
}
;
_.update_0 = function update_14(){
  var newScorePercentToShow;
  !!this.backgroundTexture && $update_1(this.backgroundTexture, div(this.game.frameTimeInfos.elapsedTime, Pf4240_longLit));
  $update_5(this.timeInfos, mul(fromInt($tick_1(platform_1)), Pf4240_longLit));
  newScorePercentToShow = min_1(div(mul(this.timeInfos.currentTime_0, P64_longLit), P540be400_longLit));
  neq(newScorePercentToShow, this.scorePerCentToShow) && (this.scorePerCentToShow = newScorePercentToShow);
}
;
_.nextSequence = null;
_.questScore = null;
_.scorePerCentToShow = P0_longLit;
_.timeInfos = null;
function ScoreSequence$1_0(this$0, this$0_1){
  this.this$0 = this$0;
  this.this$0_0 = this$0_1;
}

defineSeed(361, 343, {}, ScoreSequence$1_0);
_.activate = function activate_10(){
  throw new Sequence$NormalTransitionException_0(this.this$0.nextSequence);
}
;
_.this$0 = null;
function Sequence$AbstractTransitionException_0(nextSequence){
  Throwable_0.call(this);
  this.nextSequence = nextSequence;
}

defineSeed(362, 52, makeCastMap([Q$Serializable, Q$Throwable]));
_.nextSequence = null;
function Sequence$NormalTransitionException_0(nextSequence){
  Sequence$AbstractTransitionException_0.call(this, nextSequence);
}

defineSeed(363, 362, makeCastMap([Q$Sequence$NormalTransitionException, Q$Serializable, Q$Throwable]), Sequence$NormalTransitionException_0);
_.throwMe = function throwMe(){
  throw this;
}
;
function Sequence$ResumableTransitionException_0(nextSequence){
  Sequence$AbstractTransitionException_0.call(this, nextSequence);
}

defineSeed(364, 362, makeCastMap([Q$Sequence$ResumableTransitionException, Q$Serializable, Q$Throwable]), Sequence$ResumableTransitionException_0);
_.throwMe = function throwMe_0(){
  throw this;
}
;
function Sequence$ResumeTransitionException_0(nextSequence){
  Sequence$AbstractTransitionException_0.call(this, nextSequence);
}

defineSeed(365, 362, makeCastMap([Q$Sequence$ResumeTransitionException, Q$Serializable, Q$Throwable]), Sequence$ResumeTransitionException_0);
_.throwMe = function throwMe_1(){
  throw this;
}
;
function StoryboardSequence$1_0(this$0_1, val$transition){
  this.val$transition = val$transition;
  this.this$0_0 = this$0_1;
}

defineSeed(366, 343, {}, StoryboardSequence$1_0);
_.activate = function activate_11(){
  this.val$transition.throwMe();
}
;
_.val$transition = null;
function NullOccasionLayer_0(){
}

defineSeed(367, 1, {}, NullOccasionLayer_0);
_.draw = function draw_9(){
}
;
_.update_0 = function update_15(){
}
;
function SnowLayer_0(){
  this.flakes = initDim(_3Lim_bci_newtonadv_game_special_occasion_SnowLayer$SnowFlake_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$SnowLayer$SnowFlake, 1000, 0);
}

defineSeed(368, 1, {}, SnowLayer_0);
_.draw = function draw_10(){
}
;
_.update_0 = function update_16(){
  var i;
  ++this.lastUpdate;
  if (this.lastUpdate >= 4) {
    this.lastUpdate = 0;
    for (i = 0; i < this.flakes.length; ++i) {
      if (!this.flakes[i]) {
        this.flakes[i] = new SnowLayer$SnowFlake_0;
        break;
      }
    }
  }
  for (i = 0; i < this.flakes.length; ++i) {
    if (this.flakes[i]) {
      this.flakes[i].y -= 0.10000000149011612;
      this.flakes[i].y < -100 && (this.flakes[i] = null);
    }
  }
}
;
_.lastUpdate = 0;
function SnowLayer$SnowFlake_0(){
  Math.random() * 200 + -100;
}

defineSeed(369, 1, makeCastMap([Q$SnowLayer$SnowFlake]), SnowLayer$SnowFlake_0);
_.y = 100;
defineSeed(372, 1, {});
function $update_6(this$static, f){
  this$static.time = add_4(this$static.time, f.elapsedTime);
  gte_0(this$static.time, this$static.duration_0)?(this$static.progress = 1):(this$static.progress = toDouble(this$static.time) / toDouble(this$static.duration_0));
}

function OneShotTimedAction_0(duration){
  this.duration_0 = duration;
}

defineSeed(371, 372, {}, OneShotTimedAction_0);
_.duration_0 = P0_longLit;
_.progress = 0;
_.time = P0_longLit;
function $update_7(this$static, f){
  if (this$static.goForward) {
    this$static.time = add_4(this$static.time, f.elapsedTime);
    if (gt(this$static.time, this$static.duration_0)) {
      this$static.time = this$static.duration_0;
      this$static.goForward = false;
    }
  }
   else {
    this$static.time = sub(this$static.time, f.elapsedTime);
    if (lt(this$static.time, P0_longLit)) {
      this$static.time = P0_longLit;
      this$static.goForward = true;
    }
  }
  this$static.progress = toDouble(this$static.time) / toDouble(this$static.duration_0);
}

function PingPongTimedAction_0(){
  this.duration_0 = P1dcd6500_longLit;
}

defineSeed(373, 372, {}, PingPongTimedAction_0);
_.duration_0 = P0_longLit;
_.goForward = true;
_.progress = 0;
_.time = P0_longLit;
function $loadControlsForAction(this$static, action){
  var name_0;
  name_0 = action.name_0;
  $setMainControl(action, $getControl(this$static.config, name_0 + '.main', action.controls[0]));
  $setAlternativeControl(action, $getControl(this$static.config, name_0 + '.alternative', action.controls[1]));
}

function $poll_0(this$static){
  $poll(this$static.menuOk);
  $poll(this$static.menuUp);
  $poll(this$static.menuDown);
  $poll(this$static.menuLeft);
  $poll(this$static.menuRight);
  $poll(this$static.jump);
  $poll(this$static.right);
  $poll(this$static.rotateClockwise);
  $poll(this$static.rotateCounterClockwise);
  $poll(this$static.rotate90Clockwise);
  $poll(this$static.rotate90CounterClockwise);
  $poll(this$static.returnToMenu);
}

function $setup(this$static){
  var action, action$iterator;
  this$static.menuOk = new ActionActivatedDetector_0(this$static.toolkit.menuOK.action);
  this$static.menuUp = new ActionActivatedDetector_0(this$static.toolkit.menuUp.action);
  this$static.menuDown = new ActionActivatedDetector_0(this$static.toolkit.menuDown.action);
  this$static.menuLeft = new ActionActivatedDetector_0(this$static.toolkit.menuLeft.action);
  this$static.menuRight = new ActionActivatedDetector_0(this$static.toolkit.menuRight.action);
  this$static.jump = new ActionActivatedDetector_0(new Action_1('action.jump', initValues(_3Lim_bci_jnuit_controls_Control_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Control, [new KeyControl_0(this$static.controls, ($clinit_Key() , UP_1))])));
  this$static.left_0 = new ActionActivatedDetector_0(new Action_1('action.left', initValues(_3Lim_bci_jnuit_controls_Control_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Control, [new KeyControl_0(this$static.controls, LEFT_2)])));
  this$static.right = new ActionActivatedDetector_0(new Action_1('action.right', initValues(_3Lim_bci_jnuit_controls_Control_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Control, [new KeyControl_0(this$static.controls, RIGHT_2)])));
  this$static.rotateClockwise = new ActionActivatedDetector_0(new Action_1('action.rotate.clockwise', initValues(_3Lim_bci_jnuit_controls_Control_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Control, [new KeyControl_0(this$static.controls, C_0)])));
  this$static.rotateCounterClockwise = new ActionActivatedDetector_0(new Action_1('action.rotate.counterclockwise', initValues(_3Lim_bci_jnuit_controls_Control_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Control, [new KeyControl_0(this$static.controls, X)])));
  this$static.rotate90Clockwise = new ActionActivatedDetector_0(new Action_1('action.rotate.clockwise.90', initValues(_3Lim_bci_jnuit_controls_Control_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Control, [new KeyControl_0(this$static.controls, S)])));
  this$static.rotate90CounterClockwise = new ActionActivatedDetector_0(new Action_1('action.rotate.counterclockwise.90', initValues(_3Lim_bci_jnuit_controls_Control_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Control, [new KeyControl_0(this$static.controls, D)])));
  this$static.returnToMenu = new ActionActivatedDetector_0(new Action_1('action.returntomenu', initValues(_3Lim_bci_jnuit_controls_Control_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Control, [new KeyControl_0(this$static.controls, ESCAPE)])));
  this$static.cheatActivateAll = new ActionActivatedDetector_0(new Action_1('cheat.activate.all', initValues(_3Lim_bci_jnuit_controls_Control_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Control, [new KeyControl_0(this$static.controls, F8)])));
  this$static.cheatGetWorldMap = new ActionActivatedDetector_0(new Action_1('cheat.get.world.map', initValues(_3Lim_bci_jnuit_controls_Control_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Control, [new KeyControl_0(this$static.controls, F9)])));
  this$static.cheatGetCompass = new ActionActivatedDetector_0(new Action_1('cheat.get.compass', initValues(_3Lim_bci_jnuit_controls_Control_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Control, [new KeyControl_0(this$static.controls, F10)])));
  this$static.cheatGotoNextBonusLevel = new ActionActivatedDetector_0(new Action_1('cheat.goto.next.bonus.level', initValues(_3Lim_bci_jnuit_controls_Control_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Control, [new KeyControl_0(this$static.controls, F11)])));
  this$static.cheatGotoNextLevel = new ActionActivatedDetector_0(new Action_1('cheat.goto.next.level', initValues(_3Lim_bci_jnuit_controls_Control_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Control, [new KeyControl_0(this$static.controls, F12)])));
  this$static.cheatSetAllCompleted = new ActionActivatedDetector_0(new Action_1('cheat.set.all.completed', initValues(_3Lim_bci_jnuit_controls_Control_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Control, [new KeyControl_0(this$static.controls, F12)])));
  for (action$iterator = new AbstractList$IteratorImpl_0(new Arrays$ArrayList_0(initValues(_3Lim_bci_jnuit_controls_Action_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Action, [this$static.left_0.action, this$static.right.action, this$static.jump.action, this$static.rotateClockwise.action, this$static.rotateCounterClockwise.action, this$static.rotate90Clockwise.action, this$static.rotate90CounterClockwise.action, this$static.returnToMenu.action]))); action$iterator.i < action$iterator.this$0_0.size_0();) {
    action = $next_2(action$iterator);
    $loadControlsForAction(this$static, action);
  }
  for (action$iterator = new AbstractList$IteratorImpl_0($getMenuActionList(this$static.toolkit)); action$iterator.i < action$iterator.this$0_0.size_0();) {
    action = $next_2(action$iterator);
    $loadControlsForAction(this$static, action);
  }
}

defineSeed(374, 1, {});
_.cheatActivateAll = null;
_.cheatGetCompass = null;
_.cheatGetWorldMap = null;
_.cheatGotoNextBonusLevel = null;
_.cheatGotoNextLevel = null;
_.cheatSetAllCompleted = null;
_.config = null;
_.jump = null;
_.left_0 = null;
_.menuDown = null;
_.menuLeft = null;
_.menuOk = null;
_.menuRight = null;
_.menuUp = null;
_.returnToMenu = null;
_.right = null;
_.rotate90Clockwise = null;
_.rotate90CounterClockwise = null;
_.rotateClockwise = null;
_.rotateCounterClockwise = null;
_.toolkit = null;
function $fileExists(this$static, path){
  return this$static.assetsList.contains_0(path);
}

function $getLevelFilePath(this$static, questName, levelName, filename){
  var file;
  file = 'quests/' + questName + '/levels/' + levelName + '/' + filename;
  if (this$static.assetsList.contains_0(file)) {
    return file;
  }
  file = 'quests/' + questName + '/' + filename;
  if (this$static.assetsList.contains_0(file)) {
    return file;
  }
  return 'default_level_data/' + filename;
}

function $initQuests(this$static){
  var file, file$iterator, questConfig, questName;
  $getText(this$static.assets, 'quests/quests.json', new PlaynGameData$1_0(this$static));
  for (file$iterator = this$static.assetsList.iterator_0(); file$iterator.hasNext();) {
    file = file$iterator.next_0();
    if ($endsWith(file, 'quest.json')) {
      questConfig = new PlaynGameData$QuestConfig_0;
      questName = $replace_0(file, '/quest.json', '');
      questName = $substring_0(questName, questName.lastIndexOf('/') + 1, questName.length);
      this$static.questsConfig.quests.put(questName, questConfig);
      $getText(this$static.assets, file, new PlaynGameData$2_0(questConfig));
    }
  }
}

function $isReady(this$static){
  return $isDone(this$static.assets) && !this$static.assetsList.isEmpty() && $isReady_0(this$static.questsConfig);
}

function $listQuestLevels(this$static, questName){
  return this$static.questsConfig.quests.get_1(questName).levels;
}

function $listQuestsToCompleteToUnlockQuest(this$static, questName){
  return this$static.questsConfig.quests.get_1(questName).lockedBy;
}

function $openLevelTmx(this$static, questName, levelName){
  var map, tmxDir, tmxFile, tsxDir;
  map = new TmxMap_0;
  tmxDir = 'quests/' + questName + '/levels/' + levelName;
  tsxDir = 'quests/' + questName;
  tmxFile = tmxDir + '/' + levelName + '.tmx';
  $getText(this$static.assets, tmxFile, new PlaynGameData$4_0(this$static, map, tsxDir));
  return map;
}

function PlaynGameData_0(assets){
  this.assetsList = ($clinit_Collections() , $clinit_Collections() , EMPTY_SET);
  this.questsConfig = new PlaynGameData$QuestsConfig_0;
  this.assets = assets;
  $getText(this.assets, 'assets.txt', new PlaynGameData$3_0(this));
}

defineSeed(375, 1, {}, PlaynGameData_0);
_.assets = null;
function $onSuccess(this$static, result){
  var questName, questName$iterator;
  for (questName$iterator = new JsonTypedArray$8_0($getArray($parse(result), Ljava_lang_String_2_classLit)); questName$iterator.index_0 < questName$iterator.this$0.array.length;) {
    questName = $next_9(questName$iterator);
    $add_0(this$static.this$0.questsConfig.visibleQuests, questName);
  }
  this$static.this$0.questsConfig.ready_0 = true;
}

function PlaynGameData$1_0(this$0){
  this.this$0 = this$0;
}

defineSeed(376, 1, {}, PlaynGameData$1_0);
_.onFailure = function onFailure(cause){
}
;
_.onSuccess = function onSuccess(result){
  $onSuccess(this, result);
}
;
_.this$0 = null;
function $onSuccess_0(this$static, result){
  var json, levelName, levelName$iterator, lockQuestName, lockQuestName$iterator, lockedBy;
  json = $parse(result);
  for (levelName$iterator = new JsonTypedArray$8_0(new JsonTypedArray_0(json['levels'] instanceof Array?json['levels']:null, Ljava_lang_String_2_classLit)); levelName$iterator.index_0 < levelName$iterator.this$0.array.length;) {
    levelName = $next_9(levelName$iterator);
    $add_0(this$static.val$questConfig.levels, levelName);
  }
  lockedBy = new JsonTypedArray_0(json['lockedBy'] instanceof Array?json['lockedBy']:null, Ljava_lang_String_2_classLit);
  if (lockedBy) {
    for (lockQuestName$iterator = new JsonTypedArray$8_0(lockedBy); lockQuestName$iterator.index_0 < lockQuestName$iterator.this$0.array.length;) {
      lockQuestName = $next_9(lockQuestName$iterator);
      $add_0(this$static.val$questConfig.lockedBy, lockQuestName);
    }
  }
  this$static.val$questConfig.ready_0 = true;
}

function PlaynGameData$2_0(val$questConfig){
  this.val$questConfig = val$questConfig;
}

defineSeed(377, 1, {}, PlaynGameData$2_0);
_.onFailure = function onFailure_0(cause){
}
;
_.onSuccess = function onSuccess_0(result){
  $onSuccess_0(this, result);
}
;
_.val$questConfig = null;
--></script>
<script><!--
function $onSuccess_1(this$static, result){
  var newAssets, s, s$array, s$index, s$max;
  newAssets = new HashSet_0;
  for (s$array = $split(result, '[\r\n]+', 0) , s$index = 0 , s$max = s$array.length; s$index < s$max; ++s$index) {
    s = s$array[s$index];
    !s.length || $add_11(newAssets, s);
  }
  this$static.this$0.assetsList = newAssets;
  $initQuests(this$static.this$0);
}

function PlaynGameData$3_0(this$0){
  this.this$0 = this$0;
}

defineSeed(378, 1, {}, PlaynGameData$3_0);
_.onFailure = function onFailure_1(cause){
}
;
_.onSuccess = function onSuccess_1(result){
  $onSuccess_1(this, result);
}
;
_.this$0 = null;
function $loadNextTileset(this$static){
  var tileset, tileset$iterator, tsxFile;
  for (tileset$iterator = new AbstractList$IteratorImpl_0(this$static.val$map.tilesets); tileset$iterator.i < tileset$iterator.this$0_0.size_0();) {
    tileset = $next_2(tileset$iterator);
    if (!tileset.ready_0 && null != tileset.source) {
      tsxFile = this$static.val$tsxDir + '/' + $replaceAll(tileset.source, '../', '');
      $getText(this$static.this$0.assets, tsxFile, new PlaynGameData$4$1_0(this$static, this$static.val$map, tileset, this$static.val$tsxDir));
      return;
    }
  }
  $decode(this$static.val$map);
}

function PlaynGameData$4_0(this$0, val$map, val$tsxDir){
  this.this$0 = this$0;
  this.val$map = val$map;
  this.val$tsxDir = val$tsxDir;
}

defineSeed(379, 1, {}, PlaynGameData$4_0);
_.onFailure = function onFailure_2(cause){
}
;
_.onSuccess = function onSuccess_2(result){
  $parseTmx(this.val$map, result);
  $loadNextTileset(this);
}
;
_.this$0 = null;
_.val$map = null;
_.val$tsxDir = null;
function $onSuccess_2(this$static, result){
  var tile, tile$iterator;
  $parseTsx(this$static.val$map, this$static.val$tileset, result);
  for (tile$iterator = new AbstractList$IteratorImpl_0(this$static.val$tileset.tiles); tile$iterator.i < tile$iterator.this$0_0.size_0();) {
    tile = $next_2(tile$iterator);
    $setSource(tile.frame.image, this$static.val$tsxDir + '/' + tile.frame.image.source);
  }
  $loadNextTileset(this$static.this$1);
}

function PlaynGameData$4$1_0(this$1, val$map, val$tileset, val$tsxDir){
  this.this$1 = this$1;
  this.val$map = val$map;
  this.val$tileset = val$tileset;
  this.val$tsxDir = val$tsxDir;
}

defineSeed(380, 1, {}, PlaynGameData$4$1_0);
_.onFailure = function onFailure_3(cause){
}
;
_.onSuccess = function onSuccess_3(result){
  $onSuccess_2(this, result);
}
;
_.this$1 = null;
_.val$map = null;
_.val$tileset = null;
_.val$tsxDir = null;
function PlaynGameData$QuestConfig_0(){
  this.levels = new ArrayList_0;
  this.lockedBy = new ArrayList_0;
}

defineSeed(381, 1, {}, PlaynGameData$QuestConfig_0);
_.ready_0 = false;
function $areQuestReady(this$static){
  var conf, conf$iterator;
  for (conf$iterator = $iterator_0($values(this$static.quests)); conf$iterator.val$outerIter.hasNext();) {
    conf = $next_4(conf$iterator);
    if (!conf.ready_0) {
      return false;
    }
  }
  return true;
}

function $isReady_0(this$static){
  return this$static.ready_0 && $areQuestReady(this$static);
}

function PlaynGameData$QuestsConfig_0(){
  this.quests = new HashMap_0;
  this.visibleQuests = new ArrayList_0;
}

defineSeed(382, 1, {}, PlaynGameData$QuestsConfig_0);
_.ready_0 = false;
function $getMousePos(this$static){
  $pollPointer(this$static.controls, platform_1.graphics.width_2(), platform_1.graphics.height_2(), this$static.pointer);
  $setY(this$static.pointer, platform_1.graphics.height_2() - this$static.pointer.y);
  return new Vector2f_1(this$static.pointer.x, this$static.pointer.y);
}

function $isMouseButtonDown(this$static){
  $pollPointer(this$static.controls, platform_1.graphics.width_2(), platform_1.graphics.height_2(), this$static.pointer);
  return this$static.pointer.down;
}

function PlaynGameInput_0(toolkit, config, controls){
  this.config = config;
  this.toolkit = toolkit;
  this.pointer = new Pointer_0;
  this.controls = controls;
}

defineSeed(383, 374, {}, PlaynGameInput_0);
_.controls = null;
function $doDrawMenuSequence(this$static, sequence){
  var b, b$iterator, background, scaleX, scaleY, screenH, screenW;
  this$static.surface.save_1();
  screenW = this$static.surface.width_1();
  screenH = this$static.surface.height_1();
  scaleX = screenW / 1280;
  scaleY = screenH / 800;
  this$static.surface.scale_3(scaleX, scaleY);
  background = $getBackgroundImage(sequence);
  background?this$static.surface.drawImage_4(background.image, sequence.backgroundX1, 800 - sequence.backgroundY1, sequence.backgroundX2 - sequence.backgroundX1, sequence.backgroundY1 - sequence.backgroundY2):this$static.surface.clear_2();
  for (b$iterator = new AbstractList$IteratorImpl_0(sequence.buttons); b$iterator.i < b$iterator.this$0_0.size_0();) {
    b = $next_2(b$iterator);
    b.draw();
  }
  this$static.surface.restore_1();
}

function $drawAxe(this$static, axe, texture){
  var box, h_0, image, w;
  if (texture) {
    box = axe.shape;
    image = texture.image.image;
    w = box.size.x;
    h_0 = box.size.y;
    this$static.surface.save_1();
    this$static.surface.translate_2(axe.position_0.x, axe.position_0.y);
    this$static.surface.rotate_1(axe.rotation);
    this$static.surface.scale_3(1, -1);
    this$static.surface.drawImage_5(image, -w / 2, -h_0 / 2, w, h_0, texture.u1 * image.width_1(), texture.v1 * image.height_1(), (texture.u2 - texture.u1) * image.width_1(), (texture.v2 - texture.v1) * image.height_1());
    this$static.surface.restore_1();
  }
}

function $drawAxeAnchor(this$static, axeAnchor, radius, texture){
  var image;
  if (texture) {
    image = texture.image.image;
    this$static.surface.save_1();
    this$static.surface.translate_2(axeAnchor.position_0.x, axeAnchor.position_0.y);
    this$static.surface.rotate_1(axeAnchor.rotation);
    this$static.surface.scale_3(1, -1);
    this$static.surface.drawImage_5(image, -radius, -radius, 2 * radius, 2 * radius, 0.18000000715255737 * image.width_1(), 0.20000000298023224 * image.height_1(), 0.6200000047683716 * image.width_1(), 0.6000000238418579 * image.height_1());
    this$static.surface.restore_1();
  }
}

function $drawBat(this$static, bat, scale, texture){
  var h_0, image, size, w;
  if (texture) {
    size = getSize(bat.shape);
    image = texture.image.image;
    w = size.x;
    h_0 = size.y;
    this$static.surface.save_1();
    this$static.surface.translate_2(bat.position_0.x, bat.position_0.y);
    this$static.surface.rotate_1(bat.rotation);
    this$static.surface.scale_3(scale, -scale);
    this$static.surface.drawImage_5(image, -w / 2, -h_0 / 2, w, h_0, texture.u1 * image.width_1(), texture.v1 * image.height_1(), (texture.u2 - texture.u1) * image.width_1(), (texture.v2 - texture.v1) * image.height_1());
    this$static.surface.restore_1();
  }
}

function $drawBlocker(this$static, blocker, alpha){
  this$static.surface.setAlpha_0(alpha);
  $drawPlatform(this$static, blocker);
  this$static.surface.setAlpha_0(1);
}

function $drawBomb(this$static, bomb, texture){
  var h_0, image, size, w;
  if (texture) {
    size = getSize(bomb.shape);
    image = texture.image.image;
    w = size.x;
    h_0 = size.y;
    this$static.surface.save_1();
    this$static.surface.translate_2(bomb.position_0.x, bomb.position_0.y);
    this$static.surface.rotate_1(bomb.rotation);
    this$static.surface.scale_3(1, -1);
    this$static.surface.drawImage_5(image, -w / 2, -h_0 / 2, w, h_0, texture.u1 * image.width_1(), texture.v1 * image.height_1(), (texture.u2 - texture.u1) * image.width_1(), (texture.v2 - texture.v1) * image.height_1());
    this$static.surface.restore_1();
  }
}

function $drawBoss(this$static, boss, texture){
  var h_0, image, size, w;
  if (texture) {
    size = getSize(boss.shape);
    image = texture.image.image;
    w = size.x;
    h_0 = size.y;
    this$static.surface.save_1();
    this$static.surface.translate_2(boss.position_0.x, boss.position_0.y);
    this$static.surface.rotate_1(boss.rotation);
    this$static.surface.scale_3(1, -1);
    this$static.surface.drawImage_5(image, -w / 2, -h_0 / 2, w, h_0, texture.u1 * image.width_1(), texture.v1 * image.height_1(), (texture.u2 - texture.u1) * image.width_1(), (texture.v2 - texture.v1) * image.height_1());
    this$static.surface.restore_1();
  }
}

function $drawBossHand(this$static, boss, texture){
  var h_0, image, size, w;
  if (texture) {
    size = getSize(boss.shape);
    image = texture.image.image;
    w = size.x;
    h_0 = size.y;
    this$static.surface.save_1();
    this$static.surface.translate_2(boss.position_0.x, boss.position_0.y);
    this$static.surface.rotate_1(boss.rotation);
    this$static.surface.scale_3(1, -1);
    this$static.surface.drawImage_5(image, -w / 2, -h_0 / 2, w, h_0, texture.u1 * image.width_1(), texture.v1 * image.height_1(), (texture.u2 - texture.u1) * image.width_1(), (texture.v2 - texture.v1) * image.height_1());
    this$static.surface.restore_1();
  }
}

function $drawButton(this$static, button){
  var texture;
  texture = button.on?button.onTexture:button.offTexture;
  !!texture && this$static.surface.drawImage_4(texture.image, button.x, button.y, button.w > 0?button.w:round_int(texture.image.width_1()), button.h_0 > 0?button.h_0:round_int(texture.image.height_1()));
}

function $drawCloud(this$static, cloud, alpha){
  this$static.surface.setAlpha_0(alpha);
  $drawPlatform(this$static, cloud);
  this$static.surface.setAlpha_0(1);
}

function $drawDoor(this$static, door, texture){
  var box, h_0, image, w, x, y;
  if (texture) {
    box = door.shape;
    image = texture.image.image;
    w = box.size.x;
    h_0 = box.size.y;
    x = door.position_0.x - w;
    y = door.position_0.y + h_0 / 2;
    this$static.surface.save_1();
    this$static.surface.translate_2(x, y);
    this$static.surface.scale_3(1, -1);
    this$static.surface.drawImage_5(image, 0, 0, w, h_0, texture.u1 * image.width_1(), texture.v1 * image.height_1(), (texture.u2 - texture.u1) * image.width_1(), (texture.v2 - texture.v1) * image.height_1());
    this$static.surface.restore_1();
  }
}

function $drawExplosion(this$static, explosion, texture, world){
  var image;
  if (texture) {
    image = texture.image.image;
    this$static.surface.save_1();
    this$static.surface.translate_2(explosion.position_0.x, explosion.position_0.y);
    this$static.surface.rotate_1(world.gravityAngle);
    this$static.surface.scale_3(1, -1);
    this$static.surface.drawImage_5(image, -1, -1, 2, 2, texture.u1 * image.width_1(), texture.v1 * image.height_1(), (texture.u2 - texture.u1) * image.width_1(), (texture.v2 - texture.v1) * image.height_1());
    this$static.surface.restore_1();
  }
}

function $drawFPS(this$static, nbFps){
  ($clinit_Boolean() , $equalsIgnoreCase('true', $getSystemOrStoreProperty('tweaks.show.fps', 'false'))?TRUE:FALSE).value_0 && $drawRighAlignedText(this$static, nbFps + ' FPS', this$static.surface.width_1() - 1, 0);
}

function $drawFadeSequence(this$static, loadingPlay){
  var image, loadingFrame;
  loadingFrame = loadingPlay.animation.getFrame(loadingPlay.currentFrameIndex);
  if (loadingFrame) {
    image = loadingFrame.image.image;
    image.isReady() && this$static.surface.drawImage_5(image, this$static.surface.width_1() * 0.800000011920929, this$static.surface.height_1() * 0.800000011920929, this$static.surface.width_1() * 0.20000000298023224, this$static.surface.height_1() * 0.20000000298023224, loadingFrame.u1 * image.width_1(), loadingFrame.v1 * image.height_1(), (loadingFrame.u2 - loadingFrame.u1) * image.width_1(), (loadingFrame.v2 - loadingFrame.v1) * image.height_1());
  }
}

function $drawFireBall(this$static, fireball, texture){
  var h_0, image, size, w;
  if (texture) {
    size = getSize(fireball.shape);
    image = texture.image.image;
    w = size.x;
    h_0 = size.y;
    this$static.surface.save_1();
    this$static.surface.translate_2(fireball.position_0.x, fireball.position_0.y);
    this$static.surface.rotate_1(fireball.rotation);
    this$static.surface.scale_3(1, -1);
    this$static.surface.drawImage_5(image, -w / 2, -h_0 / 2, w, h_0, texture.u1 * image.width_1(), texture.v1 * image.height_1(), (texture.u2 - texture.u1) * image.width_1(), (texture.v2 - texture.v1) * image.height_1());
    this$static.surface.restore_1();
  }
}

function $drawHero(this$static, hero, texture, world){
  var bounds, color, image, p, r, scale, x1, y1;
  if (texture) {
    if (hero) {
      bounds = hero.shape.getBounds();
      r = world.gravityAngle;
      scale = 1;
      if (world.hero.dyingTimedAction) {
        p = world.hero.dyingTimedAction.progress;
        if (p >= 0.5) {
          p -= 0.5;
          p *= 2;
          r += 500 * p;
          scale += Math.sin(p * 1.5 * 3.141592653589793) * 4;
          if (scale < 0) {
            return;
          }
        }
      }
      this$static.surface.save_1();
      this$static.surface.translate_2(hero.position_0.x, hero.position_0.y);
      this$static.surface.rotate_1(r);
      this$static.surface.scale_3(scale, -scale);
      x1 = -bounds.width_0 / 2;
      y1 = -bounds.height_0 / 2;
      image = texture.image.image;
      (hero.currentMovement == 0 || hero.currentMovement == 2 && hero.previousMovement == 0) && this$static.surface.scale_3(-1, 1);
      color = hero.color;
      this$static.surface.setTint(-16777216 | round_int(color.r * 255) << 16 | round_int(color.g * 255) << 8 | round_int(color.r * 255));
      this$static.surface.drawImage_5(image, x1, y1, bounds.width_0, bounds.height_0, texture.u1 * image.width_1(), texture.v1 * image.height_1(), (texture.u2 - texture.u1) * image.width_1(), (texture.v2 - texture.v1) * image.height_1());
      this$static.surface.setTint(-1);
      this$static.surface.restore_1();
    }
  }
}

function $drawKey(this$static, key, texture, world){
  var bounds, color, h_0, image, w;
  if (texture) {
    bounds = key.shape.getBounds();
    image = texture.image.image;
    w = bounds.width_0;
    h_0 = bounds.height_0;
    this$static.surface.save_1();
    this$static.surface.translate_2(key.position_0.x, key.position_0.y);
    this$static.surface.rotate_1(world.gravityAngle);
    this$static.surface.scale_3(1, -1);
    color = key.color;
    this$static.surface.setTint(-16777216 | round_int(color.r * 255) << 16 | round_int(color.g * 255) << 8 | round_int(color.r * 255));
    this$static.surface.drawImage_5(image, -w / 2, -h_0 / 2, w, h_0, texture.u1 * image.width_1(), texture.v1 * image.height_1(), (texture.u2 - texture.u1) * image.width_1(), (texture.v2 - texture.v1) * image.height_1());
    this$static.surface.setTint(-1);
    this$static.surface.restore_1();
  }
}

function $drawKeyLock(this$static, keyLock, alpha){
  this$static.surface.setAlpha_0(alpha);
  $drawPlatform(this$static, keyLock);
  this$static.surface.setAlpha_0(1);
}

function $drawLosedApple(this$static, apple, world, texture, alpha){
  var image, w;
  if (texture) {
    image = texture.image.image;
    w = apple.size;
    this$static.surface.save_1();
    this$static.surface.setAlpha_0(alpha);
    this$static.surface.translate_2(apple.position_0.x, apple.position_0.y);
    this$static.surface.rotate_1(world.gravityAngle);
    this$static.surface.scale_3(1, -1);
    this$static.surface.drawImage_5(image, -w / 2, -w / 2, w, w, texture.u1 * image.width_1(), texture.v1 * image.height_1(), (texture.u2 - texture.u1) * image.width_1(), (texture.v2 - texture.v1) * image.height_1());
    this$static.surface.setAlpha_0(1);
    this$static.surface.restore_1();
  }
}

function $drawMenuButton(this$static, button, leftLabel, rightLabel){
  $drawButton(this$static, button);
  $drawText_0(this$static, leftLabel, button.x, button.y + 186.6666717529297);
  $drawRighAlignedText(this$static, rightLabel, button.x + 550, button.y + 186.6666717529297);
}

function $drawMinimap(this$static, world, minimapTexture){
  var key, key$iterator, minimapSize;
  if (!world.hero.hasMap && !world.hero.hasCompass) {
    return;
  }
  minimapSize = 0.30000001192092896 * this$static.surface.width_1();
  this$static.surface.save_1();
  this$static.surface.translate_2(this$static.surface.width_1() - minimapSize / 1.5, this$static.surface.height_1() - minimapSize / 1.5);
  this$static.surface.save_1();
  this$static.surface.rotate_1(world.gravityAngle);
  if (world.hero.hasMap) {
    this$static.surface.drawImage_4(minimapTexture.image, -minimapSize / 2, -minimapSize / 2, minimapSize, minimapSize);
  }
   else {
    this$static.surface.setFillColor_0(-8355712);
    this$static.surface.setAlpha_0(0.5);
    this$static.surface.fillRect_1(-minimapSize / 2, -minimapSize / 2, minimapSize, minimapSize);
    this$static.surface.setAlpha_0(1);
    this$static.surface.setFillColor_0(-16777216);
  }
  if (world.hero.hasCompass) {
    $drawMinimapIcon(this$static, world, world.hero.position_0, $getCurrentFrame(world.hero.play_0), minimapSize);
    for (key$iterator = new AbstractList$IteratorImpl_0(world.keys); key$iterator.i < key$iterator.this$0_0.size_0();) {
      key = $next_2(key$iterator);
      $drawMinimapIcon(this$static, world, key.position_0, $getCurrentFrame(key.play_0), minimapSize);
    }
  }
  this$static.surface.restore_1();
}

function $drawMinimapIcon(this$static, world, worldPos, texture, minimapSize){
  var image, miniMapPlatformSize;
  if (texture) {
    this$static.surface.save_1();
    miniMapPlatformSize = minimapSize * 4 / 256;
    this$static.surface.scale_3(miniMapPlatformSize / 2, -miniMapPlatformSize / 2);
    this$static.surface.translate_2(worldPos.x, worldPos.y);
    this$static.surface.rotate_1(world.gravityAngle);
    this$static.surface.scale_3(1, -1);
    image = texture.image.image;
    this$static.surface.drawImage_5(image, -4, -4, 8, 8, texture.u1 * image.width_1(), texture.v1 * image.height_1(), (texture.u2 - texture.u1) * image.width_1(), (texture.v2 - texture.v1) * image.height_1());
    this$static.surface.restore_1();
  }
}

function $drawMobilePikeAnchor(this$static, anchor, texture){
  var bounds, h_0, image, w;
  if (texture) {
    bounds = anchor.shape.getBounds();
    w = bounds.width_0;
    h_0 = bounds.height_0;
    image = texture.image.image;
    this$static.surface.save_1();
    this$static.surface.translate_2(anchor.position_0.x, anchor.position_0.y);
    this$static.surface.rotate_1(anchor.rotation);
    this$static.surface.scale_3(1, -1);
    this$static.surface.drawImage_5(image, -w / 2, -h_0 / 2, w, h_0, 0.18000000715255737 * image.width_1(), 0.20000000298023224 * image.height_1(), 0.6200000047683716 * image.width_1(), 0.6000000238418579 * image.height_1());
    this$static.surface.restore_1();
  }
}

function $drawMobilePikes(this$static, pikes, texture){
  var box, h_0, image, w;
  if (texture) {
    box = pikes.shape;
    image = texture.image.image;
    w = box.size.x;
    h_0 = box.size.y;
    this$static.surface.save_1();
    this$static.surface.translate_2(pikes.position_0.x, pikes.position_0.y);
    this$static.surface.rotate_1(pikes.rotation);
    this$static.surface.scale_3(1, -1);
    this$static.surface.drawImage_5(image, -w / 2, -h_0 / 2, w, h_0, texture.u1 * image.width_1(), texture.v1 * image.height_1(), (texture.u2 - texture.u1) * image.width_1(), (texture.v2 - texture.v1) * image.height_1());
    this$static.surface.restore_1();
  }
}

function $drawMovingPlatform(this$static, platform, texture){
  var h_0, image, size, w;
  if (texture) {
    size = getSize(platform.shape);
    image = texture.image.image;
    w = size.x;
    h_0 = size.y;
    this$static.surface.save_1();
    this$static.surface.translate_2(platform.position_0.x, platform.position_0.y);
    this$static.surface.rotate_1(platform.rotation);
    this$static.surface.scale_3(1, -1);
    this$static.surface.drawImage_5(image, -w / 2, -h_0 / 2, w, h_0, texture.u1 * image.width_1(), texture.v1 * image.height_1(), (texture.u2 - texture.u1) * image.width_1(), (texture.v2 - texture.v1) * image.height_1());
    this$static.surface.restore_1();
  }
}

function $drawMummy(this$static, mummy, texture, scale){
  var h_0, image, size, w;
  if (texture) {
    size = getSize(mummy.shape);
    image = texture.image.image;
    w = size.x;
    h_0 = size.y;
    this$static.surface.save_1();
    this$static.surface.translate_2(mummy.position_0.x, mummy.position_0.y);
    this$static.surface.rotate_1(mummy.rotation);
    this$static.surface.scale_3(mummy.currentMovement == 0 || mummy.currentMovement == 2 && mummy.previousMovement == 0?-scale:scale, -scale);
    this$static.surface.drawImage_5(image, -w / 2, -h_0 / 2, w, h_0, texture.u1 * image.width_1(), texture.v1 * image.height_1(), (texture.u2 - texture.u1) * image.width_1(), (texture.v2 - texture.v1) * image.height_1());
    this$static.surface.restore_1();
  }
}

function $drawPickableObject(this$static, pickable, texture, world){
  var bounds, h_0, image, w;
  if (texture) {
    bounds = pickable.shape.getBounds();
    image = texture.image.image;
    w = bounds.width_0;
    h_0 = bounds.height_0;
    this$static.surface.save_1();
    this$static.surface.translate_2(pickable.position_0.x, pickable.position_0.y);
    this$static.surface.rotate_1(world.gravityAngle);
    this$static.surface.scale_3(1, -1);
    this$static.surface.drawImage_5(image, -w / 2, -h_0 / 2, w, h_0, texture.u1 * image.width_1(), texture.v1 * image.height_1(), (texture.u2 - texture.u1) * image.width_1(), (texture.v2 - texture.v1) * image.height_1());
    this$static.surface.restore_1();
  }
}

function $drawPickedUpObject(this$static, apple, world, texture){
  var image, w;
  if (texture) {
    image = texture.image.image;
    w = apple.size;
    this$static.surface.save_1();
    this$static.surface.translate_2(apple.position_0.x, apple.position_0.y);
    this$static.surface.rotate_1(world.gravityAngle);
    this$static.surface.scale_3(1, -1);
    this$static.surface.drawImage_5(image, -w / 2, -w / 2, w, w, texture.u1 * image.width_1(), texture.v1 * image.height_1(), (texture.u2 - texture.u1) * image.width_1(), (texture.v2 - texture.v1) * image.height_1());
    this$static.surface.restore_1();
  }
}

function $drawPlatform(this$static, platform){
  var h_0, image, size, texture, w;
  texture = platform.frame;
  if (texture) {
    size = getSize(platform.shape);
    image = texture.image.image;
    w = size.x;
    h_0 = size.y;
    this$static.surface.save_1();
    this$static.surface.translate_2(platform.position_0.x, platform.position_0.y);
    this$static.surface.rotate_1(platform.rotation);
    this$static.surface.scale_3(1, -1);
    this$static.surface.drawImage_5(image, -w / 2, -h_0 / 2, w, h_0, texture.u1 * image.width_1(), texture.v1 * image.height_1(), (texture.u2 - texture.u1) * image.width_1(), (texture.v2 - texture.v1) * image.height_1());
    this$static.surface.restore_1();
  }
}

function $drawRighAlignedText(this$static, text, x, y){
  var textLayout;
  if (text.length) {
    textLayout = $layoutText(platform_1.graphics, text, this$static.textFormat);
    $drawText_1(this$static, textLayout, x - (max_0(textLayout.bounds.x, 0) + textLayout.bounds.width_0), y);
  }
}

function $drawScoreSequence(this$static, sequence, questScore, scorePerCentToShow){
  var levelEntry, levelEntry$iterator, scores;
  $doDrawMenuSequence(this$static, sequence);
  scores = new StringBuilder_1('SCORES\n');
  for (levelEntry$iterator = new TreeMap$EntryIterator_0((new TreeMap$EntrySet_0(questScore)).this$0); $hasNext_0(levelEntry$iterator.iter);) {
    levelEntry = levelEntry$iterator.last = $next_2(levelEntry$iterator.iter);
    $append_12($append_10($append_12($append_12((scores.impl.string += ' ' , scores), levelEntry.getKey()), ': '), div(mul(scorePerCentToShow, fromInt($computeScore(levelEntry.getValue()))), P64_longLit)), '\n');
  }
  $append_10((scores.impl.string += 'TOTAL: ' , scores), div(mul(scorePerCentToShow, fromInt($computeScore_0(questScore))), P64_longLit));
  $drawText_0(this$static, scores.impl.string, 0, 0);
}

function $drawStaticPlatforms(this$static, drawable){
  var h_0, image, indices, platform, platform$iterator, size, useTriangles, w;
  image = drawable.texture.image;
  useTriangles = !!platform_1.graphics.ctx_0();
  if (useTriangles) {
    if (image.isReady()) {
      this$static.surface.setFillPattern_0(image.toPattern());
      indices = initDim(_3I_classLit, makeCastMap([Q$int_$1, Q$Serializable]), -1, drawable.indicesLimit, 1);
      arraycopy(drawable.indices, 0, indices, 0, drawable.indicesLimit);
      this$static.surface.fillTriangles(drawable.vertices, drawable.texCoords, indices);
    }
  }
   else {
    for (platform$iterator = new AbstractList$IteratorImpl_0(drawable.platforms); platform$iterator.i < platform$iterator.this$0_0.size_0();) {
      platform = $next_2(platform$iterator);
      size = getSize(platform.shape);
      w = size.x;
      h_0 = size.y;
      this$static.surface.save_1();
      this$static.surface.translate_2(platform.position_0.x, platform.position_0.y);
      this$static.surface.rotate_1(platform.rotation);
      this$static.surface.scale_3(1, -1);
      this$static.surface.drawImage_5(image, -w / 2, -h_0 / 2, w, h_0, platform.u1 * image.width_1(), platform.v1 * image.height_1(), (platform.u2 - platform.u1) * image.width_1(), (platform.v2 - platform.v1) * image.height_1());
      this$static.surface.restore_1();
    }
  }
}

function $drawText_0(this$static, text, x, y){
  var textLayout;
  if (text.length) {
    textLayout = $layoutText(platform_1.graphics, text, this$static.textFormat);
    $drawText_1(this$static, textLayout, x, y);
  }
}

function $drawText_1(this$static, textLayout, x, y){
  var canvas, textImage;
  textImage = $createImage(platform_1.graphics, max_0(textLayout.bounds.x, 0) + textLayout.bounds.width_0, 0.699999988079071 * textLayout.metrics.height_0 + $descent(textLayout.metrics));
  canvas = textImage.canvas;
  $setFillStyleWeb(canvas.ctx, cssColorString(-1));
  $fill_0(textLayout, canvas.ctx);
  canvas.isDirty = true;
  this$static.surface.drawImage_3(textImage, x, y);
}

function $drawUsedKey(this$static, key, texture, world){
  var image, w;
  if (texture) {
    image = texture.image.image;
    w = key.size;
    this$static.surface.save_1();
    this$static.surface.translate_2(key.position_0.x, key.position_0.y);
    this$static.surface.rotate_1(world.gravityAngle);
    this$static.surface.scale_3(1, -1);
    this$static.surface.drawImage_5(image, -w / 2, -w / 2, w, w, texture.u1 * image.width_1(), texture.v1 * image.height_1(), (texture.u2 - texture.u1) * image.width_1(), (texture.v2 - texture.v1) * image.height_1());
    this$static.surface.restore_1();
  }
}

function $drawWorld(this$static, world){
  var body, cameraSize, drawableBodies, drawableBody, drawableBody$iterator, heroPos, i, visibleBodies, v, drawable;
  this$static.surface.save_1();
  $setOrtho2D(this$static.surface);
  ($clinit_Boolean() , $equalsIgnoreCase('true', $getSystemOrStoreProperty('tweaks.rotate.view.with.gravity', 'true'))?TRUE:FALSE).value_0 && this$static.surface.rotate_1(-world.gravityAngle);
  $drawWorldBackground(this$static, world);
  heroPos = world.hero.position_0;
  this$static.surface.translate_2(-heroPos.x, -heroPos.y);
  cameraSize = Math.sqrt(3200);
  visibleBodies = $getVisibleBodies(world, heroPos.x - cameraSize, heroPos.y - cameraSize, heroPos.x + cameraSize, heroPos.y + cameraSize);
  drawableBodies = new ArrayList_0;
  $resetVisibles(world.staticPlatformDrawer);
  for (i = 0; i < visibleBodies.elements.size; ++i) {
    body = $get(visibleBodies.elements, i);
    instanceOf(body, Q$Drawable) && $add_0(drawableBodies, body);
    instanceOf(body, Q$StaticPlatform) && (v = body.vertexBufferIndex * 4 , drawable = body.drawable , drawable.indices[drawable.indicesLimit++] = v , drawable.indices[drawable.indicesLimit++] = v + 1 , drawable.indices[drawable.indicesLimit++] = v + 2 , drawable.indices[drawable.indicesLimit++] = v , drawable.indices[drawable.indicesLimit++] = v + 2 , drawable.indices[drawable.indicesLimit++] = v + 3 , undefined);
  }
  $getVisibleDrawables(world.staticPlatformDrawer, drawableBodies);
  sort_1(drawableBodies, ($clinit_Drawable() , comparator));
  for (drawableBody$iterator = new AbstractList$IteratorImpl_0(drawableBodies); drawableBody$iterator.i < drawableBody$iterator.this$0_0.size_0();) {
    drawableBody = $next_2(drawableBody$iterator);
    drawableBody.draw();
  }
  $draw(world.topLevelEntities);
  this$static.surface.restore_1();
}

--></script>
<script><!--
function $drawWorldBackground(this$static, world){
  var backgroundTexture, color, heroPos, icolor, staticBounds, worldStaticBounds, xt, yt;
  backgroundTexture = world.backgroundTexture;
  if (backgroundTexture) {
    this$static.surface.save_1();
    this$static.surface.scale_3(1, -1);
    heroPos = world.hero.position_0;
    color = 1;
    if (world.hero.dyingTimedAction) {
      color -= world.hero.dyingTimedAction.progress * 2;
      color <= 0 && (color = 0);
    }
    icolor = round_int(255 * color);
    this$static.surface.setTint(-16777216 | icolor << 16 | icolor << 8 | icolor);
    worldStaticBounds = world.collisionStrategy?$getStaticBounds(world.collisionStrategy):null;
    staticBounds = new AbsoluteAABox_0;
    staticBounds.x1 = -40;
    staticBounds.x2 = 40;
    staticBounds.y1 = -40;
    staticBounds.y2 = 40;
    xt = -heroPos.x * ((staticBounds.x2 - staticBounds.x1) / (worldStaticBounds.x2 - worldStaticBounds.x1));
    yt = -heroPos.y * ((staticBounds.y2 - staticBounds.y1) / (worldStaticBounds.y2 - worldStaticBounds.y1));
    xt *= 0.10000000149011612;
    yt *= 0.10000000149011612;
    xt = xt > -10?xt:-10;
    xt = xt < 10?xt:10;
    yt = yt > -10?yt:-10;
    yt = yt < 10?yt:10;
    staticBounds.x1 += xt;
    staticBounds.x2 += xt;
    staticBounds.y1 += yt;
    staticBounds.y2 += yt;
    this$static.surface.drawImage_4(backgroundTexture.image, staticBounds.x1, staticBounds.y1, staticBounds.x2 - staticBounds.x1, staticBounds.y2 - staticBounds.y1);
    this$static.surface.setTint(-1);
    this$static.surface.restore_1();
  }
}

function $loadFromAnimation(this$static, filename){
  var nanim;
  if ($endsWith(filename, '.json')) {
    return nanim = new AnimationCollection_0 , $getText(this$static.assets, filename, new PlaynGameView$1_0(this$static, filename, nanim)) , nanim;
  }
   else if ($endsWith(filename, '.png')) {
    return new AnimationCollection_1($getTexture(this$static.textureCache, filename));
  }
   else {
    throw new RuntimeException_1('Unknow animation format of ' + filename);
  }
}

function $setCurrentSurface(this$static, currentSurface){
  this$static.surface = currentSurface;
}

function $setOrtho2D(surface){
  var aspectRatio, scaleX, scaleY, screenH, screenW;
  screenW = surface.width_1();
  screenH = surface.height_1();
  aspectRatio = screenW / screenH;
  scaleX = screenW / (aspectRatio * 40);
  scaleY = screenH / 40;
  surface.translate_2(screenW / 2, screenH / 2);
  surface.scale_3(scaleX, -scaleY);
}

function PlaynGameView_0(assets){
  this.assets = assets;
  this.textFormat = new TextFormat_0(new HtmlFont_0('monospaced', ($clinit_Font$Style() , BOLD_0), 24));
  this.textureCache = new PlaynTextureCache_0(assets);
}

defineSeed(384, 1, {}, PlaynGameView_0);
_.assets = null;
_.surface = null;
_.textFormat = null;
_.textureCache = null;
function $onSuccess_3(this$static, result){
  var $e0, a, animation, f, imageFilename, json, jsonAnimation, jsonAnimations, jsonFrame, jsonFrames, lastIndexOfSlash, na, nf, path, texture;
  try {
    lastIndexOfSlash = this$static.val$filename.lastIndexOf('/');
    lastIndexOfSlash < 0?(path = ''):(path = $substring_0(this$static.val$filename, 0, this$static.val$filename.lastIndexOf('/') + 1));
    json = $parse(result);
    jsonAnimations = json['animations'] instanceof Array?json['animations']:null;
    for (a = 0 , na = jsonAnimations.length; a < na; ++a) {
      jsonAnimation = isValueObject(jsonAnimations[a])?jsonAnimations[a]:null;
      animation = new Animation_0(typeof jsonAnimation['name'] == 'string'?jsonAnimation['name']:null);
      jsonFrames = jsonAnimation['frames'] instanceof Array?jsonAnimation['frames']:null;
      for (f = 0 , nf = jsonFrames.length; f < nf; ++f) {
        jsonFrame = isValueObject(jsonFrames[f])?jsonFrames[f]:null;
        imageFilename = typeof jsonFrame['image'] == 'string'?jsonFrame['image']:null;
        texture = $getTexture(this$static.this$0.textureCache, path + imageFilename);
        $addFrame(animation, texture, fromInt(~~Math.max(Math.min(typeof jsonFrame['duration'] == 'number'?jsonFrame['duration']:0, 2147483647), -2147483648)), typeof jsonFrame['u1'] == 'number'?jsonFrame['u1']:0, typeof jsonFrame['v1'] == 'number'?jsonFrame['v1']:0, typeof jsonFrame['u2'] == 'number'?jsonFrame['u2']:0, typeof jsonFrame['v2'] == 'number'?jsonFrame['v2']:0);
      }
      $addAnimation(this$static.val$nanim, animation);
    }
    this$static.val$nanim.ready_0 = true;
  }
   catch ($e0) {
    $e0 = caught_0($e0);
    if (!instanceOf($e0, Q$Exception))
      throw $e0;
  }
}

function PlaynGameView$1_0(this$0, val$filename, val$nanim){
  this.this$0 = this$0;
  this.val$filename = val$filename;
  this.val$nanim = val$nanim;
}

defineSeed(385, 1, {}, PlaynGameView$1_0);
_.onFailure = function onFailure_4(cause){
}
;
_.onSuccess = function onSuccess_4(result){
  $onSuccess_3(this, result);
}
;
_.this$0 = null;
_.val$filename = null;
_.val$nanim = null;
function $tick_0(this$static, elapsed){
  var nextUpdate, updateRate, updates;
  nextUpdate = this$static.nextUpdate;
  updateRate = this$static.updateRate;
  updates = 0;
  while (elapsed >= nextUpdate) {
    nextUpdate += updateRate;
    ++updates;
  }
  updates > 0 && (elapsed = $tick_1(platform_1));
  this$static.nextUpdate = nextUpdate;
}

defineSeed(387, 1, {});
_.nextUpdate = 0;
_.updateRate = 0;
function $init(this$static){
  var $e0, ex, immediateLayer;
  try {
    this$static.platform = new PlaynPlatformSpecific_0;
    immediateLayer = platform_1.graphics.createImmediateLayer(new PlaynNewtonAdventureGame$2_0(this$static));
    platform_1.graphics.rootLayer_0().add_1(immediateLayer);
  }
   catch ($e0) {
    $e0 = caught_0($e0);
    if (instanceOf($e0, Q$Exception)) {
      ex = $e0;
      throw new RuntimeException_2('Error during init', ex);
    }
     else 
      throw $e0;
  }
}

defineSeed(386, 387, {});
_.game = null;
_.platform = null;
function $render_0(this$static, surface){
  var $e0, ex;
  try {
    if ($isDone(this$static.this$0.platform.assets)) {
      if (!this$static.this$0.game) {
        if ($isReady(this$static.this$0.platform.data)) {
          this$static.this$0.game = new Game_0(this$static.this$0.platform);
          $start(this$static.this$0.game);
        }
      }
       else if (this$static.this$0.game.running) {
        $setSurface(this$static.this$0.platform.toolkit.renderer, surface);
        $setCurrentSurface(this$static.this$0.game.view, surface);
        $tick(this$static.this$0.game);
      }
    }
  }
   catch ($e0) {
    $e0 = caught_0($e0);
    if (instanceOf($e0, Q$Exception)) {
      ex = $e0;
      throw new RuntimeException_2('Error during update', ex);
    }
     else 
      throw $e0;
  }
}

function PlaynNewtonAdventureGame$2_0(this$0){
  this.this$0 = this$0;
}

defineSeed(388, 1, {}, PlaynNewtonAdventureGame$2_0);
_.this$0 = null;
function PlaynPlatformSpecific_0(){
  var controls, font, translator;
  this.assets = new RealWatchedAssets_0(new CachingAssets_0(platform_1.assets));
  this.data = new PlaynGameData_0(this.assets);
  controls = new PlaynNuitControls_0;
  font = new PlaynNuitFont_0(($clinit_Font$Style() , BOLD_0));
  translator = new NewtonAdventureNuitTranslator_0;
  this.toolkit = new NuitToolkit_0(controls, translator, font, new PlaynNuitRenderer_0(translator, font), new PlaynNuitAudio_0);
  this.config = new PlaynNuitPreferences_0(controls);
  this.gameView = new PlaynGameView_0(this.assets);
  this.input = new PlaynGameInput_0(this.toolkit, this.config, controls);
  $setup(this.input);
}

defineSeed(389, 1, {}, PlaynPlatformSpecific_0);
_.config = null;
_.gameView = null;
_.input = null;
_.toolkit = null;
function $clinit_PlaynStaticPlatformDrawable(){
  $clinit_PlaynStaticPlatformDrawable = nullMethod;
  COMPARATOR = new PlaynStaticPlatformDrawable$1_0;
}

function $addStaticPlatform(this$static, platform, verticesBuffer, texCoordsBuffer){
  var i, nbPoints, point, points, shape;
  $add_0(this$static.platforms, platform);
  platform.drawable = this$static;
  shape = platform.shape;
  points = getVertices(shape, platform.position_0, platform.rotation);
  nbPoints = min_0(points.length, verticesBuffer.capacity);
  for (i = 0; i < nbPoints; ++i) {
    point = points[i];
    $put_1(verticesBuffer, point.x);
    $put_1(verticesBuffer, point.y);
  }
  $put_1(texCoordsBuffer, platform.u1);
  $put_1(texCoordsBuffer, platform.v2);
  $put_1(texCoordsBuffer, platform.u2);
  $put_1(texCoordsBuffer, platform.v2);
  $put_1(texCoordsBuffer, platform.u2);
  $put_1(texCoordsBuffer, platform.v1);
  $put_1(texCoordsBuffer, platform.u1);
  $put_1(texCoordsBuffer, platform.v1);
}

function $addStaticPlatforms(this$static, platforms){
  var i, nb, platform, texCoordsBuffer, verticesBuffer;
  nb = platforms.size_0();
  verticesBuffer = allocate(nb * 2 * 4);
  texCoordsBuffer = allocate(nb * 2 * 4);
  this$static.indices = initDim(_3I_classLit, makeCastMap([Q$int_$1, Q$Serializable]), -1, nb * 6, 1);
  for (i = 0; i < nb; ++i) {
    platform = platforms.get(i);
    platform.vertexBufferIndex = i;
    $addStaticPlatform(this$static, platform, verticesBuffer, texCoordsBuffer);
  }
  this$static.vertices = initDim(_3F_classLit, makeCastMap([Q$Serializable]), -1, nb * 2 * 4, 1);
  $flip(verticesBuffer);
  $get_4(verticesBuffer, this$static.vertices);
  this$static.texCoords = initDim(_3F_classLit, makeCastMap([Q$Serializable]), -1, nb * 2 * 4, 1);
  $flip(texCoordsBuffer);
  $get_4(texCoordsBuffer, this$static.texCoords);
}

function PlaynStaticPlatformDrawable_0(){
  this.platforms = new ArrayList_0;
}

function create_8(view, platforms){
  $clinit_PlaynStaticPlatformDrawable();
  var drawable, p, partitionedPlatforms, partitionedPlatforms$iterator, result;
  result = new ArrayList_0;
  sort_1(platforms, COMPARATOR);
  for (partitionedPlatforms$iterator = new AbstractList$IteratorImpl_0(partition(platforms)); partitionedPlatforms$iterator.i < partitionedPlatforms$iterator.this$0_0.size_0();) {
    partitionedPlatforms = $next_2(partitionedPlatforms$iterator);
    if (!partitionedPlatforms.isEmpty()) {
      drawable = new PlaynStaticPlatformDrawable_0;
      p = partitionedPlatforms.get(0);
      drawable.view = view;
      drawable.texture = p.texture;
      drawable.zOrder = p.zOrder;
      $addStaticPlatforms(drawable, partitionedPlatforms);
      setCheck(result.array, result.size++, drawable);
    }
  }
  return result;
}

function partition(platforms){
  var currentPlatforms, platform, platform$iterator, previousPlatform, result;
  result = new ArrayList_0;
  previousPlatform = null;
  currentPlatforms = null;
  for (platform$iterator = new AbstractList$IteratorImpl_0(platforms); platform$iterator.i < platform$iterator.this$0_0.size_0();) {
    platform = $next_2(platform$iterator);
    if (!currentPlatforms || 0 != $compare_0(previousPlatform, platform)) {
      currentPlatforms = new ArrayList_0;
      setCheck(result.array, result.size++, currentPlatforms);
    }
    setCheck(currentPlatforms.array, currentPlatforms.size++, platform);
    previousPlatform = platform;
  }
  return result;
}

defineSeed(390, 1, {}, PlaynStaticPlatformDrawable_0);
_.draw = function draw_11(){
  $drawStaticPlatforms(this.view, this);
}
;
_.getZOrder = function getZOrder_2(){
  return this.zOrder;
}
;
_.indices = null;
_.indicesLimit = 0;
_.texCoords = null;
_.texture = null;
_.vertices = null;
_.view = null;
_.zOrder = 0;
var COMPARATOR;
function $compare_0(o1, o2){
  var result, texture1, texture2, z1, z2;
  z1 = o1.zOrder;
  z2 = o2.zOrder;
  result = 0;
  z1 < z2?(result = -1):z1 > z2 && (result = 1);
  if (result == 0) {
    texture1 = o1.texture;
    texture2 = o2.texture;
    result = compareTo_7(texture1.name_0, texture2.name_0);
  }
  return result;
}

function PlaynStaticPlatformDrawable$1_0(){
}

defineSeed(391, 1, {}, PlaynStaticPlatformDrawable$1_0);
_.compare = function compare_1(o1, o2){
  return $compare_0(o1, o2);
}
;
function $add_7(this$static, platform){
  $add_0(this$static.platforms, platform);
}

function $getVisibleDrawables(this$static, visibleDrawables){
  var drawable, drawable$iterator;
  for (drawable$iterator = new AbstractList$IteratorImpl_0(this$static.drawables); drawable$iterator.i < drawable$iterator.this$0_0.size_0();) {
    drawable = $next_2(drawable$iterator);
    drawable.indicesLimit > 0 && (setCheck(visibleDrawables.array, visibleDrawables.size++, drawable) , true);
  }
}

function $postConstruct(this$static, view){
  this$static.drawables = create_8(view, this$static.platforms);
  $clear(this$static.platforms);
}

function $resetVisibles(this$static){
  var drawable, drawable$iterator;
  for (drawable$iterator = new AbstractList$IteratorImpl_0(this$static.drawables); drawable$iterator.i < drawable$iterator.this$0_0.size_0();) {
    drawable = $next_2(drawable$iterator);
    drawable.indicesLimit = 0;
  }
}

function PlaynStaticPlatformDrawer_0(){
  this.platforms = new ArrayList_0;
}

defineSeed(392, 1, {}, PlaynStaticPlatformDrawer_0);
_.drawables = null;
function PlaynTexture_0(name_0, image){
  this.name_0 = name_0;
  this.image = image;
}

defineSeed(393, 1, {}, PlaynTexture_0);
_.toString$ = function toString_18(){
  return this.name_0;
}
;
_.image = null;
_.name_0 = null;
function $getTexture(this$static, name_0){
  return new PlaynTexture_0(name_0, $getImage(this$static.assets, name_0));
}

function PlaynTextureCache_0(assets){
  this.assets = assets;
}

defineSeed(394, 1, {}, PlaynTextureCache_0);
_.assets = null;
function $getImage(this$static, path){
  var image;
  ++this$static.totalRequestsCount;
  image = $getImage_0(this$static.delegate, path);
  image.addCallback(this$static.callback);
  return image;
}

function $getText(this$static, path, textCallback){
  ++this$static.totalRequestsCount;
  $getText_0(this$static.delegate, path, new RealWatchedAssets$2_0(this$static, textCallback));
}

function $isDone(this$static){
  return this$static.totalRequestsCount == this$static.successCount + this$static.errorsCount;
}

function RealWatchedAssets_0(delegate){
  this.callback = new RealWatchedAssets$1_0(this);
  this.delegate = delegate;
}

defineSeed(395, 1, {}, RealWatchedAssets_0);
_.delegate = null;
_.errorsCount = 0;
_.successCount = 0;
_.totalRequestsCount = 0;
function $onFailure(this$static){
  ++this$static.this$0.errorsCount;
}

function $onSuccess_4(this$static){
  ++this$static.this$0.successCount;
}

function RealWatchedAssets$1_0(this$0){
  this.this$0 = this$0;
}

defineSeed(396, 1, {}, RealWatchedAssets$1_0);
_.onFailure = function onFailure_5(e){
  $onFailure(this);
}
;
_.onSuccess = function onSuccess_5(resource){
  $onSuccess_4(this);
}
;
_.this$0 = null;
function $onFailure_0(this$static, cause){
  this$static.val$textCallback.onFailure(cause);
  ++this$static.this$0.errorsCount;
}

function $onSuccess_5(this$static, result){
  this$static.val$textCallback.onSuccess(result);
  ++this$static.this$0.successCount;
}

function RealWatchedAssets$2_0(this$0, val$textCallback){
  this.this$0 = this$0;
  this.val$textCallback = val$textCallback;
}

defineSeed(397, 1, {}, RealWatchedAssets$2_0);
_.onFailure = function onFailure_6(cause){
  $onFailure_0(this, cause);
}
;
_.onSuccess = function onSuccess_6(result){
  this.val$textCallback.onSuccess(result);
  ++this.this$0.successCount;
}
;
_.this$0 = null;
_.val$textCallback = null;
function PlaynNewtonAdventureGameHtml$1_0(){
  this.updateRate = 16;
}

defineSeed(400, 386, {}, PlaynNewtonAdventureGameHtml$1_0);
function $getQuestScore(this$static, questName){
  var score;
  score = $get_1(this$static.questScores, questName);
  if (!score) {
    score = new QuestScore_0;
    $put_0(this$static.questScores, questName, score);
  }
  return score;
}

function $setLevelScore(this$static, questName, levelName, score){
  var questScore, currentScore;
  questScore = $getQuestScore(this$static, questName);
  currentScore = $get_1(questScore, levelName);
  (!currentScore || score.nbKilledMummy * 3 + score.nbKilledBat * 4 + score.nbKilledEgyptianBoss * 10 + score.nbCoin * 5 + score.nbApple + score.nbLosedApple * -2 > currentScore.nbKilledMummy * 3 + currentScore.nbKilledBat * 4 + currentScore.nbKilledEgyptianBoss * 10 + currentScore.nbCoin * 5 + currentScore.nbApple + currentScore.nbLosedApple * -2) && $put_0(questScore, levelName, score);
}

function GameScore_0(){
  this.questScores = new TreeMap_0;
}

defineSeed(401, 1, makeCastMap([Q$Serializable]), GameScore_0);
function $addApple(this$static, n){
  this$static.nbApple += n;
}

function $addLosedApple(this$static, n){
  this$static.nbLosedApple += n;
}

function $computeScore(this$static){
  return this$static.nbKilledMummy * 3 + this$static.nbKilledBat * 4 + this$static.nbKilledEgyptianBoss * 10 + this$static.nbCoin * 5 + this$static.nbApple + this$static.nbLosedApple * -2;
}

function LevelScore_0(){
}

defineSeed(402, 1, makeCastMap([Q$Serializable]), LevelScore_0);
_.nbApple = 0;
_.nbCoin = 0;
_.nbKilledBat = 0;
_.nbKilledEgyptianBoss = 0;
_.nbKilledMummy = 0;
_.nbLosedApple = 0;
function $clinit_TreeMap(){
  $clinit_TreeMap = nullMethod;
  DEFAULT_COMPARATOR = new TreeMap$1_0;
}

function $clear_2(this$static){
  this$static.root = null;
  this$static.size = 0;
}

function $get_1(this$static, k){
  var entry;
  entry = $getEntry(this$static, k);
  return entry?entry.value_0:null;
}

function $getEntry(this$static, key){
  var c, tree;
  tree = this$static.root;
  while (tree) {
    c = $compare_2(key, tree.key_0);
    if (c == 0) {
      return tree;
    }
    c < 0?(tree = tree.child[0]):(tree = tree.child[1]);
  }
  return null;
}

function $insert_0(this$static, tree, newNode, state){
  var c, childNum;
  if (!tree) {
    return newNode;
  }
   else {
    c = $compare_2(tree.key_0, newNode.key_0);
    if (c == 0) {
      state.value_0 = tree.value_0;
      state.found = true;
      tree.value_0 = newNode.value_0;
      return tree;
    }
    childNum = c > 0?0:1;
    tree.child[childNum] = $insert_0(this$static, tree.child[childNum], newNode, state);
    if ($isRed(tree.child[childNum])) {
      if ($isRed(tree.child[1 - childNum])) {
        tree.isRed = true;
        tree.child[0].isRed = false;
        tree.child[1].isRed = false;
      }
       else {
        $isRed(tree.child[childNum].child[childNum])?(tree = $rotateSingle(tree, 1 - childNum)):$isRed(tree.child[childNum].child[1 - childNum]) && (tree = (tree.child[1 - (1 - childNum)] = $rotateSingle(tree.child[1 - (1 - childNum)], 1 - (1 - childNum)) , $rotateSingle(tree, 1 - childNum)));
      }
    }
  }
  return tree;
}

function $isRed(node){
  return !!node && node.isRed;
}

function $put_0(this$static, key, value){
  var node, state;
  node = new TreeMap$Node_0(key, value);
  state = new TreeMap$State_0;
  this$static.root = $insert_0(this$static, this$static.root, node, state);
  state.found || ++this$static.size;
  this$static.root.isRed = false;
  return state.value_0;
}

function $remove_8(this$static, keyObj){
  var state;
  state = new TreeMap$State_0;
  $removeWithState(this$static, keyObj, state);
  return state.value_0;
}

function $removeWithState(this$static, key, state){
  var c, dir, dir2, found, grandparent, head, last, newNode, node, parent_0, sibling;
  if (!this$static.root) {
    return false;
  }
  found = null;
  parent_0 = null;
  head = new TreeMap$Node_0(null, null);
  dir = 1;
  head.child[1] = this$static.root;
  node = head;
  while (node.child[dir]) {
    last = dir;
    grandparent = parent_0;
    parent_0 = node;
    node = node.child[dir];
    c = $compare_2(node.key_0, key);
    dir = c < 0?1:0;
    c == 0 && (!state.matchValue || equals__devirtual$(node.value_0, state.value_0)) && (found = node);
    if (!(!!node && node.isRed) && !$isRed(node.child[dir])) {
      if ($isRed(node.child[1 - dir])) {
        parent_0 = parent_0.child[last] = $rotateSingle(node, dir);
      }
       else if (!$isRed(node.child[1 - dir])) {
        sibling = parent_0.child[1 - last];
        if (sibling) {
          if (!$isRed(sibling.child[1 - last]) && !$isRed(sibling.child[last])) {
            parent_0.isRed = false;
            sibling.isRed = true;
            node.isRed = true;
          }
           else {
            dir2 = grandparent.child[1] == parent_0?1:0;
            $isRed(sibling.child[last])?(grandparent.child[dir2] = (parent_0.child[1 - last] = $rotateSingle(parent_0.child[1 - last], 1 - last) , $rotateSingle(parent_0, last))):$isRed(sibling.child[1 - last]) && (grandparent.child[dir2] = $rotateSingle(parent_0, last));
            node.isRed = grandparent.child[dir2].isRed = true;
            grandparent.child[dir2].child[0].isRed = false;
            grandparent.child[dir2].child[1].isRed = false;
          }
        }
      }
    }
  }
  if (found) {
    state.found = true;
    state.value_0 = found.value_0;
    if (node != found) {
      newNode = new TreeMap$Node_0(node.key_0, node.value_0);
      $replaceNode(this$static, head, found, newNode);
      parent_0 == found && (parent_0 = newNode);
    }
    parent_0.child[parent_0.child[1] == node?1:0] = node.child[!node.child[0]?1:0];
    --this$static.size;
  }
  this$static.root = head.child[1];
  !!this$static.root && (this$static.root.isRed = false);
  return state.found;
}

function $replaceNode(this$static, head, node, newNode){
  var direction, parent_0;
  parent_0 = head;
  direction = parent_0.key_0 == null || $compare_2(node.key_0, parent_0.key_0) > 0?1:0;
  while (parent_0.child[direction] != node) {
    parent_0 = parent_0.child[direction];
    direction = $compare_2(node.key_0, parent_0.key_0) > 0?1:0;
  }
  parent_0.child[direction] = newNode;
  newNode.isRed = node.isRed;
  newNode.child[0] = node.child[0];
  newNode.child[1] = node.child[1];
  node.child[0] = null;
  node.child[1] = null;
}

function $rotateSingle(tree, rotateDirection){
  var save;
  save = tree.child[1 - rotateDirection];
  tree.child[1 - rotateDirection] = save.child[rotateDirection];
  save.child[rotateDirection] = tree;
  tree.isRed = true;
  save.isRed = false;
  return save;
}

function TreeMap_0(){
  $clinit_TreeMap();
  TreeMap_1.call(this, null);
}

function TreeMap_1(c){
  this.root = null;
  !c && (c = DEFAULT_COMPARATOR);
  this.cmp = c;
}

defineSeed(404, 198, makeCastMap([Q$Serializable, Q$Map]), TreeMap_0);
_.containsKey = function containsKey_1(key){
  return !!$getEntry(this, key);
}
;
_.entrySet_0 = function entrySet_1(){
  return new TreeMap$EntrySet_0(this);
}
;
_.get_1 = function get_10(k){
  return $get_1(this, k);
}
;
_.put = function put_1(key, value){
  return $put_0(this, key, value);
}
;
_.remove_1 = function remove_11(keyObj){
  return $remove_8(this, keyObj);
}
;
_.size_0 = function size_4(){
  return this.size;
}
;
_.cmp = null;
_.root = null;
_.size = 0;
var DEFAULT_COMPARATOR;
function $computeScore_0(this$static){
  var levelScore, levelScore$iterator, result;
  result = 0;
  for (levelScore$iterator = $iterator_0($values(this$static)); levelScore$iterator.val$outerIter.hasNext();) {
    levelScore = $next_4(levelScore$iterator);
    result += levelScore.nbKilledMummy * 3 + levelScore.nbKilledBat * 4 + levelScore.nbKilledEgyptianBoss * 10 + levelScore.nbCoin * 5 + levelScore.nbApple + levelScore.nbLosedApple * -2;
  }
  return result;
}

function QuestScore_0(){
  $clinit_TreeMap();
  TreeMap_0.call(this);
}

defineSeed(403, 404, makeCastMap([Q$Serializable, Q$Map]), QuestScore_0);
function ModChooser_0(toolkit, possibleMods){
  Table_1.call(this);
  this.mods = new Select_1(toolkit, possibleMods);
  $cell(this, this.mods);
  $row(this.layout);
  $cell(this, new ModChooser$1_0(this, toolkit));
}

defineSeed(405, 292, {}, ModChooser_0);
_.mods = null;
function ModChooser$1_0(this$0, $anonymous0){
  this.this$0 = this$0;
  Button_0.call(this, $anonymous0, 'modchooser.back');
}

defineSeed(406, 299, {}, ModChooser$1_0);
_.onOK = function onOK_9(){
  $close(this.this$0);
}
;
_.this$0 = null;
function NewtonAdventureNuitTranslator_0(){
  NuitTranslator_0.call(this);
  $addTranslation(this, ($clinit_NuitLocale() , ENGLISH), 'options.video', 'VIDEO');
  $addTranslation(this, ENGLISH, 'options.audio', 'AUDIO');
  $addTranslation(this, ENGLISH, 'options.game.controls', 'GAME CONTROLS');
  $addTranslation(this, ENGLISH, 'options.menu.controls', 'MENU CONTROLS');
  $addTranslation(this, ENGLISH, 'options.language', 'LANGUAGE');
  $addTranslation(this, ENGLISH, 'options.tweaks', 'TWEAKS');
  $addTranslation(this, ENGLISH, 'options.mods', 'MODS');
  $addTranslation(this, ENGLISH, 'options.back', 'BACK');
  $addTranslation(this, ENGLISH, 'modchooser.back', 'BACK');
  $addTranslation(this, ENGLISH, 'tweaks.show.fps', 'Show FPS');
  $addTranslation(this, ENGLISH, 'tweaks.rotate.view.with.gravity', 'Rotate view with gravity');
  $addTranslation(this, ENGLISH, 'tweaks.back', 'BACK');
  $addTranslation(this, ENGLISH, 'action.jump', 'Jump');
  $addTranslation(this, ENGLISH, 'action.left', 'Left');
  $addTranslation(this, ENGLISH, 'action.right', 'Right');
  $addTranslation(this, ENGLISH, 'action.rotate.clockwise', 'Rotate clockwise');
  $addTranslation(this, ENGLISH, 'action.rotate.counterclockwise', 'Rotate counterclockwise');
  $addTranslation(this, ENGLISH, 'action.rotate.clockwise.90', 'Rotate clockwise 90');
  $addTranslation(this, ENGLISH, 'action.rotate.counterclockwise.90', 'Rotate counterclockwise 90');
  $addTranslation(this, ENGLISH, 'action.returntomenu', 'Menu');
  $addTranslation(this, FRENCH, 'options.video', 'VIDEO');
  $addTranslation(this, FRENCH, 'options.audio', 'AUDIO');
  $addTranslation(this, FRENCH, 'options.game.controls', 'CONTROLES DU JEU');
  $addTranslation(this, FRENCH, 'options.menu.controls', 'CONTROLES DES MENUS');
  $addTranslation(this, FRENCH, 'options.tweaks', 'AUTRES REGLAGES');
  $addTranslation(this, FRENCH, 'options.language', 'LANGUE');
  $addTranslation(this, FRENCH, 'options.mods', 'MODS');
  $addTranslation(this, FRENCH, 'options.back', 'RETOUR');
  $addTranslation(this, FRENCH, 'modchooser.back', 'RETOUR');
  $addTranslation(this, FRENCH, 'tweaks.show.fps', 'Afficher les FPS');
  $addTranslation(this, FRENCH, 'tweaks.rotate.view.with.gravity', 'Tourner la vue avec la gravit\xE9');
  $addTranslation(this, FRENCH, 'tweaks.back', 'RETOUR');
  $addTranslation(this, FRENCH, 'action.jump', 'Sauter');
  $addTranslation(this, FRENCH, 'action.left', 'Gauche');
  $addTranslation(this, FRENCH, 'action.right', 'Droite');
  $addTranslation(this, FRENCH, 'action.rotate.clockwise', 'Tourne (sens horaire)');
  $addTranslation(this, FRENCH, 'action.rotate.counterclockwise', 'Tourne (sens antihoraire)');
  $addTranslation(this, FRENCH, 'action.rotate.clockwise.90', 'Tourne (sens horaire 90)');
  $addTranslation(this, FRENCH, 'action.rotate.counterclockwise.90', 'Tourne (sens antihoraire 90)');
  $addTranslation(this, FRENCH, 'action.returntomenu', 'Menu');
}

defineSeed(407, 254, {}, NewtonAdventureNuitTranslator_0);
function $getSelectedModName(this$static){
  !!this$static.modChooser && $getSelected(this$static.modChooser.mods);
  return null;
}

--></script>
<script><!--
function OptionsGUI_0(toolkit, platform){
  var gameInput, mods, themer;
  Stack_0.call(this);
  themer = new Themer_0;
  $setBackground(this, new ColoredBackground_0(0, 0, 0, 1));
  this.videoConfigurator = new VideoConfigurator_0(toolkit);
  $theme(themer, this.videoConfigurator);
  this.audioConfigurator = new AudioConfigurator_0(toolkit);
  $theme(themer, this.audioConfigurator);
  gameInput = platform.input;
  this.gameControlsConfigurator = new ControlsConfigurator_0(toolkit, new Arrays$ArrayList_0(initValues(_3Lim_bci_jnuit_controls_Action_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Action, [gameInput.left_0.action, gameInput.right.action, gameInput.jump.action, gameInput.rotateClockwise.action, gameInput.rotateCounterClockwise.action, gameInput.rotate90Clockwise.action, gameInput.rotate90CounterClockwise.action, gameInput.returnToMenu.action])), new Arrays$ArrayList_0(initValues(_3Lim_bci_jnuit_controls_Action_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Action, [new Action_1('action.jump', initValues(_3Lim_bci_jnuit_controls_Control_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Control, [new KeyControl_0(gameInput.controls, ($clinit_Key() , UP_1))])), new Action_1('action.left', initValues(_3Lim_bci_jnuit_controls_Control_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Control, [new KeyControl_0(gameInput.controls, LEFT_2)])), new Action_1('action.right', initValues(_3Lim_bci_jnuit_controls_Control_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Control, [new KeyControl_0(gameInput.controls, RIGHT_2)])), new Action_1('action.rotate.clockwise', initValues(_3Lim_bci_jnuit_controls_Control_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Control, [new KeyControl_0(gameInput.controls, C_0)])), new Action_1('action.rotate.counterclockwise', initValues(_3Lim_bci_jnuit_controls_Control_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Control, [new KeyControl_0(gameInput.controls, X)])), new Action_1('action.rotate.clockwise.90', initValues(_3Lim_bci_jnuit_controls_Control_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Control, [new KeyControl_0(gameInput.controls, S)])), new Action_1('action.rotate.counterclockwise.90', initValues(_3Lim_bci_jnuit_controls_Control_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Control, [new KeyControl_0(gameInput.controls, D)])), new Action_1('action.returntomenu', initValues(_3Lim_bci_jnuit_controls_Control_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Control, [new KeyControl_0(gameInput.controls, ESCAPE)]))])));
  $theme(themer, this.gameControlsConfigurator);
  this.menuControlsConfigurator = new ControlsConfigurator_0(toolkit, new Arrays$ArrayList_0(initValues(_3Lim_bci_jnuit_controls_Action_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Action, [toolkit.menuUp.action, toolkit.menuDown.action, toolkit.menuLeft.action, toolkit.menuRight.action, toolkit.menuOK.action, toolkit.menuCancel.action])), new Arrays$ArrayList_0(initValues(_3Lim_bci_jnuit_controls_Action_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Action, [new Action_1('nuit.action.menu.up', $getDefaultMenuUpControls(toolkit.controls)), new Action_1('nuit.action.menu.down', $getDefaultMenuDownControls(toolkit.controls)), new Action_1('nuit.action.menu.left', $getDefaultMenuLeftControls(toolkit.controls)), new Action_1('nuit.action.menu.right', $getDefaultMenuRightControls(toolkit.controls)), new Action_1('nuit.action.menu.ok', $getDefaultMenuOkControls(toolkit.controls)), new Action_1('nuit.action.menu.cancel', $getDefaultMenuCancelControls(toolkit.controls))])));
  $theme(themer, this.menuControlsConfigurator);
  mods = new ArrayList_0;
  this.optionsMenu = new Table_1;
  $space(this.optionsMenu.layout.cellDefaults);
  $cell(this.optionsMenu, new OptionsGUI$2_0(this, toolkit));
  $row(this.optionsMenu.layout);
  $cell(this.optionsMenu, new OptionsGUI$3_0(this, toolkit));
  $row(this.optionsMenu.layout);
  $cell(this.optionsMenu, new OptionsGUI$4_0(this, toolkit));
  $row(this.optionsMenu.layout);
  if (mods.size != 0) {
    this.modChooser = new ModChooser_0(toolkit, mods);
    $theme(themer, this.modChooser);
    $cell(this.optionsMenu, new OptionsGUI$5_0(this, toolkit));
    $row(this.optionsMenu.layout);
  }
  $cell(this.optionsMenu, new OptionsGUI$6_0(this, toolkit, toolkit, platform, themer));
  $row(this.optionsMenu.layout);
  $cell(this.optionsMenu, new OptionsGUI$7_0(this, toolkit));
  $show(this, this.optionsMenu);
  $theme(themer, this.optionsMenu);
}

defineSeed(408, 310, {}, OptionsGUI_0);
_.audioConfigurator = null;
_.gameControlsConfigurator = null;
_.menuControlsConfigurator = null;
_.modChooser = null;
_.optionsMenu = null;
_.videoConfigurator = null;
function OptionsGUI$2_0(this$0, $anonymous0){
  this.this$0 = this$0;
  Button_0.call(this, $anonymous0, 'options.audio');
}

defineSeed(409, 299, {}, OptionsGUI$2_0);
_.onOK = function onOK_10(){
  $show(this.this$0, this.this$0.audioConfigurator);
}
;
_.this$0 = null;
function OptionsGUI$3_0(this$0, $anonymous0){
  this.this$0 = this$0;
  Button_0.call(this, $anonymous0, 'options.menu.controls');
}

defineSeed(410, 299, {}, OptionsGUI$3_0);
_.onOK = function onOK_11(){
  $show(this.this$0, this.this$0.menuControlsConfigurator);
}
;
_.this$0 = null;
function OptionsGUI$4_0(this$0, $anonymous0){
  this.this$0 = this$0;
  Button_0.call(this, $anonymous0, 'options.game.controls');
}

defineSeed(411, 299, {}, OptionsGUI$4_0);
_.onOK = function onOK_12(){
  $show(this.this$0, this.this$0.gameControlsConfigurator);
}
;
_.this$0 = null;
function OptionsGUI$5_0(this$0, $anonymous0){
  this.this$0 = this$0;
  Button_0.call(this, $anonymous0, 'options.mods');
}

defineSeed(412, 299, {}, OptionsGUI$5_0);
_.onOK = function onOK_13(){
  $show(this.this$0, this.this$0.modChooser);
}
;
_.this$0 = null;
function OptionsGUI$6_0(this$0, $anonymous0, val$toolkit, val$platform, val$themer){
  this.this$0 = this$0;
  this.val$toolkit = val$toolkit;
  this.val$platform = val$platform;
  this.val$themer = val$themer;
  Button_0.call(this, $anonymous0, 'options.tweaks');
}

defineSeed(413, 299, {}, OptionsGUI$6_0);
_.onOK = function onOK_14(){
  var tweaksGUI;
  tweaksGUI = new TweaksGUI_0(this.val$toolkit, this.val$platform);
  $theme(this.val$themer, tweaksGUI);
  $show(this.this$0, tweaksGUI);
}
;
_.this$0 = null;
_.val$platform = null;
_.val$themer = null;
_.val$toolkit = null;
function OptionsGUI$7_0(this$0, $anonymous0){
  this.this$0 = this$0;
  Button_0.call(this, $anonymous0, 'options.back');
}

defineSeed(414, 299, {}, OptionsGUI$7_0);
_.onOK = function onOK_15(){
  $close(this.this$0);
}
;
_.this$0 = null;
function $setNextSequence_2(this$static, mainMenuSequence){
  this$static.nextSequence = mainMenuSequence;
}

function OptionsSequence_0(platform){
  this.platform = platform;
}

defineSeed(415, 1, {}, OptionsSequence_0);
_.draw = function draw_12(){
  $render(this.toolkit.renderer, this.root);
}
;
_.processInputs = function processInputs_6(){
}
;
_.resume = function resume_4(){
}
;
_.start_2 = function start_16(){
  this.toolkit = this.platform.toolkit;
  this.optionsGui = new OptionsGUI_0(this.toolkit, this.platform);
  this.root = new Root_0(this.toolkit);
  $show(this.root, this.optionsGui);
}
;
_.stop_0 = function stop_10(){
  this.root = null;
  this.optionsGui = null;
  this.toolkit = null;
}
;
_.update_0 = function update_17(){
  $update(this.toolkit, this.root);
  $update_0(this.root, 0.01666666753590107);
  if (this.optionsGui != $getFocusedChild(this.root)) {
    $getSelectedModName(this.optionsGui);
    throw new Sequence$ResumeTransitionException_0(this.nextSequence);
  }
}
;
_.nextSequence = null;
_.optionsGui = null;
_.platform = null;
_.root = null;
_.toolkit = null;
function $clinit_Themer(){
  $clinit_Themer = nullMethod;
  BUTTON_FOCUSED_BACKGROUND = new ColoredBackground_0(0.6000000238418579, 0, 0, 1);
  BUTTON_FOCUS_CURSOR = new ColoredRectangleFocusCursor_0(1, 0, 0);
  SELECT_SUCKED_FOCUS_CURSOR = new ColoredRectangleFocusCursor_0(0.800000011920929, 0, 0);
  BUTTON_BACKGROUND = new ColoredBackground_0(0.30000001192092896, 0, 0, 1);
  YELLOW = new TextColor_0(0.8799999952316284, 0.11999999731779099);
}

function $theme(this$static, w){
  var child, child$iterator;
  if (w) {
    w.accept_1(this$static);
    for (child$iterator = new AbstractList$IteratorImpl_0(w.children); child$iterator.i < child$iterator.this$0_0.size_0();) {
      child = $next_2(child$iterator);
      $theme(this$static, child);
    }
  }
}

function Themer_0(){
  $clinit_Themer();
}

defineSeed(416, 1, {}, Themer_0);
_.visit = function visit_18(widget){
}
;
_.visit_0 = function visit_19(widget){
  $setBackground(widget, BUTTON_BACKGROUND);
  $setFocusedBackground(widget, BUTTON_FOCUSED_BACKGROUND);
  $setSuckedFocusedBackground(widget, BUTTON_FOCUSED_BACKGROUND);
  $setFocusCursor(widget, BUTTON_FOCUS_CURSOR);
  $setFocusedTextColor(widget, YELLOW);
}
;
_.visit_1 = function visit_20(widget){
}
;
_.visit_2 = function visit_21(widget){
}
;
_.visit_3 = function visit_22(widget){
}
;
_.visit_4 = function visit_23(widget){
}
;
_.visit_5 = function visit_24(widget){
  $setBackground(widget, BUTTON_BACKGROUND);
  $setFocusedBackground(widget, BUTTON_FOCUSED_BACKGROUND);
  $setSuckedFocusedBackground(widget, BUTTON_FOCUSED_BACKGROUND);
  $setFocusCursor(widget, BUTTON_FOCUS_CURSOR);
  $setSuckedFocusCursor(widget, SELECT_SUCKED_FOCUS_CURSOR);
  $setFocusedTextColor(widget, YELLOW);
}
;
_.visit_6 = function visit_25(widget){
}
;
_.visit_7 = function visit_26(widget){
}
;
_.visit_8 = function visit_27(widget){
  $setBackground(widget, BUTTON_BACKGROUND);
  $setFocusedBackground(widget, BUTTON_FOCUSED_BACKGROUND);
  $setSuckedFocusedBackground(widget, BUTTON_FOCUSED_BACKGROUND);
  $setFocusCursor(widget, BUTTON_FOCUS_CURSOR);
  $setFocusedTextColor(widget, YELLOW);
}
;
_.visit_9 = function visit_28(widget){
}
;
var BUTTON_BACKGROUND, BUTTON_FOCUSED_BACKGROUND, BUTTON_FOCUS_CURSOR, SELECT_SUCKED_FOCUS_CURSOR, YELLOW;
function TweaksGUI_0(toolkit){
  var mustDrawFps, rotateViewWithGravity;
  Table_1.call(this);
  $expand(this.layout.cellDefaults);
  $cell(this, new Label_0(toolkit, 'tweaks.show.fps'));
  mustDrawFps = new Toggle_0(toolkit);
  $setEnabled(mustDrawFps, ($clinit_Boolean() , $equalsIgnoreCase('true', $getSystemOrStoreProperty('tweaks.show.fps', 'false'))?TRUE:FALSE).value_0);
  $add_5(this, mustDrawFps);
  $add_1(this.layout, mustDrawFps);
  $row(this.layout);
  $cell(this, new Label_0(toolkit, 'tweaks.rotate.view.with.gravity'));
  rotateViewWithGravity = new Toggle_0(toolkit);
  $setEnabled(rotateViewWithGravity, ($equalsIgnoreCase('true', $getSystemOrStoreProperty('tweaks.rotate.view.with.gravity', 'true'))?TRUE:FALSE).value_0);
  $add_5(this, rotateViewWithGravity);
  $add_1(this.layout, rotateViewWithGravity);
  $row(this.layout);
  $cell(this, new TweaksGUI$1_0(this, toolkit, mustDrawFps, rotateViewWithGravity));
}

defineSeed(417, 292, {}, TweaksGUI_0);
function TweaksGUI$1_0(this$0, $anonymous0, val$mustDrawFps, val$rotateViewWithGravity){
  this.this$0 = this$0;
  this.val$mustDrawFps = val$mustDrawFps;
  this.val$rotateViewWithGravity = val$rotateViewWithGravity;
  Button_0.call(this, $anonymous0, 'tweaks.back');
}

defineSeed(418, 299, {}, TweaksGUI$1_0);
_.onOK = function onOK_16(){
  $putBoolean('tweaks.show.fps', this.val$mustDrawFps.enabled);
  $putBoolean('tweaks.rotate.view.with.gravity', this.val$rotateViewWithGravity.enabled);
  $close(this.this$0);
}
;
_.this$0 = null;
_.val$mustDrawFps = null;
_.val$rotateViewWithGravity = null;
function AbsoluteAABox_0(){
}

function AbsoluteAABox_1(other){
  this.x1 = other.x1;
  this.y1 = other.y1;
  this.x2 = other.x2;
  this.y2 = other.y2;
}

defineSeed(419, 1, {}, AbsoluteAABox_0, AbsoluteAABox_1);
_.x1 = 0;
_.x2 = 0;
_.y1 = 0;
_.y2 = 0;
function $hasNext(this$static){
  var i;
  for (i = 0; i < this$static.indexes.length; ++i) {
    if (this$static.indexes[i] != this$static.dimensions[i] - 1) {
      return true;
    }
  }
  return false;
}

function $next_1(this$static){
  var i;
  for (i = this$static.dimensions.length - 1; i >= 0; --i) {
    if (this$static.indexes[i] == this$static.dimensions[i] - 1) {
      this$static.indexes[i] = 0;
    }
     else {
      ++this$static.indexes[i];
      break;
    }
  }
  return this$static.indexes;
}

function MultidimensionnalIterator_0(dimensions){
  this.dimensions = dimensions;
  this.indexes = initDim(_3I_classLit, makeCastMap([Q$int_$1, Q$Serializable]), -1, dimensions.length, 1);
}

defineSeed(420, 1, {}, MultidimensionnalIterator_0);
_.dimensions = null;
_.indexes = null;
function $clinit_NewtonColor(){
  $clinit_NewtonColor = nullMethod;
  white = new NewtonColor_0('white', 0, 1, 1);
  red_0 = new NewtonColor_0('red', 1, 1, 0);
  green_0 = new NewtonColor_0('green', 2, 0, 1);
  blue_0 = new NewtonColor_0('blue', 3, 0, 0);
  $VALUES_18 = initValues(_3Lim_bci_newtonadv_util_NewtonColor_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$NewtonColor, [white, red_0, green_0, blue_0]);
}

function NewtonColor_0(enum$name, enum$ordinal, r, g){
  Enum_0.call(this, enum$name, enum$ordinal);
  this.r = r;
  this.g = g;
}

function valueOf_0(name_0){
  $clinit_NewtonColor();
  return valueOf(($clinit_NewtonColor$Map() , $MAP), name_0);
}

function values_19(){
  $clinit_NewtonColor();
  return $VALUES_18;
}

defineSeed(421, 11, makeCastMap([Q$NewtonColor, Q$Serializable, Q$Comparable, Q$Enum]), NewtonColor_0);
_.g = 0;
_.r = 0;
var $VALUES_18, blue_0, green_0, red_0, white;
function $clinit_NewtonColor$Map(){
  $clinit_NewtonColor$Map = nullMethod;
  $MAP = createValueOfMap(($clinit_NewtonColor() , $VALUES_18));
}

var $MAP;
function getSize(shape){
  var bounds, box, circle, diameter, height, i, line, maxX, maxY, minX, minY, polygon, vertices, width;
  if (instanceOf(shape, Q$Box)) {
    box = shape;
    return box.size;
  }
   else if (instanceOf(shape, Q$ConvexPolygon)) {
    polygon = shape;
    vertices = $getVertices(polygon);
    minX = vertices[0].x;
    maxX = vertices[0].x;
    minY = vertices[0].y;
    maxY = vertices[0].y;
    for (i = 1; i < vertices.length; ++i) {
      minX = min(minX, vertices[i].x);
      maxX = max_0(maxX, vertices[i].x);
      minY = min(minY, vertices[i].y);
      maxY = max_0(maxY, vertices[i].y);
    }
    return new Vector2f_1(maxX - minX, maxY - minY);
  }
   else if (instanceOf(shape, Q$Line)) {
    line = shape;
    width = abs(line.end.x - line.start.x);
    height = abs(line.end.y - line.start.y);
    return new Vector2f_1(width, height);
  }
   else if (instanceOf(shape, Q$Circle)) {
    circle = shape;
    diameter = circle.radius * 2;
    return new Vector2f_1(diameter, diameter);
  }
   else {
    bounds = shape.getBounds();
    return new Vector2f_1(bounds.width_0, bounds.height_0);
  }
}

function getVertices(shape, position, rotation){
  var bounds, box, height, i, line, maxX, maxY, minX, minY, polygon, vertices, width;
  if (instanceOf(shape, Q$Box)) {
    box = shape;
    return $getPoints(box, position, rotation);
  }
   else if (instanceOf(shape, Q$ConvexPolygon)) {
    polygon = shape;
    vertices = $getVertices_0(polygon, position, rotation);
    minX = vertices[0].x;
    maxX = vertices[0].x;
    minY = vertices[0].y;
    maxY = vertices[0].y;
    for (i = 1; i < vertices.length; ++i) {
      minX = min(minX, vertices[i].x);
      maxX = max_0(maxX, vertices[i].x);
      minY = min(minY, vertices[i].y);
      maxY = max_0(maxY, vertices[i].y);
    }
    width = maxX - minX;
    height = maxY - minY;
    return $getPoints(new Box_0(width, height), position, rotation);
  }
   else if (instanceOf(shape, Q$Line)) {
    line = shape;
    width = abs(line.end.x - line.start.x);
    height = abs(line.end.y - line.start.y);
    return $getPoints(new Box_0(width, height), position, rotation);
  }
   else {
    bounds = shape.getBounds();
    return $getPoints(new Box_0(bounds.width_0, bounds.height_0), position, rotation);
  }
}

function angle_0(a, b){
  var dls;
  dls = (a.x * b.x + a.y * b.y) / (sqrt(a.x * a.x + a.y * a.y) * sqrt(b.x * b.x + b.y * b.y));
  dls < -1?(dls = -1):dls > 1 && (dls = 1);
  return Math.acos(dls);
}

function $changeAnimation(this$static, animationName, mode){
  if (this$static.texture) {
    this$static.play_0 = $getAnimationByName(this$static.texture, animationName).start_1(mode);
    $start_2(this$static.play_0, mode);
    $setAnimationFrame(this$static, $getCurrentFrame(this$static.play_0));
  }
}

function $draw_0(this$static){
  if (this$static.play_0) {
    $setAnimationFrame(this$static, $getCurrentFrame(this$static.play_0));
    $drawPlatform(this$static.world.game.view, this$static);
  }
}

function $setAnimationFrame(this$static, currentFrame){
  if (this$static.frame != currentFrame) {
    this$static.frame = currentFrame;
    $put_1(this$static.texCoords, this$static.frame.u1);
    $put_1(this$static.texCoords, this$static.frame.v2);
    $put_1(this$static.texCoords, this$static.frame.u2);
    $put_1(this$static.texCoords, this$static.frame.v2);
    $put_1(this$static.texCoords, this$static.frame.u2);
    $put_1(this$static.texCoords, this$static.frame.v1);
    $put_1(this$static.texCoords, this$static.frame.u1);
    $put_1(this$static.texCoords, this$static.frame.v1);
    $flip(this$static.texCoords);
  }
}

function $setPosition_0(this$static, x, y){
  var i, nbPoints, point, points, shape;
  $set_4(this$static.position_0, x, y);
  $set_4(this$static.lastPosition, x, y);
  shape = this$static.shape;
  points = getVertices(shape, this$static.position_0, this$static.rotation);
  nbPoints = min_0(points.length, this$static.vertices.capacity);
  for (i = 0; i < nbPoints; ++i) {
    point = points[i];
    $put_1(this$static.vertices, point.x);
    $put_1(this$static.vertices, point.y);
  }
  $flip(this$static.vertices);
}

function $setTexture(this$static, texture){
  this$static.texture = texture;
  this$static.play_0 = (texture.animations.map.size_0() == 0?new AnimationCollection$NotReadyFirstAnimation_0(texture):$iterator_0($values(texture.animations)).val$outerIter.next_0().getValue()).start_0();
  $setAnimationFrame(this$static, $getCurrentFrame(this$static.play_0));
}

function AnimatedPlatform_0(world, w, h_0){
  AbstractDrawableStaticBody_0.call(this, new Box_0(w, h_0));
  this.vertices = new FloatBuffer_0($slice($order(allocateDirect(32), ($clinit_ByteOrder() , $clinit_ByteOrder() , NATIVE_ORDER))));
  this.texCoords = new FloatBuffer_0($slice($order(allocateDirect(32), NATIVE_ORDER)));
  this.surfaceFriction = 10;
  this.bitmask = or(this.bitmask, P1_longLit);
  this.world = world;
  this.w = w;
  this.h_0 = h_0;
}

defineSeed(426, 330, makeCastMap([Q$Drawable, Q$Updatable, Q$AnimatedPlatform, Q$StaticBody]), AnimatedPlatform_0);
_.draw = function draw_13(){
  $draw_0(this);
}
;
_.update_1 = function update_18(frameTimeInfos){
  $update_1(this.play_0, div(frameTimeInfos.elapsedTime, Pf4240_longLit));
}
;
_.frame = null;
_.h_0 = 0;
_.play_0 = null;
_.texture = null;
_.w = 0;
_.world = null;
function Accelerator_0(world, w, h_0, force){
  AnimatedPlatform_0.call(this, world, w, h_0);
  this.force = force;
}

defineSeed(425, 426, makeCastMap([Q$Drawable, Q$Updatable, Q$AnimatedPlatform, Q$CollisionDetectionOnly, Q$StaticBody]), Accelerator_0);
_.collided = function collided_0(body){
  $addForce(body, this.force);
}
;
_.force = null;
function Activator_0(world, activableId, onTexture, offTexture, w, h_0){
  AnimatedPlatform_0.call(this, world, w, h_0);
  this.activableId = activableId;
  $setTexture(this, offTexture);
  this.onTexture = onTexture;
}

defineSeed(427, 426, makeCastMap([Q$Drawable, Q$Updatable, Q$AnimatedPlatform, Q$StaticBody]), Activator_0);
_.collided = function collided_1(body){
  var a, b, bodies, i;
  if (this.activated) {
    return;
  }
  if (instanceOf(body, Q$Hero) || instanceOf(body, Q$Key)) {
    this.activated = true;
    bodies = this.world.bodies;
    for (i = 0; i < bodies.elements.size; ++i) {
      b = $get(bodies.elements, i);
      if (instanceOf(b, Q$Blocker)) {
        a = b;
        if (a.activableId == this.activableId) {
          a.activated = true;
          $setTexture(this, this.onTexture);
        }
      }
    }
  }
}
;
_.activableId = 0;
_.activated = false;
_.onTexture = null;
function $setTexture_0(this$static, texture){
  this$static.play_0 = (texture.animations.map.size_0() == 0?new AnimationCollection$NotReadyFirstAnimation_0(texture):$iterator_0($values(texture.animations)).val$outerIter.next_0().getValue()).start_0();
}

function $setZOrder_1(this$static, zOrder){
  this$static.zOrder = zOrder;
}

function PickableObject_0(world, shape){
  StaticBody_0.call(this, shape);
  this.world = world;
  this.bitmask = or(this.bitmask, P1_longLit);
}

defineSeed(429, 331, makeCastMap([Q$Drawable, Q$Updatable, Q$CollisionDetectionOnly, Q$StaticBody]));
_.collided = function collided_2(body){
  if (instanceOf(body, Q$Hero)) {
    this.removeFromWorld();
    $addTopLevelEntities(this.world, new PickedUpObject_0(this.world, $getCurrentFrame(this.play_0), this.position_0, this.shape.getBounds().width_0));
  }
}
;
_.draw = function draw_14(){
  $drawPickableObject(this.world.game.view, this, $getCurrentFrame(this.play_0), this.world);
}
;
_.getZOrder = function getZOrder_3(){
  return this.zOrder;
}
;
_.removeFromWorld = function removeFromWorld(){
  $remove_9(this.world, this);
}
;
_.update_1 = function update_19(frameTimeInfos){
  $update_1(this.play_0, div(frameTimeInfos.elapsedTime, Pf4240_longLit));
}
;
_.play_0 = null;
_.world = null;
_.zOrder = 0;
function Apple_0(world, shape){
  PickableObject_0.call(this, world, shape);
}

defineSeed(428, 429, makeCastMap([Q$Drawable, Q$Updatable, Q$Apple, Q$CollisionDetectionOnly, Q$StaticBody]), Apple_0);
_.removeFromWorld = function removeFromWorld_0(){
  $removeApple(this.world, this);
}
;
function $setTexture_1(this$static, texture){
  this$static.play_0 = (texture.animations.map.size_0() == 0?new AnimationCollection$NotReadyFirstAnimation_0(texture):$iterator_0($values(texture.animations)).val$outerIter.next_0().getValue()).start_0();
}

function Axe_0(world){
  AbstractDrawableBody_0.call(this, new Box_0(1, 3.9000000953674316), 10);
  this.world = world;
  this.gravity = false;
}

defineSeed(430, 328, makeCastMap([Q$Drawable, Q$Updatable]), Axe_0);
_.collided = function collided_3(other){
  var event_0, event$index, event$max, events, hero, normal;
  if (instanceOf(other, Q$Hero)) {
    hero = other;
    if (hero.isHurt) {
      return;
    }
    events = $getContacts(this.world, this);
    for (event$index = 0 , event$max = events.length; event$index < event$max; ++event$index) {
      event_0 = events[event$index];
      if (event_0.body2 == hero) {
        normal = new Vector2f_2(event_0.normal);
        $hurtByPike(hero, normal);
        return;
      }
       else if (event_0.body1 == hero) {
        normal = new Vector2f_2(event_0.normal);
        $hurtByPike(hero, new Vector2f_1(-normal.x, -normal.y));
        return;
      }
    }
  }
}
;
_.draw = function draw_15(){
  $drawAxe(this.world.game.view, this, $getCurrentFrame(this.play_0));
}
;
_.update_1 = function update_20(frameTimeInfos){
  var v;
  v = this.angularVelocity;
  v < 1 && $adjustAngularVelocity(this, 1 - v);
}
;
_.play_0 = null;
_.world = null;
function $setTexture_2(this$static, texture){
  this$static.play_0 = (texture.animations.map.size_0() == 0?new AnimationCollection$NotReadyFirstAnimation_0(texture):$iterator_0($values(texture.animations)).val$outerIter.next_0().getValue()).start_0();
}

function AxeAnchor_0(world){
  AxeAnchor_1.call(this, world, new Circle_0(1));
}

function AxeAnchor_1(world, shape){
  AbstractDrawableStaticBody_0.call(this, shape);
  this.surfaceFriction = 10;
  this.bitmask = or(this.bitmask, P1_longLit);
  this.world = world;
}

defineSeed(431, 330, makeCastMap([Q$Drawable, Q$Updatable, Q$StaticBody]), AxeAnchor_0);
_.draw = function draw_16(){
  $drawAxeAnchor(this.world.game.view, this, 1, $getCurrentFrame(this.play_0));
}
;
_.update_1 = function update_21(frameTimeInfos){
  $update_1(this.play_0, div(frameTimeInfos.elapsedTime, Pf4240_longLit));
}
;
_.play_0 = null;
_.world = null;
function Bat_0(world, shape, animation){
  Body_0.call(this, shape, 0.10000000149011612);
  this.world = world;
  this.rotatable = false;
  this.gravity = false;
  this.play_0 = (animation.animations.map.size_0() == 0?new AnimationCollection$NotReadyFirstAnimation_0(animation):$iterator_0($values(animation.animations)).val$outerIter.next_0().getValue()).start_0();
}

defineSeed(432, 328, makeCastMap([Q$Drawable, Q$Updatable]), Bat_0);
_.collided = function collided_4(other){
  var angle, event_0, events, hero, i, normal;
  if (!this.isDead) {
    if (instanceOf(other, Q$Hero)) {
      events = $getContacts(this.world, this);
      hero = other;
      for (i = 0; i < events.length; ++i) {
        event_0 = events[i];
        if (event_0.body2 == hero) {
          normal = new Vector2f_2(event_0.normal);
          angle = angle_0(normal, this.world.gravityVector);
          if (angle < 0.7853981633974483) {
            hero.isHurt || $hurt(hero, 1);
          }
           else {
            ++hero.levelScore.nbKilledBat;
            $addTopLevelEntities(hero.world, new ScoreVisualIndicator_0(hero));
            this.isDead = true;
          }
        }
         else if (event_0.body1 == hero) {
          normal = new Vector2f_2(event_0.normal);
          angle = angle_0(normal, this.world.gravityVector);
          if (angle > 0.7853981633974483) {
            hero.isHurt || $hurt(hero, 1);
          }
           else {
            ++hero.levelScore.nbKilledBat;
            $addTopLevelEntities(hero.world, new ScoreVisualIndicator_0(hero));
            this.isDead = true;
          }
        }
      }
    }
    this.isDead && (this.moveable = false);
  }
}
;
_.draw = function draw_17(){
  $drawBat(this.world.game.view, this, this.scale_0, $getCurrentFrame(this.play_0));
}
;
_.update_1 = function update_22(frameTimeInfos){
  var rot;
  if (this.isDead) {
    if (lt(this.beginOfDyingDuration, P0_longLit)) {
      this.beginOfDyingDuration = frameTimeInfos.currentTime_0;
    }
     else {
      this.scale_0 = 1 - toDouble(sub(frameTimeInfos.currentTime_0, this.beginOfDyingDuration)) / 1000000000;
      this.scale_0 <= 0 && $remove_9(this.world, this);
    }
    return;
  }
  if (gt(frameTimeInfos.currentTime_0, this.nextChangeDirectionTime)) {
    this.nextChangeDirectionTime = add_4(frameTimeInfos.currentTime_0, fromDouble(Math.random() * 1000000000));
    rot = new Matrix2f_1(Math.random() * 2 * 3.141592653589793);
    this.directionVelocity = mul_0(rot, new Vector2f_1(8, 0));
  }
   else {
    $adjustBiasedVelocity(this, this.directionVelocity);
  }
  $update_1(this.play_0, div(frameTimeInfos.elapsedTime, Pf4240_longLit));
}
;
_.beginOfDyingDuration = N1_longLit;
_.directionVelocity = null;
_.isDead = false;
_.nextChangeDirectionTime = P0_longLit;
_.play_0 = null;
_.scale_0 = 1;
_.world = null;
function Blocker_0(world, activableId, w, h_0){
  AnimatedPlatform_0.call(this, world, w, h_0);
  this.activableId = activableId;
}

defineSeed(433, 426, makeCastMap([Q$Drawable, Q$Updatable, Q$AnimatedPlatform, Q$Blocker, Q$StaticBody]), Blocker_0);
_.draw = function draw_18(){
  $drawBlocker(this.world.game.view, this, this.alpha_0);
}
;
_.update_1 = function update_23(frameTimeInfos){
  this.activated && (lt(this.disappearEndTime, P0_longLit)?(this.disappearEndTime = add_4(frameTimeInfos.currentTime_0, P3b9aca00_longLit)):lt(frameTimeInfos.currentTime_0, this.disappearEndTime)?(this.alpha_0 = toDouble(sub(this.disappearEndTime, frameTimeInfos.currentTime_0)) / 1000000000):$remove_9(this.world, this));
}
;
_.activableId = 0;
_.activated = false;
_.alpha_0 = 1;
_.disappearEndTime = N1_longLit;
function $setExplosionTexture(this$static, explositionTexture){
  this$static.explositionTexture = explositionTexture;
}

function $setFireBallTexture(this$static, fireBallTexture){
  this$static.fireBallTexture = fireBallTexture;
}

function $setTexture_3(this$static, texture){
  this$static.texture = texture;
  this$static.play_0 = (texture.animations.map.size_0() == 0?new AnimationCollection$NotReadyAnimationWithName_0(texture, 'bomb_inactive'):$get_9(texture.animations, 'bomb_inactive')).start_0();
}

function $throwFireball(this$static, dx, dy){
  var fireBall, pos, w;
  pos = new Vector2f_2(this$static.position_0);
  w = this$static.shape.getBounds().width_0;
  fireBall = new FireBall_0(this$static.world, w / 2);
  $setPosition(fireBall, pos.x + dx * w, pos.y + dy * w);
  $setTexture_7(fireBall, this$static.fireBallTexture);
  $setExplosionTexture_3(fireBall, this$static.explositionTexture);
  $add_9(this$static.world, fireBall);
  $addForce(fireBall, new Vector2f_1(dx * 10000, dy * 10000));
}

function Bomb_0(world){
  AbstractDrawableBody_0.call(this, new Circle_0(0.9750000238418579), 1);
  this.world = world;
}

defineSeed(434, 328, makeCastMap([Q$Drawable, Q$Updatable]), Bomb_0);
_.collided = function collided_5(body){
  if (instanceOf(body, Q$Hero) || instanceOf(body, Q$FireBall)) {
    if (!this.triggered) {
      this.play_0 = $getAnimationByName(this.texture, 'bomb_about_to_explode').start_0();
      this.triggered = true;
    }
  }
}
;
_.draw = function draw_19(){
  $drawBomb(this.world.game.view, this, $getCurrentFrame(this.play_0));
}
;
--></script>
<script><!--
_.update_1 = function update_24(frameTimeInfos){
  $update_1(this.play_0, div(frameTimeInfos.elapsedTime, Pf4240_longLit));
  this.triggered && (lt(this.explodeTime, P0_longLit)?(this.explodeTime = add_4(frameTimeInfos.currentTime_0, P77359400_longLit)):gte_0(frameTimeInfos.currentTime_0, this.explodeTime) && ($play_0(this.world.explodeSound.val$sound) , !!this.parentHole && (this.parentHole.canThrowBomb = true) , $remove_9(this.world, this) , $throwFireball(this, 1, 1) , $throwFireball(this, -1, -1) , $throwFireball(this, -1, 1) , $throwFireball(this, 1, -1) , undefined));
}
;
_.explodeTime = N1_longLit;
_.explositionTexture = null;
_.fireBallTexture = null;
_.parentHole = null;
_.play_0 = null;
_.texture = null;
_.triggered = false;
_.world = null;
function $setBombTexture(this$static, bombTexture){
  this$static.bombTexture = bombTexture;
}

function $setExplosionTexture_0(this$static, explositionTexture){
  this$static.explosionTexture = explositionTexture;
}

function $setFireBallTexture_0(this$static, fireBallTexture){
  this$static.fireBallTexture = fireBallTexture;
}

function BombHole_0(world, w, h_0){
  AnimatedPlatform_0.call(this, world, w, h_0);
  this.enabled = false;
}

defineSeed(435, 426, makeCastMap([Q$Drawable, Q$Updatable, Q$AnimatedPlatform, Q$StaticBody]), BombHole_0);
_.update_1 = function update_25(frameTimeInfos){
  var pos, bomb;
  if (this.canThrowBomb) {
    this.canThrowBomb = false;
    pos = new Vector2f_2(this.position_0);
    bomb = new Bomb_0(this.world);
    $setTexture_3(bomb, this.bombTexture);
    $setFireBallTexture(bomb, this.fireBallTexture);
    $setExplosionTexture(bomb, this.explosionTexture);
    bomb.parentHole = this;
    $setPosition(bomb, pos.x, pos.y);
    $add_9(this.world, bomb);
  }
}
;
_.bombTexture = null;
_.canThrowBomb = true;
_.explosionTexture = null;
_.fireBallTexture = null;
function $getHandPosition(this$static, side){
  var pos;
  pos = new Vector2f_2(this$static.position_0);
  pos.y -= 2.616039991378784;
  side == ($clinit_BossHand$Side() , LEFT)?(pos.x -= 2.799999952316284):(pos.x += 2.799999952316284);
  return pos;
}

function $setExplosionTexture_1(this$static, explosionTexture){
  this$static.explosionTexture = explosionTexture;
}

function $setTexture_4(this$static, texture){
  this$static.play_0 = (texture.animations.map.size_0() == 0?new AnimationCollection$NotReadyAnimationWithName_0(texture, 'boss_body'):$get_9(texture.animations, 'boss_body')).start_0();
  this$static.texture = texture;
  $setTexture_5(this$static.leftHand, texture);
  $setTexture_5(this$static.rightHand, texture);
}

function Boss_0(world, x, y){
  AbstractDrawableBody_0.call(this, new Circle_0(4), 10);
  this.world = world;
  this.rotatable = false;
  this.gravity = false;
  this.leftHand = new BossHand_0(this, ($clinit_BossHand$Side() , LEFT), world);
  $setPosition(this.leftHand, $getHandPosition(this, LEFT).x, $getHandPosition(this, LEFT).y);
  this.rightHand = new BossHand_0(this, RIGHT, world);
  $setPosition(this.rightHand, $getHandPosition(this, RIGHT).x, $getHandPosition(this, RIGHT).y);
  $set_4(this.position_0, x, y);
  $set_4(this.lastPosition, x, y);
}

defineSeed(436, 328, makeCastMap([Q$Drawable, Q$Updatable]), Boss_0);
_.collided = function collided_6(other){
  var angle, event_0, events, hero, i, isBossHurt, isHeroHurt, normal;
  if (instanceOf(other, Q$Hero)) {
    events = $getContacts(this.world, this);
    hero = other;
    isBossHurt = false;
    isHeroHurt = false;
    for (i = 0; i < events.length; ++i) {
      event_0 = events[i];
      normal = new Vector2f_2(event_0.normal);
      angle = angle_0(normal, this.world.gravityVector);
      event_0.body2 == hero?angle < 0.7853981633974483?(isHeroHurt = true):(isBossHurt = true):event_0.body1 == hero && (angle > 0.7853981633974483?(isHeroHurt = true):(isBossHurt = true));
      if (isBossHurt) {
        if (!this.isHurt) {
          if (hero.position_0.y > this.position_0.y) {
            --this.lifePoints;
            this.isHurt = true;
            this.endOfInvincibilityDuration = N1_longLit;
            this.lifePoints == 0 && (++hero.levelScore.nbKilledEgyptianBoss , $addTopLevelEntities(hero.world, new ScoreVisualIndicator_0(hero)));
          }
        }
      }
      !isBossHurt && isHeroHurt && (hero.isHurt || $hurt(hero, 1));
    }
  }
  this.lifePoints <= 0 && (this.moveable = false);
}
;
_.draw = function draw_20(){
  $drawBoss(this.world.game.view, this, $getCurrentFrame(this.play_0));
}
;
_.update_1 = function update_26(frameTimeInfos){
  var bodies, body, bounds, i, pos, x1, y1;
  $update_1(this.play_0, div(frameTimeInfos.elapsedTime, Pf4240_longLit));
  if (this.lifePoints <= 0) {
    if (lt(this.endOfDyingDuration, P0_longLit)) {
      $remove_9(this.world, this.leftHand);
      $remove_9(this.world, this.rightHand);
      this.endOfDyingDuration = add_4(frameTimeInfos.currentTime_0, P2540be400_longLit);
      this.nextExplosionTime = add_4(frameTimeInfos.currentTime_0, P11e1a300_longLit);
    }
     else {
      if (gt(this.endOfDyingDuration, frameTimeInfos.currentTime_0)) {
        if (lt(this.nextExplosionTime, frameTimeInfos.currentTime_0)) {
          bounds = this.shape.getBounds();
          x1 = this.position_0.x + -bounds.width_0 / 2;
          y1 = this.position_0.y + -bounds.height_0 / 2;
          pos = new Vector2f_1(x1 + $nextInternal(frameTimeInfos.random_0, 24) * 5.9604644775390625E-8 * bounds.width_0, y1 + $nextInternal(frameTimeInfos.random_0, 24) * 5.9604644775390625E-8 * bounds.height_0 / 2);
          $addTopLevelEntities(this.world, new Explosion_0(this.world, pos, this.explosionTexture));
          this.nextExplosionTime = add_4(frameTimeInfos.currentTime_0, P11e1a300_longLit);
        }
      }
       else {
        bodies = this.world.bodies;
        for (i = 0; i < bodies.elements.size; ++i) {
          body = $get(bodies.elements, i);
          instanceOf(body, Q$Door) && $open(body);
        }
        $remove_9(this.world, this);
      }
    }
    return;
  }
  if (this.isHurt) {
    if (lt(this.endOfInvincibilityDuration, P0_longLit)) {
      this.play_0 = $getAnimationByName(this.texture, 'angry_boss_body').start_0();
      this.speed = 2;
      this.endOfInvincibilityDuration = add_4(frameTimeInfos.currentTime_0, P2540be400_longLit);
    }
     else if (gt(frameTimeInfos.currentTime_0, this.endOfInvincibilityDuration)) {
      this.play_0 = $getAnimationByName(this.texture, 'boss_body').start_0();
      this.isHurt = false;
      this.speed = 1;
    }
  }
  if (gt(frameTimeInfos.currentTime_0, this.nextChangeDirectionTime)) {
    this.nextChangeDirectionTime = add_4(add_4(frameTimeInfos.currentTime_0, P1dcd6500_longLit), fromDouble(Math.random() * 500000000));
    this.directionVelocity = new Vector2f_2(this.world.hero.position_0);
    $sub(this.directionVelocity, this.position_0);
    $normalise(this.directionVelocity);
    $scale_0(this.directionVelocity, 2 * this.speed);
  }
   else {
    $adjustBiasedVelocity(this, this.directionVelocity);
  }
}
;
_.directionVelocity = null;
_.endOfDyingDuration = N1_longLit;
_.endOfInvincibilityDuration = N1_longLit;
_.explosionTexture = null;
_.isHurt = false;
_.leftHand = null;
_.lifePoints = 3;
_.nextChangeDirectionTime = P0_longLit;
_.nextExplosionTime = P0_longLit;
_.play_0 = null;
_.rightHand = null;
_.speed = 1;
_.texture = null;
_.world = null;
function $setTexture_5(this$static, t){
  this$static.play_0 = $getAnimationByName(t, 'boss_hand_' + this$static.side.name_0.toLowerCase()).start_0();
}

function BossHand_0(boss, side, world){
  AbstractDrawableBody_0.call(this, new Circle_0(1), 5);
  this.boss = boss;
  this.side = side;
  this.world = world;
  this.rotatable = false;
  this.gravity = false;
  $addExcludedBody(this, boss);
}

defineSeed(437, 328, makeCastMap([Q$Drawable, Q$Updatable]), BossHand_0);
_.collided = function collided_7(other){
  if (instanceOf(other, Q$Hero)) {
    other.isHurt || $hurt(other, 1);
    this.gravity = false;
    this.state = 1;
  }
   else if (instanceOf(other, Q$AnimatedPlatform)) {
    this.gravity = false;
    this.state = 1;
  }
}
;
_.draw = function draw_21(){
  $drawBossHand(this.world.game.view, this, $getCurrentFrame(this.play_0));
}
;
_.update_1 = function update_27(frameTimeInfos){
  var canfall, dir, directionVelocity, handPosition, hero, position;
  $update_1(this.play_0, div(frameTimeInfos.elapsedTime, Pf4240_longLit));
  if (this.state == 1) {
    handPosition = $getHandPosition(this.boss, this.side);
    directionVelocity = new Vector2f_2(handPosition);
    position = this.position_0;
    directionVelocity.x -= position.x;
    directionVelocity.y -= position.y;
    $normalise(directionVelocity);
    $scale_0(directionVelocity, 2 * this.boss.speed * 2);
    $adjustBiasedVelocity(this, directionVelocity);
    canfall = $distanceSquared(handPosition, position) < 1;
    if (canfall) {
      hero = this.boss.world.hero;
      dir = new Vector2f_2(hero.position_0);
      $sub(dir, this.position_0);
      if (angle_0(dir, this.boss.world.gravityVector) < 0.39269908169872414) {
        this.gravity = true;
        this.state = 0;
      }
    }
  }
}
;
_.boss = null;
_.play_0 = null;
_.side = null;
_.state = 1;
_.world = null;
function $clinit_BossHand$Side(){
  $clinit_BossHand$Side = nullMethod;
  LEFT = new BossHand$Side_0('LEFT', 0);
  RIGHT = new BossHand$Side_0('RIGHT', 1);
  $VALUES_19 = initValues(_3Lim_bci_newtonadv_world_BossHand$Side_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$BossHand$Side, [LEFT, RIGHT]);
}

function BossHand$Side_0(enum$name, enum$ordinal){
  Enum_0.call(this, enum$name, enum$ordinal);
}

function values_20(){
  $clinit_BossHand$Side();
  return $VALUES_19;
}

defineSeed(438, 11, makeCastMap([Q$BossHand$Side, Q$Serializable, Q$Comparable, Q$Enum]), BossHand$Side_0);
var $VALUES_19, LEFT, RIGHT;
function BouncePlatform_0(world, w, h_0){
  AnimatedPlatform_0.call(this, world, w, h_0);
}

defineSeed(439, 426, makeCastMap([Q$Drawable, Q$Updatable, Q$AnimatedPlatform, Q$StaticBody]), BouncePlatform_0);
_.collided = function collided_8(other){
  var event_0, events, hero, i, normal;
  if (instanceOf(other, Q$Hero)) {
    hero = other;
    events = $getContacts(this.world, this);
    for (i = 0; i < events.length; ++i) {
      event_0 = events[i];
      if (event_0.body2 == hero) {
        normal = new Vector2f_2(event_0.normal);
        $collisionWithBouncePlatform(hero, normal);
      }
       else if (event_0.body1 == hero) {
        normal = new Vector2f_2(event_0.normal);
        $collisionWithBouncePlatform(hero, new Vector2f_1(-normal.x, -normal.y));
      }
    }
  }
}
;
function $setExplosionTexture_2(this$static, texture){
  this$static.explosionTexture = texture;
}

function $setFireBallTexture_1(this$static, texture){
  this$static.fireBallTexture = texture;
}

function $throwFireball_0(this$static){
  var fireBall, pos;
  pos = new Vector2f_2(this$static.position_0);
  fireBall = new FireBall_0(this$static.world, this$static.w / 2);
  $setPosition(fireBall, pos.x, pos.y);
  $setTexture_7(fireBall, this$static.fireBallTexture);
  $setExplosionTexture_3(fireBall, this$static.explosionTexture);
  $add_9(this$static.world, fireBall);
  switch (this$static.orientation.ordinal) {
    case 0:
      $addForce(fireBall, new Vector2f_1(0, 10000));
      break;
    case 1:
      $addForce(fireBall, new Vector2f_1(0, -10000));
      break;
    case 2:
      $addForce(fireBall, new Vector2f_1(-10000, 0));
      break;
    case 3:
      $addForce(fireBall, new Vector2f_1(10000, 0));
  }
}

function Cannon_0(world, orientation, w, h_0){
  AnimatedPlatform_0.call(this, world, w, h_0);
  this.orientation = orientation;
  this.enabled = false;
}

defineSeed(440, 426, makeCastMap([Q$Drawable, Q$Updatable, Q$AnimatedPlatform, Q$StaticBody]), Cannon_0);
_.update_1 = function update_28(frameTimeInfos){
  if (gt(frameTimeInfos.currentTime_0, this.nextFireballTime)) {
    $throwFireball_0(this);
    this.nextFireballTime = add_4(frameTimeInfos.currentTime_0, P77359400_longLit);
  }
}
;
_.explosionTexture = null;
_.fireBallTexture = null;
_.nextFireballTime = P0_longLit;
_.orientation = null;
function $clinit_Cannon$Orientation(){
  $clinit_Cannon$Orientation = nullMethod;
  UP = new Cannon$Orientation_0('UP', 0);
  DOWN = new Cannon$Orientation_0('DOWN', 1);
  LEFT_0 = new Cannon$Orientation_0('LEFT', 2);
  RIGHT_0 = new Cannon$Orientation_0('RIGHT', 3);
  $VALUES_20 = initValues(_3Lim_bci_newtonadv_world_Cannon$Orientation_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Cannon$Orientation, [UP, DOWN, LEFT_0, RIGHT_0]);
}

function Cannon$Orientation_0(enum$name, enum$ordinal){
  Enum_0.call(this, enum$name, enum$ordinal);
}

function values_21(){
  $clinit_Cannon$Orientation();
  return $VALUES_20;
}

defineSeed(441, 11, makeCastMap([Q$Cannon$Orientation, Q$Serializable, Q$Comparable, Q$Enum]), Cannon$Orientation_0);
var $VALUES_20, DOWN, LEFT_0, RIGHT_0, UP;
function $setColor(this$static, color){
  this$static.color = color;
}

function Cloud_0(world, w, h_0){
  AnimatedPlatform_0.call(this, world, w, h_0);
}

defineSeed(442, 426, makeCastMap([Q$Drawable, Q$Updatable, Q$AnimatedPlatform, Q$StaticBody]), Cloud_0);
_.collided = function collided_9(body){
  instanceOf(body, Q$Hero) && (!this.color || body.color == this.color) && (this.touched = true);
}
;
_.draw = function draw_22(){
  $drawCloud(this.world.game.view, this, this.alpha_0);
}
;
_.update_1 = function update_29(frameTimeInfos){
  this.touched && (lt(this.disappearEndTime, P0_longLit)?(this.disappearEndTime = add_4(frameTimeInfos.currentTime_0, P3b9aca00_longLit)):lt(frameTimeInfos.currentTime_0, this.disappearEndTime)?(this.alpha_0 = toDouble(sub(this.disappearEndTime, frameTimeInfos.currentTime_0)) / 1000000000):$remove_9(this.world, this));
}
;
_.alpha_0 = 1;
_.color = null;
_.disappearEndTime = N1_longLit;
_.touched = false;
function Clue_0(world, w, h_0){
  AnimatedPlatform_0.call(this, world, w, h_0);
  this.move = new PingPongTimedAction_0;
}

defineSeed(443, 426, makeCastMap([Q$Drawable, Q$Updatable, Q$AnimatedPlatform, Q$CollisionDetectionOnly, Q$StaticBody]), Clue_0);
_.draw = function draw_23(){
  $distanceSquared(this.world.hero.position_0, this.position_0) < 100 && $draw_0(this);
}
;
_.update_1 = function update_30(frameTimeInfos){
  $update_1(this.play_0, div(frameTimeInfos.elapsedTime, Pf4240_longLit));
  $update_7(this.move, frameTimeInfos);
  $setPosition_0(this, this.anchor.x, this.anchor.y + this.h_0 / 4 * this.move.progress);
}
;
_.anchor = null;
function Coin_0(world, shape){
  PickableObject_0.call(this, world, shape);
}

defineSeed(444, 429, makeCastMap([Q$Drawable, Q$Updatable, Q$Coin, Q$CollisionDetectionOnly, Q$StaticBody]), Coin_0);
_.removeFromWorld = function removeFromWorld_1(){
  $removeCoin(this.world, this);
}
;
function ColoredPlatform_0(world, w, h_0){
  AnimatedPlatform_0.call(this, world, w, h_0);
}

defineSeed(445, 426, makeCastMap([Q$Drawable, Q$Updatable, Q$AnimatedPlatform, Q$StaticBody]), ColoredPlatform_0);
function $setColor_0(this$static, color){
  this$static.color = color;
}

function Colorizer_0(world, w, h_0){
  AnimatedPlatform_0.call(this, world, w, h_0);
}

defineSeed(446, 426, makeCastMap([Q$Drawable, Q$Updatable, Q$AnimatedPlatform, Q$CollisionDetectionOnly, Q$StaticBody]), Colorizer_0);
_.collided = function collided_10(body){
  instanceOf(body, Q$Hero)?$setColor_3(body, this.color):instanceOf(body, Q$Key) && $setColor_4(body, this.color);
}
;
_.color = null;
function Compass_0(world, shape){
  PickableObject_0.call(this, world, shape);
}

defineSeed(447, 429, makeCastMap([Q$Drawable, Q$Updatable, Q$CollisionDetectionOnly, Q$Compass, Q$StaticBody]), Compass_0);
function Crate_0(world, w, h_0){
  AnimatedPlatform_0.call(this, world, w, h_0);
  $changeAnimation(this, 'crate', 1);
}

defineSeed(448, 426, makeCastMap([Q$Drawable, Q$Updatable, Q$AnimatedPlatform, Q$StaticBody]), Crate_0);
_.collided = function collided_11(body){
  if (instanceOf(body, Q$FireBall)) {
    if (!this.touched) {
      this.touched = true;
      $changeAnimation(this, 'burning_crate', 0);
    }
  }
}
;
_.update_1 = function update_31(frameTimeInfos){
  $update_1(this.play_0, div(frameTimeInfos.elapsedTime, Pf4240_longLit));
  this.touched && this.play_0.state == 1 && $remove_9(this.world, this);
}
;
_.touched = false;
function MovingPlatform_0(world, texture, destinations, w, h_0){
  MovingPlatform_1.call(this, world, texture, destinations, new Box_0(w, h_0));
}

function MovingPlatform_1(world, texture, destinations, shape){
  Body_0.call(this, shape, 10000);
  this.f = new Vector2f_0;
  this.world = world;
  this.play_0 = (texture.animations.map.size_0() == 0?new AnimationCollection$NotReadyFirstAnimation_0(texture):$iterator_0($values(texture.animations)).val$outerIter.next_0().getValue()).start_0();
  this.destinations = destinations;
  this.gravity = false;
  this.rotatable = false;
  (texture.animations.map.size_0() == 0?new AnimationCollection$NotReadyFirstAnimation_0(texture):$iterator_0($values(texture.animations)).val$outerIter.next_0().getValue()).start_0();
}

defineSeed(450, 328, makeCastMap([Q$Drawable, Q$Updatable]), MovingPlatform_0);
_.draw = function draw_24(){
  $drawMovingPlatform(this.world.game.view, this, $getCurrentFrame(this.play_0));
}
;
_.update_1 = function update_32(frameTimeInfos){
  var destinationPos;
  if (this.destinations.length > 0) {
    destinationPos = this.destinations[this.currentDestination];
    if (sqrt($distanceSquared(this.position_0, destinationPos)) < 1) {
      ++this.currentDestination;
      this.currentDestination >= this.destinations.length && (this.currentDestination = 0);
    }
    $set_5(this.f, destinationPos);
    $sub(this.f, this.position_0);
    $normalise(this.f);
    $scale_0(this.f, 2);
    $adjustBiasedVelocity(this, this.f);
  }
}
;
_.currentDestination = 0;
_.destinations = null;
_.play_0 = null;
_.world = null;
function $setColor_1(this$static, color){
  this$static.color = color;
}

function DangerousMovingPlatform_0(world, texture, destinations, w, h_0){
  MovingPlatform_1.call(this, world, texture, destinations, new Box_0(w, h_0));
}

defineSeed(449, 450, makeCastMap([Q$Drawable, Q$Updatable]), DangerousMovingPlatform_0);
_.collided = function collided_12(other){
  var event_0, event$index, event$max, events, hero, normal;
  if (instanceOf(other, Q$Hero)) {
    hero = other;
    if (hero.isHurt || this.color == hero.color) {
      return;
    }
    events = $getContacts(this.world, this);
    for (event$index = 0 , event$max = events.length; event$index < event$max; ++event$index) {
      event_0 = events[event$index];
      if (event_0.body2 == hero) {
        normal = new Vector2f_2(event_0.normal);
        $hurtByPike(hero, normal);
        return;
      }
       else if (event_0.body1 == hero) {
        normal = new Vector2f_2(event_0.normal);
        $hurtByPike(hero, new Vector2f_1(-normal.x, -normal.y));
        return;
      }
    }
  }
}
;
_.color = null;
function $open(this$static){
  this$static.isClose = false;
  this$static.play_0 = $getAnimationByName(this$static.texture, 'open').start_1(0);
}

function $setColor_2(this$static, color){
  this$static.color = color;
}

function $setTexture_6(this$static, texture){
  this$static.texture = texture;
  this$static.play_0 = (texture.animations.map.size_0() == 0?new AnimationCollection$NotReadyAnimationWithName_0(texture, 'closed'):$get_9(texture.animations, 'closed')).start_0();
}

function Door_0(world, w, h_0){
  AbstractDrawableStaticBody_0.call(this, new Box_0(w, h_0));
  this.world = world;
  this.bitmask = or(this.bitmask, P1_longLit);
}

defineSeed(451, 330, makeCastMap([Q$Drawable, Q$Updatable, Q$CollisionDetectionOnly, Q$Door, Q$StaticBody]), Door_0);
_.collided = function collided_13(body){
  instanceOf(body, Q$Hero) && !this.isClose && (this.world.objectivesCompleted = true);
}
;
_.draw = function draw_25(){
  $drawDoor(this.world.game.view, this, $getCurrentFrame(this.play_0));
}
;
_.isOpenableWithKey = function isOpenableWithKey(key){
  return !this.color || this.color == key.color;
}
;
_.update_1 = function update_33(frameTimeInfos){
  $update_1(this.play_0, div(frameTimeInfos.elapsedTime, Pf4240_longLit));
}
;
_.color = null;
_.isClose = true;
_.play_0 = null;
_.texture = null;
_.world = null;
function DoorToBonusWorld_0(world, w, h_0){
  Door_0.call(this, world, w, h_0);
}

defineSeed(452, 451, makeCastMap([Q$Drawable, Q$Updatable, Q$CollisionDetectionOnly, Q$Door, Q$DoorToBonusWorld, Q$StaticBody]), DoorToBonusWorld_0);
_.collided = function collided_14(body){
  !this.isClose && instanceOf(body, Q$Hero) && $goToBonusWorld(this.world);
}
;
_.isOpenableWithKey = function isOpenableWithKey_0(key){
  return false;
}
;
function Explosion_0(world, position, explosionAnimation){
  this.world = world;
  this.position_0 = new Vector2f_2(position);
  this.play_0 = (explosionAnimation.animations.map.size_0() == 0?new AnimationCollection$NotReadyFirstAnimation_0(explosionAnimation):$iterator_0($values(explosionAnimation.animations)).val$outerIter.next_0().getValue()).start_1(0);
}

defineSeed(453, 332, {}, Explosion_0);
_.draw = function draw_26(){
  $drawExplosion(this.world.game.view, this, $getCurrentFrame(this.play_0), this.world);
}
;
_.isDead_0 = function isDead(){
  return this.play_0.state == 1;
}
;
_.update_1 = function update_34(frameTimeInfos){
  $update_1(this.play_0, div(frameTimeInfos.elapsedTime, Pf4240_longLit));
}
;
_.play_0 = null;
_.position_0 = null;
_.world = null;
function $setExplosionTexture_3(this$static, texture){
  this$static.explosionTexture = texture;
}

function $setTexture_7(this$static, texture){
  this$static.play_0 = (texture.animations.map.size_0() == 0?new AnimationCollection$NotReadyFirstAnimation_0(texture):$iterator_0($values(texture.animations)).val$outerIter.next_0().getValue()).start_0();
}

function FireBall_0(world, size){
  AbstractDrawableBody_0.call(this, new Circle_0(size / 2), 40);
  this.world = world;
}

defineSeed(454, 328, makeCastMap([Q$Drawable, Q$Updatable, Q$CollisionDetectionOnly, Q$FireBall]), FireBall_0);
_.collided = function collided_15(other){
  var hero;
  if (instanceOf(other, Q$Hero)) {
    hero = other;
    if (hero.isHurt) {
      return;
    }
    hero.isHurt || $hurt(hero, 2);
  }
  $remove_9(this.world, this);
  $addTopLevelEntities(this.world, new Explosion_0(this.world, this.position_0, this.explosionTexture));
}
;
_.draw = function draw_27(){
  $drawFireBall(this.world.game.view, this, $getCurrentFrame(this.play_0));
}
;
_.update_1 = function update_35(frameTimeInfos){
  $update_1(this.play_0, div(frameTimeInfos.elapsedTime, Pf4240_longLit));
}
;
_.explosionTexture = null;
_.play_0 = null;
_.world = null;
function GameOverException_0(){
  Throwable_0.call(this);
}

defineSeed(455, 52, makeCastMap([Q$GameOverException, Q$Serializable, Q$Throwable]), GameOverException_0);
function HelpSign_0(world, w, h_0){
  AnimatedPlatform_0.call(this, world, w, h_0);
}

defineSeed(456, 426, makeCastMap([Q$Drawable, Q$Updatable, Q$AnimatedPlatform, Q$CollisionDetectionOnly, Q$StaticBody]), HelpSign_0);
_.collided = function collided_16(body){
  instanceOf(body, Q$Hero) && (this.collideHero = true);
}
;
_.update_1 = function update_36(frameTimeInfos){
  if (this.collideHero) {
    if (lt(this.showHelpTime, P0_longLit)) {
      this.showHelpTime = add_4(frameTimeInfos.currentTime_0, P77359400_longLit);
    }
     else if (gt(frameTimeInfos.currentTime_0, this.showHelpTime)) {
      this.showHelpTime = N1_longLit;
      $showHelp_0(this.world);
    }
  }
   else {
    this.showHelpTime = N1_longLit;
  }
  this.collideHero = false;
}
;
_.collideHero = false;
_.showHelpTime = N1_longLit;
function $addColoredExcludedBodies(this$static, newColor){
  var bodies, i, n;
  bodies = $getColoredStaticBodyList(this$static.world, newColor);
  for (i = 0 , n = bodies.elements.size; i < n; ++i) {
    $addExcludedBody(this$static, $get(bodies.elements, i));
  }
}

function $canJump(this$static){
  var angle, event_0, event$index, event$max, events;
  if (this$static.nbStepSinceLastJump++ < 1) {
    return false;
  }
  this$static.nbStepSinceLastJump = 0;
  events = $getContacts(this$static.world, this$static);
  for (event$index = 0 , event$max = events.length; event$index < event$max; ++event$index) {
    event_0 = events[event$index];
    angle = angle_0(this$static.world.gravityVector, event_0.normal);
    if (angle > 2.3271056693257726 && event_0.body2 == this$static) {
      return true;
    }
    if (angle < 2.3271056693257726 && event_0.body1 == this$static) {
      return true;
    }
  }
  return false;
}

function $collisionWithBouncePlatform(this$static, normal){
  var force;
  force = new Vector2f_1(normal.x * 396, normal.y * 396);
  $add_14(this$static.force_0, force);
}

function $hurt(this$static, nbAppleLose){
  var i, losedAppleSize, scoreDiff;
  $play_0(this$static.hurtSound.val$sound);
  this$static.nbApple == 0 && (this$static.dyingTimedAction = new OneShotTimedAction_0(P77359400_longLit));
  nbAppleLose > this$static.nbApple && (nbAppleLose = this$static.nbApple);
  this$static.nbApple -= nbAppleLose;
  nbAppleLose > 0 && $addLosedApple(this$static.levelScore, nbAppleLose);
  scoreDiff = nbAppleLose * -2;
  scoreDiff != 0 && $addTopLevelEntities(this$static.world, new ScoreVisualIndicator_0);
  losedAppleSize = this$static.shape.getBounds().width_0 / 4;
  for (i = 0; i < nbAppleLose; ++i) {
    $addTopLevelEntities(this$static.world, new LosedApple_0(this$static.world, this$static.position_0, losedAppleSize));
  }
  this$static.isHurt = true;
  this$static.endOfInvincibilityDuration = N1_longLit;
}

function $hurtByPike(this$static, normal){
  var force;
  if (!this$static.isHurt) {
    $hurt(this$static, 5);
    force = new Vector2f_1(normal.x * 288, normal.y * 288);
    $add_14(this$static.force_0, force);
  }
}

function $isFalling(this$static){
  var dp, g, v;
  g = this$static.world.gravityVector;
  dp = $dot(g, this$static.velocity);
  if (dp > 0.10000000149011612) {
    v = new Vector2f_0;
    v.x = dp * g.x;
    v.y = dp * g.y;
    return sqrt(v.x * v.x + v.y * v.y) > 20;
  }
  return false;
}

function $jump(this$static){
  var jump, rot;
  if ($canJump(this$static)) {
    rot = new Matrix2f_1(this$static.world.gravityAngle);
    jump = mul_0(rot, new Vector2f_1(0, 360));
    $add_14(this$static.force_0, jump);
    $play_0(this$static.jumpSound.val$sound);
  }
}

function $moveLeft(this$static){
  var rot, velocity;
  rot = new Matrix2f_1(this$static.world.gravityAngle);
  velocity = mul_0(rot, new Vector2f_1(-8, 0));
  $adjustBiasedVelocity(this$static, velocity);
  $setCurrentMovement(this$static, 0);
}

function $moveRight(this$static){
  var rot, velocity;
  rot = new Matrix2f_1(this$static.world.gravityAngle);
  velocity = mul_0(rot, new Vector2f_1(8, 0));
  $adjustBiasedVelocity(this$static, velocity);
  $setCurrentMovement(this$static, 1);
}

function $removeColoredExcludedBodies(this$static, oldColor){
  var bodies, i, n;
  bodies = $getColoredStaticBodyList(this$static.world, oldColor);
  for (i = 0 , n = bodies.elements.size; i < n; ++i) {
    $removeExcludedBody(this$static, $get(bodies.elements, i));
  }
}

function $setAnimation(this$static, heroAnimation){
  this$static.animations = heroAnimation;
  this$static.play_0 = $getAnimationByName(this$static.animations, 'walk').start_0();
  $stop_0(this$static.play_0);
}

function $setColor_3(this$static, color){
  $removeColoredExcludedBodies(this$static, this$static.color);
  this$static.color = color;
  $addColoredExcludedBodies(this$static, color);
}

function $setCurrentMovement(this$static, currentMovement){
  if ($isFalling(this$static)) {
    $equals_0('falling', this$static.play_0.animation.getName()) || (this$static.play_0 = $getAnimationByName(this$static.animations, 'falling').start_0());
  }
   else {
    if (!$equals_0('walk', this$static.play_0.animation.getName())) {
      this$static.play_0 = $getAnimationByName(this$static.animations, 'walk').start_0();
      this$static.currentMovement == 2 && $stop_0(this$static.play_0);
    }
  }
  if (this$static.currentMovement != currentMovement) {
    this$static.previousMovement = this$static.currentMovement;
    this$static.currentMovement = currentMovement;
    this$static.currentMovement == 2?$stop_0(this$static.play_0):$start_2(this$static.play_0, 1);
  }
}

function $setDeadClock(this$static, duration){
  this$static.deadClock = new OneShotTimedAction_0(duration);
}

function $setHurtSound(this$static, hurtSound){
  this$static.hurtSound = hurtSound;
}

function $setJumpSound(this$static, jumpSound){
  this$static.jumpSound = jumpSound;
}

function $setPickupSound(this$static, pickupSound){
  this$static.pickupSound = pickupSound;
}

function $step(this$static){
  this$static.isResting && $setCurrentMovement(this$static, 2);
}

function $update_8(this$static, frameTimeInfos){
  $update_1(this$static.play_0, div(frameTimeInfos.elapsedTime, Pf4240_longLit));
  this$static.isHurt && (lt(this$static.endOfInvincibilityDuration, P0_longLit)?(this$static.endOfInvincibilityDuration = add_4(frameTimeInfos.currentTime_0, Pb2d05e00_longLit)):gt(frameTimeInfos.currentTime_0, this$static.endOfInvincibilityDuration) && (this$static.isHurt = false));
  if (this$static.dyingTimedAction) {
    $update_6(this$static.dyingTimedAction, frameTimeInfos);
    this$static.isHurt = false;
    this$static.zorder = 1000;
    if (this$static.dyingTimedAction.progress >= 1) {
      throw new GameOverException_0;
    }
  }
   else if (this$static.deadClock) {
    $update_6(this$static.deadClock, frameTimeInfos);
    if (this$static.deadClock.progress >= 1) {
      $hurt(this$static, 1);
      this$static.deadClock = new OneShotTimedAction_0(P77359400_longLit);
    }
  }
}

function Hero_0(world){
  Hero_1.call(this, world, new Circle_0(1));
}

--></script>
<script><!--
function Hero_1(world, shape){
  Body_0.call(this, shape, 1);
  this.levelScore = new LevelScore_0;
  this.color = ($clinit_NewtonColor() , white);
  this.world = world;
  this.rotatable = false;
  $addApple(this.levelScore, this.nbApple);
}

defineSeed(457, 328, makeCastMap([Q$Drawable, Q$Updatable, Q$Hero]), Hero_0);
_.collided = function collided_17(body){
  if (instanceOf(body, Q$Apple)) {
    ++this.nbApple;
    $play_0(this.pickupSound.val$sound);
    this.levelScore.nbApple += 1;
    $addTopLevelEntities(this.world, new ScoreVisualIndicator_0(body));
  }
   else if (instanceOf(body, Q$Coin)) {
    $play_0(this.pickupSound.val$sound);
    this.levelScore.nbCoin += 1;
    $addTopLevelEntities(this.world, new ScoreVisualIndicator_0(body));
  }
   else if (instanceOf(body, Q$WorldMap)) {
    $play_0(this.pickupSound.val$sound);
    this.hasMap = true;
  }
   else if (instanceOf(body, Q$Compass)) {
    $play_0(this.pickupSound.val$sound);
    this.hasCompass = true;
  }
}
;
_.draw = function draw_28(){
  if (this.isHurt) {
    this.isHurtBlinkState = !this.isHurtBlinkState;
    if (this.isHurtBlinkState) {
      return;
    }
  }
  $drawHero(this.world.game.view, this, $getCurrentFrame(this.play_0), this.world);
}
;
_.update_1 = function update_37(frameTimeInfos){
  $update_8(this, frameTimeInfos);
}
;
_.animations = null;
_.currentMovement = 2;
_.deadClock = null;
_.dyingTimedAction = null;
_.endOfInvincibilityDuration = N1_longLit;
_.hasCompass = false;
_.hasMap = false;
_.hurtSound = null;
_.isHurt = false;
_.isHurtBlinkState = false;
_.jumpSound = null;
_.nbApple = 10;
_.nbStepSinceLastJump = 0;
_.pickupSound = null;
_.play_0 = null;
_.previousMovement = 2;
_.world = null;
function $addColoredExcludedBodies_0(this$static, newColor){
  var bodies, i, n;
  bodies = $getColoredStaticBodyList(this$static.world, newColor);
  for (i = 0 , n = bodies.elements.size; i < n; ++i) {
    $addExcludedBody(this$static, $get(bodies.elements, i));
  }
}

function $removeColoredExcludedBodies_0(this$static, oldColor){
  var bodies, i, n;
  bodies = $getColoredStaticBodyList(this$static.world, oldColor);
  for (i = 0 , n = bodies.elements.size; i < n; ++i) {
    $removeExcludedBody(this$static, $get(bodies.elements, i));
  }
}

function $setColor_4(this$static, color){
  $removeColoredExcludedBodies_0(this$static, this$static.color);
  this$static.color = color;
  $addColoredExcludedBodies_0(this$static, color);
}

function $setTexture_8(this$static, texture){
  this$static.play_0 = (texture.animations.map.size_0() == 0?new AnimationCollection$NotReadyFirstAnimation_0(texture):$iterator_0($values(texture.animations)).val$outerIter.next_0().getValue()).start_0();
}

function Key_0(world){
  AbstractDrawableBody_0.call(this, new Circle_0(1), 1);
  this.color = ($clinit_NewtonColor() , white);
  this.world = world;
  this.rotatable = false;
}

defineSeed(458, 328, makeCastMap([Q$Drawable, Q$Updatable, Q$Key]), Key_0);
_.collided = function collided_18(body){
  var door, keyLock;
  if (instanceOf(body, Q$Door)) {
    door = body;
    if (door.isOpenableWithKey(this)) {
      door.isClose = false;
      door.play_0 = $getAnimationByName(door.texture, 'open').start_1(0);
      $removeKey(this.world, this);
      $addTopLevelEntities(this.world, new UsedKey_0(this.world, $getCurrentFrame(this.play_0), this.position_0));
    }
  }
   else if (instanceOf(body, Q$KeyLock)) {
    keyLock = body;
    if (!keyLock.opened && keyLock.color == this.color) {
      keyLock.opened = true;
      $removeKey(this.world, this);
      $addTopLevelEntities(this.world, new UsedKey_0(this.world, $getCurrentFrame(this.play_0), this.position_0));
    }
  }
}
;
_.draw = function draw_29(){
  $drawKey(this.world.game.view, this, $getCurrentFrame(this.play_0), this.world);
}
;
_.update_1 = function update_38(frameTimeInfos){
  $update_1(this.play_0, div(frameTimeInfos.elapsedTime, Pf4240_longLit));
}
;
_.play_0 = null;
_.world = null;
function $setColor_5(this$static, color){
  this$static.color = color;
}

function KeyLock_0(world, w, h_0){
  AnimatedPlatform_0.call(this, world, w, h_0);
  this.color = ($clinit_NewtonColor() , white);
}

defineSeed(459, 426, makeCastMap([Q$Drawable, Q$Updatable, Q$AnimatedPlatform, Q$KeyLock, Q$StaticBody]), KeyLock_0);
_.draw = function draw_30(){
  $drawKeyLock(this.world.game.view, this, this.alpha_0);
}
;
_.update_1 = function update_39(frameTimeInfos){
  this.opened && (lt(this.disappearEndTime, P0_longLit)?(this.disappearEndTime = add_4(frameTimeInfos.currentTime_0, P3b9aca00_longLit)):lt(frameTimeInfos.currentTime_0, this.disappearEndTime)?(this.alpha_0 = toDouble(sub(this.disappearEndTime, frameTimeInfos.currentTime_0)) / 1000000000):$remove_9(this.world, this));
}
;
_.alpha_0 = 1;
_.disappearEndTime = N1_longLit;
_.opened = false;
function LaserBlocker_0(world, w, h_0){
  Blocker_0.call(this, world, 1, w, h_0);
}

defineSeed(460, 433, makeCastMap([Q$Drawable, Q$Updatable, Q$AnimatedPlatform, Q$Blocker, Q$StaticBody]), LaserBlocker_0);
_.collided = function collided_19(other){
  var event_0, event$index, event$max, events, hero, normal;
  if (instanceOf(other, Q$Hero)) {
    hero = other;
    if (hero.isHurt) {
      return;
    }
    events = $getContacts(this.world, this);
    for (event$index = 0 , event$max = events.length; event$index < event$max; ++event$index) {
      event_0 = events[event$index];
      if (event_0.body2 == hero) {
        normal = new Vector2f_2(event_0.normal);
        $hurtByPike(hero, normal);
        return;
      }
       else if (event_0.body1 == hero) {
        normal = new Vector2f_2(event_0.normal);
        $hurtByPike(hero, new Vector2f_1(-normal.x, -normal.y));
        return;
      }
    }
  }
}
;
function Letter_0(world, shape){
  PickableObject_0.call(this, world, shape);
}

defineSeed(461, 444, makeCastMap([Q$Drawable, Q$Updatable, Q$Coin, Q$CollisionDetectionOnly, Q$StaticBody]), Letter_0);
function LosedApple_0(world, position, size){
  this.world = world;
  this.texture = $getCurrentFrame(world.appleIconPlay);
  this.position_0 = new Vector2f_2(position);
  this.direction_0 = mul_0(new Matrix2f_1(Math.random() * 3.141592653589793 * 2), new Vector2f_1(1, 0));
  this.size = size;
}

defineSeed(462, 332, {}, LosedApple_0);
_.draw = function draw_31(){
  $drawLosedApple(this.world.game.view, this, this.world, this.texture, this.alpha_0);
}
;
_.isDead_0 = function isDead_0(){
  return this.isDead;
}
;
_.update_1 = function update_40(frameTimeInfos){
  lt(this.deadTime, P0_longLit)?(this.deadTime = add_4(frameTimeInfos.currentTime_0, P3b9aca00_longLit)):gt(frameTimeInfos.currentTime_0, this.deadTime) && (this.isDead = true);
  $add_14(this.position_0, this.direction_0);
  this.alpha_0 = toDouble(sub(this.deadTime, frameTimeInfos.currentTime_0)) / 1000000000;
}
;
_.alpha_0 = 1;
_.deadTime = N1_longLit;
_.direction_0 = null;
_.isDead = false;
_.position_0 = null;
_.size = 0;
_.texture = null;
_.world = null;
function $activate(this$static){
  var a, b, bodies, i, m_0;
  bodies = this$static.world.bodies;
  for (i = 0; i < bodies.elements.size; ++i) {
    b = $get(bodies.elements, i);
    if (instanceOf(b, Q$Blocker)) {
      a = b;
      if (a.activableId == this$static.activableId) {
        a.activated = true;
        $setTexture(this$static, this$static.onTexture);
      }
    }
     else if (instanceOf(b, Q$MemoryActivator)) {
      m_0 = b;
      if (m_0.activableId == this$static.activableId) {
        m_0.state = 2;
        $setTexture(m_0, m_0.onTexture);
      }
    }
  }
}

function $areAllShown(this$static){
  var b, bodies, i, m_0;
  bodies = this$static.world.bodies;
  for (i = 0; i < bodies.elements.size; ++i) {
    b = $get(bodies.elements, i);
    if (instanceOf(b, Q$MemoryActivator)) {
      m_0 = b;
      if (m_0.activableId == this$static.activableId && m_0.state != 1)
        return false;
    }
  }
  return true;
}

function MemoryActivator_0(world, activableId, onTexture, offTexture, hiddenTexture, w, h_0){
  AnimatedPlatform_0.call(this, world, w, h_0);
  this.activableId = activableId;
  this.offTexture = offTexture;
  this.onTexture = onTexture;
  this.hiddenTexture = hiddenTexture;
  $setTexture(this, hiddenTexture);
}

defineSeed(463, 426, makeCastMap([Q$Drawable, Q$Updatable, Q$AnimatedPlatform, Q$MemoryActivator, Q$StaticBody]), MemoryActivator_0);
_.collided = function collided_20(body){
  if (this.state != 2) {
    if (instanceOf(body, Q$Hero) || instanceOf(body, Q$Key)) {
      this.state = 1;
      $setTexture(this, this.offTexture);
      $areAllShown(this) && $activate(this);
    }
  }
}
;
_.update_1 = function update_41(frameTimeInfos){
  if (this.state == 1) {
    if (lt(this.showEndTime, P0_longLit))
      this.showEndTime = add_4(frameTimeInfos.currentTime_0, P12a05f200_longLit);
    else if (gt(frameTimeInfos.currentTime_0, this.showEndTime)) {
      this.state = 0;
      this.showEndTime = N1_longLit;
      $setTexture(this, this.hiddenTexture);
    }
  }
}
;
_.activableId = 0;
_.hiddenTexture = null;
_.offTexture = null;
_.onTexture = null;
_.showEndTime = N1_longLit;
_.state = 0;
function $setTexture_9(this$static, texture){
  this$static.play_0 = (texture.animations.map.size_0() == 0?new AnimationCollection$NotReadyFirstAnimation_0(texture):$iterator_0($values(texture.animations)).val$outerIter.next_0().getValue()).start_0();
}

function MobilePikeAnchor_0(world){
  MobilePikeAnchor_1.call(this, world, new Circle_0(1));
}

function MobilePikeAnchor_1(world, shape){
  AbstractDrawableStaticBody_0.call(this, shape);
  this.surfaceFriction = 10;
  this.bitmask = or(this.bitmask, P1_longLit);
  this.world = world;
}

defineSeed(464, 330, makeCastMap([Q$Drawable, Q$Updatable, Q$StaticBody]), MobilePikeAnchor_0);
_.draw = function draw_32(){
  $drawMobilePikeAnchor(this.world.game.view, this, $getCurrentFrame(this.play_0));
}
;
_.update_1 = function update_42(frameTimeInfos){
  $update_1(this.play_0, div(frameTimeInfos.elapsedTime, Pf4240_longLit));
}
;
_.play_0 = null;
_.world = null;
function $setTexture_10(this$static, texture){
  this$static.play_0 = (texture.animations.map.size_0() == 0?new AnimationCollection$NotReadyFirstAnimation_0(texture):$iterator_0($values(texture.animations)).val$outerIter.next_0().getValue()).start_0();
}

function MobilePikes_0(world){
  AbstractDrawableBody_0.call(this, new Box_0(1, 3.9000000953674316), 10);
  this.world = world;
  this.damping = 0.019999999552965164;
}

defineSeed(465, 328, makeCastMap([Q$Drawable, Q$Updatable]), MobilePikes_0);
_.collided = function collided_21(other){
  var event_0, event$index, event$max, events, hero, normal;
  if (instanceOf(other, Q$Hero)) {
    hero = other;
    if (hero.isHurt) {
      return;
    }
    events = $getContacts(this.world, this);
    for (event$index = 0 , event$max = events.length; event$index < event$max; ++event$index) {
      event_0 = events[event$index];
      if (event_0.body2 == hero) {
        normal = new Vector2f_2(event_0.normal);
        $hurtByPike(hero, normal);
        return;
      }
       else if (event_0.body1 == hero) {
        normal = new Vector2f_2(event_0.normal);
        $hurtByPike(hero, new Vector2f_1(-normal.x, -normal.y));
        return;
      }
    }
  }
}
;
_.draw = function draw_33(){
  $drawMobilePikes(this.world.game.view, this, $getCurrentFrame(this.play_0));
}
;
_.update_1 = function update_43(frameTimeInfos){
  $update_1(this.play_0, div(frameTimeInfos.elapsedTime, Pf4240_longLit));
}
;
_.play_0 = null;
_.world = null;
function $moveLeft_0(this$static){
  var rot, velocity;
  rot = new Matrix2f_1(this$static.world.gravityAngle);
  velocity = mul_0(rot, new Vector2f_1(-8, 0));
  $adjustBiasedVelocity(this$static, velocity);
  $setCurrentMovement_0(this$static, 0);
}

function $moveRight_0(this$static){
  var rot, velocity;
  rot = new Matrix2f_1(this$static.world.gravityAngle);
  velocity = mul_0(rot, new Vector2f_1(8, 0));
  $adjustBiasedVelocity(this$static, velocity);
  $setCurrentMovement_0(this$static, 1);
}

function $setCurrentMovement_0(this$static, currentMovement){
  if (this$static.currentMovement != currentMovement) {
    this$static.previousMovement = this$static.currentMovement;
    this$static.currentMovement = currentMovement;
    this$static.currentMovement == 2?$stop_0(this$static.play_0):$start_2(this$static.play_0, 1);
  }
}

function Mummy_0(world, shape, animation){
  Body_0.call(this, shape, 1);
  this.world = world;
  this.play_0 = (animation.animations.map.size_0() == 0?new AnimationCollection$NotReadyFirstAnimation_0(animation):$iterator_0($values(animation.animations)).val$outerIter.next_0().getValue()).start_0();
  this.rotatable = false;
}

defineSeed(466, 328, makeCastMap([Q$Drawable, Q$Updatable]), Mummy_0);
_.collided = function collided_22(other){
  var angle, event_0, events, hero, i, normal;
  if (!this.isDead) {
    if (instanceOf(other, Q$Hero)) {
      events = $getContacts(this.world, this);
      hero = other;
      for (i = 0; i < events.length; ++i) {
        event_0 = events[i];
        if (event_0.body2 == hero) {
          normal = new Vector2f_2(event_0.normal);
          angle = angle_0(normal, this.world.gravityVector);
          if (angle < 0.7853981633974483) {
            hero.isHurt || $hurt(hero, 1);
          }
           else {
            this.isDead = true;
            ++hero.levelScore.nbKilledMummy;
            $addTopLevelEntities(hero.world, new ScoreVisualIndicator_0(hero));
          }
        }
         else if (event_0.body1 == hero) {
          normal = new Vector2f_2(event_0.normal);
          angle = angle_0(normal, this.world.gravityVector);
          if (angle > 0.7853981633974483) {
            hero.isHurt || $hurt(hero, 1);
          }
           else {
            this.isDead = true;
            ++hero.levelScore.nbKilledMummy;
            $addTopLevelEntities(hero.world, new ScoreVisualIndicator_0(hero));
          }
        }
      }
    }
    this.isDead && (this.moveable = false);
  }
}
;
_.draw = function draw_34(){
  $drawMummy(this.world.game.view, this, $getCurrentFrame(this.play_0), this.scale_0);
}
;
_.update_1 = function update_44(frameTimeInfos){
  if (this.isDead) {
    if (lt(this.beginOfDyingDuration, P0_longLit)) {
      this.beginOfDyingDuration = frameTimeInfos.currentTime_0;
    }
     else {
      this.scale_0 = 1 - toDouble(sub(frameTimeInfos.currentTime_0, this.beginOfDyingDuration)) / 1000000000;
      this.scale_0 <= 0 && $remove_9(this.world, this);
    }
    return;
  }
  if (gt(frameTimeInfos.currentTime_0, this.nextChangeDirectionTime)) {
    this.nextChangeDirectionTime = add_4(frameTimeInfos.currentTime_0, Pee6b2800_longLit);
    this.currentMovement == 0?$moveRight_0(this):$moveLeft_0(this);
  }
   else {
    this.currentMovement == 0?$moveLeft_0(this):$moveRight_0(this);
  }
  this.currentMovement == 2 || $update_1(this.play_0, div(frameTimeInfos.elapsedTime, Pf4240_longLit));
}
;
_.beginOfDyingDuration = N1_longLit;
_.currentMovement = 2;
_.isDead = false;
_.nextChangeDirectionTime = P0_longLit;
_.play_0 = null;
_.previousMovement = 2;
_.scale_0 = 1;
_.world = null;
function PickedUpObject_0(world, texture, position, size){
  this.world = world;
  this.texture = texture;
  this.position_0 = new Vector2f_2(position);
  this.size = size;
  this.originalSize = size;
}

defineSeed(467, 332, {}, PickedUpObject_0);
_.draw = function draw_35(){
  $drawPickedUpObject(this.world.game.view, this, this.world, this.texture);
}
;
_.isDead_0 = function isDead_1(){
  return this.canMove && sqrt($distanceSquared(this.position_0, this.world.hero.position_0)) < this.size;
}
;
_.update_1 = function update_45(frameTimeInfos){
  var direction;
  if (this.canMove) {
    direction = new Vector2f_2(this.world.hero.position_0);
    $sub(direction, this.position_0);
    $normalise(direction);
    $add_14(this.position_0, direction);
  }
   else {
    if (lt(this.canMoveTime, P0_longLit)) {
      this.canMoveTime = add_4(frameTimeInfos.currentTime_0, P11e1a300_longLit);
    }
     else {
      this.canMove = gt(frameTimeInfos.currentTime_0, this.canMoveTime);
      this.canMove?(this.size = this.originalSize * 0.5):(this.size = this.originalSize * (0.5 + 0.5 * toDouble(sub(this.canMoveTime, frameTimeInfos.currentTime_0)) / 300000000));
    }
  }
}
;
_.canMove = false;
_.canMoveTime = N1_longLit;
_.originalSize = 0;
_.position_0 = null;
_.size = 0;
_.texture = null;
_.world = null;
function Pikes_0(world, dangerousSide, w, h_0){
  AnimatedPlatform_0.call(this, world, w, h_0);
  this.pikes = new PikesComponent_0;
  $setDangerousSide(this.pikes, dangerousSide);
}

defineSeed(468, 426, makeCastMap([Q$Drawable, Q$Updatable, Q$AnimatedPlatform, Q$StaticBody]), Pikes_0);
_.collided = function collided_23(other){
  $collided(this.pikes, this.world, this, this.w, this.h_0, other);
}
;
function $collided(this$static, world, aThis, aThisW, aThisH, other){
  var event_0, events, hero, i, normal, point;
  if (instanceOf(other, Q$Hero)) {
    hero = other;
    if (hero.isHurt) {
      return;
    }
    events = $getContacts(world, aThis);
    for (i = 0; i < events.length; ++i) {
      event_0 = events[i];
      point = event_0.point;
      if ($isPointOnDangerousSide(this$static, aThis.position_0, aThisW, aThisH, point)) {
        if (event_0.body2 == hero) {
          normal = new Vector2f_2(event_0.normal);
          $hurtByPike(hero, normal);
        }
         else if (event_0.body1 == hero) {
          normal = new Vector2f_2(event_0.normal);
          $hurtByPike(hero, new Vector2f_1(-normal.x, -normal.y));
        }
        return;
      }
    }
  }
}

function $isPointOnDangerousSide(this$static, position, w, h_0, point){
  switch (this$static.dangerousSide.ordinal) {
    case 0:
      return point.y >= position.y + h_0 * 0.44999998807907104;
    case 1:
      return point.y <= position.y - h_0 * 0.45;
    case 3:
      return point.x >= position.x + w * 0.44999998807907104;
    case 2:
      return point.x <= position.x - w * 0.44999998807907104;
  }
  return false;
}

function $setDangerousSide(this$static, dangerousSide){
  this$static.dangerousSide = dangerousSide;
}

function PikesComponent_0(){
}

defineSeed(469, 1, {}, PikesComponent_0);
_.dangerousSide = null;
function $clinit_PikesComponent$DangerousSide(){
  $clinit_PikesComponent$DangerousSide = nullMethod;
  UP_0 = new PikesComponent$DangerousSide_0('UP', 0);
  DOWN_0 = new PikesComponent$DangerousSide_0('DOWN', 1);
  LEFT_1 = new PikesComponent$DangerousSide_0('LEFT', 2);
  RIGHT_1 = new PikesComponent$DangerousSide_0('RIGHT', 3);
  $VALUES_21 = initValues(_3Lim_bci_newtonadv_world_PikesComponent$DangerousSide_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$PikesComponent$DangerousSide, [UP_0, DOWN_0, LEFT_1, RIGHT_1]);
}

function PikesComponent$DangerousSide_0(enum$name, enum$ordinal){
  Enum_0.call(this, enum$name, enum$ordinal);
}

function valueOf_1(name_0){
  $clinit_PikesComponent$DangerousSide();
  return valueOf(($clinit_PikesComponent$DangerousSide$Map() , $MAP_0), name_0);
}

function values_22(){
  $clinit_PikesComponent$DangerousSide();
  return $VALUES_21;
}

defineSeed(470, 11, makeCastMap([Q$PikesComponent$DangerousSide, Q$Serializable, Q$Comparable, Q$Enum]), PikesComponent$DangerousSide_0);
var $VALUES_21, DOWN_0, LEFT_1, RIGHT_1, UP_0;
function $clinit_PikesComponent$DangerousSide$Map(){
  $clinit_PikesComponent$DangerousSide$Map = nullMethod;
  $MAP_0 = createValueOfMap(($clinit_PikesComponent$DangerousSide() , $VALUES_21));
}

var $MAP_0;
function ScoreVisualIndicator_0(){
  this.zorder = 1;
}

defineSeed(472, 332, {}, ScoreVisualIndicator_0);
_.draw = function draw_36(){
}
;
_.isDead_0 = function isDead_2(){
  return this.isDead;
}
;
_.update_1 = function update_46(frameTimeInfos){
  if (lt(this.endTime, P0_longLit)) {
    this.endTime = add_4(frameTimeInfos.currentTime_0, P17d78400_longLit);
  }
   else {
    2 - toDouble(sub(this.endTime, frameTimeInfos.currentTime_0)) / 400000000;
    this.isDead = gt(frameTimeInfos.currentTime_0, this.endTime);
  }
}
;
_.endTime = N1_longLit;
_.isDead = false;
function $setTexture_11(this$static, texture){
  this$static.texture = texture;
}

function $setU1(this$static, u1){
  this$static.u1 = u1;
}

function $setU2(this$static, u2){
  this$static.u2 = u2;
}

function $setV1(this$static, v1){
  this$static.v1 = v1;
}

function $setV2(this$static, v2){
  this$static.v2 = v2;
}

function $setZOrder_2(this$static, zOrder){
  this$static.zOrder = zOrder;
}

function StaticPlatform_0(w, h_0){
  StaticBody_0.call(this, new Box_0(w, h_0));
  this.surfaceFriction = 10;
  this.bitmask = or(this.bitmask, P1_longLit);
}

defineSeed(474, 331, makeCastMap([Q$StaticPlatform, Q$StaticBody]), StaticPlatform_0);
_.drawable = null;
_.texture = null;
_.u1 = 0;
_.u2 = 1;
_.v1 = 0;
_.v2 = 1;
_.vertexBufferIndex = 0;
_.zOrder = 0;
function StaticPikes_0(world, dangerousSide, w, h_0){
  StaticPlatform_0.call(this, w, h_0);
  this.pikes = new PikesComponent_0;
  this.w = w;
  this.h_0 = h_0;
  this.world = world;
  $setDangerousSide(this.pikes, dangerousSide);
}

defineSeed(473, 474, makeCastMap([Q$StaticPlatform, Q$StaticBody]), StaticPikes_0);
_.collided = function collided_24(other){
  $collided(this.pikes, this.world, this, this.w, this.h_0, other);
}
;
_.h_0 = 0;
_.w = 0;
_.world = null;
function $addBody(this$static, body){
  instanceOf(body, Q$StaticBody)?(this$static.needToBeRebuild = true):$add_16(this$static.dynamicBodies, body);
}

function $classifyBodies(this$static, bodies){
  var b, i;
  $clear(this$static.staticBodies);
  $clear(this$static.dynamicBodies.elements);
  for (i = 0; i < bodies.elements.size; ++i) {
    b = $get(bodies.elements, i);
    b.isStatic()?$add_0(this$static.staticBodies, b):$add_16(this$static.dynamicBodies, b);
  }
}

function $collideBodies(this$static, context, bodies){
  var space, space$iterator;
  if (this$static.needToBeRebuild) {
    $classifyBodies(this$static, bodies);
    this$static.rootSpace = new StaticQuadSpaceStrategy$Space_1(this$static, this$static.staticBodies);
    $recursiveSplit(this$static, this$static.rootSpace, 0);
    this$static.needToBeRebuild = false;
  }
   else 
    this$static.removedStaticBodies.size != 0 && ($update_9(this$static.rootSpace) , $clear(this$static.removedStaticBodies));
  $clear(this$static.spaceWithPotentialCollision);
  $recursiveFindSpaceWithPotentialCollision(this$static, this$static.rootSpace, this$static.dynamicBodies);
  for (space$iterator = new AbstractList$IteratorImpl_0(this$static.spaceWithPotentialCollision); space$iterator.i < space$iterator.this$0_0.size_0();) {
    space = $next_2(space$iterator);
    $resolve_1(context, space.bodiesForCollides);
  }
}

function $findVisibleBodies(this$static, camera_x1, camera_y1, camera_x2, camera_y2){
  var b, b$iterator, bodiesSet, i, visibleBodies;
  visibleBodies = new BodyList_0;
  if (this$static.needToBeRebuild) {
    return visibleBodies;
  }
  bodiesSet = new HashSet_0;
  $recursiveFindVisibleBodies(this$static, this$static.rootSpace, camera_x1, camera_y1, camera_x2, camera_y2, bodiesSet);
  for (b$iterator = $iterator($keySet(bodiesSet.map)); b$iterator.val$outerIter.hasNext();) {
    b = $next_3(b$iterator);
    $add_0(visibleBodies.elements, b);
  }
  for (i = 0; i < this$static.dynamicBodies.elements.size; ++i) {
    $add_16(visibleBodies, $get_11(this$static.dynamicBodies, i));
  }
  return visibleBodies;
}

function $getStaticBounds(this$static){
  return this$static.rootSpace?new AbsoluteAABox_1(this$static.rootSpace):new AbsoluteAABox_0;
}

function $recursiveFindSpaceWithPotentialCollision(this$static, space, dynBodies){
  var b, b$iterator, i, subSpace, subSpace$iterator;
  $clear(space.bodiesForCollides.elements);
  for (i = 0; i < dynBodies.elements.size; ++i) {
    b = $get(dynBodies.elements, i);
    $touches(space, b) && $add_16(space.bodiesForCollides, b);
  }
  if (space.bodiesForCollides.elements.size != 0) {
    if (space.subSpaces.size == 0) {
      $add_0(this$static.spaceWithPotentialCollision, space);
      for (b$iterator = new AbstractList$IteratorImpl_0(space.staticBodiesInSpace); b$iterator.i < b$iterator.this$0_0.size_0();) {
        b = $next_2(b$iterator);
        $add_16(space.bodiesForCollides, b);
      }
    }
     else {
      for (subSpace$iterator = new AbstractList$IteratorImpl_0(space.subSpaces); subSpace$iterator.i < subSpace$iterator.this$0_0.size_0();) {
        subSpace = $next_2(subSpace$iterator);
        $recursiveFindSpaceWithPotentialCollision(this$static, subSpace, space.bodiesForCollides);
      }
    }
  }
}

function $recursiveFindVisibleBodies(this$static, space, camera_x1, camera_y1, camera_x2, camera_y2, visibleBodies){
  var i, s, s$iterator;
  if (!(space.x2 < camera_x1 || space.y2 < camera_y1 || space.x1 > camera_x2 || space.y1 > camera_y2)) {
    if (space.subSpaces.size == 0) {
      for (i = 0; i < space.staticBodiesInSpace.size; ++i) {
        visibleBodies.add($get(space.staticBodiesInSpace, i));
      }
    }
     else {
      for (s$iterator = new AbstractList$IteratorImpl_0(space.subSpaces); s$iterator.i < s$iterator.this$0_0.size_0();) {
        s = $next_2(s$iterator);
        $recursiveFindVisibleBodies(this$static, s, camera_x1, camera_y1, camera_x2, camera_y2, visibleBodies);
      }
    }
  }
}

function $recursiveSplit(this$static, space, level){
  var s, s$iterator, width, height;
  if (level > this$static.maxLevels) {
    return;
  }
  if (space.staticBodiesInSpace.size <= this$static.maxInSpace) {
    return;
  }
  width = (space.x2 - space.x1) / 2;
  height = (space.y2 - space.y1) / 2;
  $clear(space.subSpaces);
  $add_0(space.subSpaces, new StaticQuadSpaceStrategy$Space_0(space.this$0, space, space.x1, space.y1, width, height));
  $add_0(space.subSpaces, new StaticQuadSpaceStrategy$Space_0(space.this$0, space, space.x1, space.y1 + height, width, height));
  $add_0(space.subSpaces, new StaticQuadSpaceStrategy$Space_0(space.this$0, space, space.x1 + width, space.y1, width, height));
  $add_0(space.subSpaces, new StaticQuadSpaceStrategy$Space_0(space.this$0, space, space.x1 + width, space.y1 + height, width, height));
  for (s$iterator = new AbstractList$IteratorImpl_0(space.subSpaces); s$iterator.i < s$iterator.this$0_0.size_0();) {
    s = $next_2(s$iterator);
    $recursiveSplit(this$static, s, level + 1);
  }
}

function $removeBody(this$static, body){
  instanceOf(body, Q$StaticBody)?$add_0(this$static.removedStaticBodies, body):$remove_18(this$static.dynamicBodies, body);
}

function StaticQuadSpaceStrategy_0(){
  this.staticBodies = new ArrayList_0;
  this.dynamicBodies = new BodyList_0;
  this.spaceWithPotentialCollision = new ArrayList_0;
  this.removedStaticBodies = new ArrayList_0;
  this.maxInSpace = 20;
  this.maxLevels = 5;
}

defineSeed(475, 1, {}, StaticQuadSpaceStrategy_0);
_.maxInSpace = 0;
_.maxLevels = 0;
_.needToBeRebuild = true;
_.rootSpace = null;
function $$init_1(this$static){
  this$static.staticBodiesInSpace = new ArrayList_0;
  this$static.subSpaces = new ArrayList_0;
  this$static.bodiesForCollides = new BodyList_0;
}

function $touches(this$static, body){
  var box, h_0, w, xp, yp;
  box = body.shape.getBounds();
  xp = body.position_0.x;
  yp = body.position_0.y;
  w = box.width_0;
  h_0 = box.height_0;
  return !(this$static.x2 < xp - w || this$static.y2 < yp - h_0 || this$static.x1 > xp + w || this$static.y1 > yp + h_0);
}

function $update_9(this$static){
  var it, s;
  if ($removeAll(this$static.staticBodiesInSpace, this$static.this$0.removedStaticBodies)) {
    it = new AbstractList$IteratorImpl_0(this$static.subSpaces);
    while (it.i < it.this$0_0.size_0()) {
      s = $next_2(it);
      $update_9(s);
      this$static.staticBodiesInSpace.size == 0 && $remove_10(it);
    }
  }
}

function StaticQuadSpaceStrategy$Space_0(this$0, parent_0, x1, y1, width, height){
  var body, body$iterator;
  this.this$0 = this$0;
  $$init_1(this);
  this.x1 = x1;
  this.y1 = y1;
  this.x2 = x1 + width;
  this.y2 = y1 + height;
  for (body$iterator = new AbstractList$IteratorImpl_0(parent_0.staticBodiesInSpace); body$iterator.i < body$iterator.this$0_0.size_0();) {
    body = $next_2(body$iterator);
    $touches(this, body) && $add_0(this.staticBodiesInSpace, body);
  }
}

function StaticQuadSpaceStrategy$Space_1(this$0, bodies){
  var body, body$iterator, box, bx1, bx2, by1, by2, xp, yp;
  this.this$0 = this$0;
  $$init_1(this);
  for (body$iterator = new AbstractList$IteratorImpl_0(bodies); body$iterator.i < body$iterator.this$0_0.size_0();) {
    body = $next_2(body$iterator);
    $add_0(this.staticBodiesInSpace, body);
    box = body.shape.getBounds();
    xp = body.position_0.x;
    yp = body.position_0.y;
    bx1 = xp - box.width_0;
    bx2 = xp + box.width_0;
    by1 = yp - box.height_0;
    by2 = yp + box.height_0;
    this.x1 = min(bx1, this.x1);
    this.y1 = min(by1, this.y1);
    this.x2 = max_0(bx2, this.x2);
    this.y2 = max_0(by2, this.y2);
  }
}

defineSeed(476, 419, {}, StaticQuadSpaceStrategy$Space_0, StaticQuadSpaceStrategy$Space_1);
_.this$0 = null;
function $setColor_6(this$static, color){
  this$static.color = color;
}

function Teleporter_0(world, w, h_0){
  AnimatedPlatform_0.call(this, world, w, h_0);
}

defineSeed(477, 426, makeCastMap([Q$Drawable, Q$Updatable, Q$AnimatedPlatform, Q$CollisionDetectionOnly, Q$Teleporter, Q$StaticBody]), Teleporter_0);
_.collided = function collided_25(body){
  instanceOf(body, Q$Hero) && (this.collideHero = true);
}
;
--></script>
<script><!--
_.update_1 = function update_47(frameTimeInfos){
  if (this.collideHero) {
    if (lt(this.teleportTime, P0_longLit))
      this.teleportTime = add_4(frameTimeInfos.currentTime_0, P77359400_longLit);
    else if (gt(frameTimeInfos.currentTime_0, this.teleportTime)) {
      this.teleportTime = N1_longLit;
      $teleportFrom(this.world, this);
    }
  }
   else {
    this.teleportTime = N1_longLit;
  }
  this.collideHero = false;
}
;
_.collideHero = false;
_.color = null;
_.teleportTime = N1_longLit;
function $clinit_TmxLoader(){
  $clinit_TmxLoader = nullMethod;
  defaultPickableObjectShape = new Circle_0(1);
  defaultMapProperties = new HashMap_0;
  defaultMapProperties.put('newton_adventure.mummy', 'mummy.json');
  defaultMapProperties.put('newton_adventure.bat', 'bat.json');
  defaultMapProperties.put('newton_adventure.explosion', 'explosion.json');
  defaultMapProperties.put('newton_adventure.fireball', 'fireball.png');
  defaultMapProperties.put('newton_adventure.bomb', 'bomb.json');
  defaultMapProperties.put('newton_adventure.crate', 'crate.json');
  defaultMapProperties.put('newton_adventure.axe', 'axe.png');
  defaultMapProperties.put('newton_adventure.mobilePikes', 'mobile_pikes.png');
  defaultMapProperties.put('newton_adventure.door_to_bonus_world', 'door_to_bonus_world.json');
  defaultMapProperties.put('newton_adventure.door', 'door.json');
  defaultMapProperties.put('newton_adventure.key', 'key.json');
  defaultMapProperties.put('newton_adventure.clue', 'clue.json');
  defaultMapProperties.put('newton_adventure.hero', 'hero.json');
  defaultMapProperties.put('newton_adventure.apple', 'apple.png');
  defaultMapProperties.put('newton_adventure.coin', 'coin.png');
  defaultMapProperties.put('newton_adventure.world_map', 'map.png');
  defaultMapProperties.put('newton_adventure.compass', 'compass.png');
  defaultMapProperties.put('newton_adventure.activator1.on', 'actived1.png');
  defaultMapProperties.put('newton_adventure.activator2.on', 'actived2.png');
  defaultMapProperties.put('newton_adventure.activator3.on', 'actived3.png');
  defaultMapProperties.put('newton_adventure.activator1.off', 'activable1.png');
  defaultMapProperties.put('newton_adventure.activator2.off', 'activable2.png');
  defaultMapProperties.put('newton_adventure.activator3.off', 'activable3.png');
  defaultMapProperties.put('newton_adventure.memory_activator.hidden', 'activable_hidden.png');
  defaultMapProperties.put('newton_adventure.blocker1', 'blocker1.png');
  defaultMapProperties.put('newton_adventure.blocker2', 'blocker2.png');
  defaultMapProperties.put('newton_adventure.blocker3', 'blocker3.png');
  defaultMapProperties.put('newton_adventure.music', 'hopnbop.ogg');
  defaultMapProperties.put('newton_adventure.rotate_gravity_possible', 'true');
}

function $finishLoading(this$static){
  var backgroundTextureFile;
  backgroundTextureFile = $getFileFromMapIfAvailable(this$static, this$static.map, 'newton_adventure.background');
  null != backgroundTextureFile && $setBackgroundTexture(this$static.world, $getTexture(this$static.game.view.textureCache, backgroundTextureFile));
  $playMusic(this$static.game.platform.toolkit.audio, $getFileFromMap(this$static, this$static.map, 'newton_adventure.music'), true);
  $setIsRotateGravityPossible(this$static.world, $equals_0('true', $getMapProperty(this$static.map)));
  $postConstruct(this$static.world.staticPlatformDrawer, this$static.world.game.view);
}

function $getAnimationForTile(this$static, tile, defaultAnimation){
  var animation, gfx;
  gfx = $getProperty(tile.tile, 'newton_adventure.gfx', null);
  null != gfx?(animation = $loadFromAnimation(this$static.game.view, $getLevelFilePath(this$static.game.data, this$static.questName, this$static.levelName, gfx))):(animation = defaultAnimation);
  return animation;
}

function $getAnimationForTile_0(this$static, tile, textureCache){
  var animation, frame, gfx, image, imageHeight, imageWidth;
  gfx = $getProperty(tile.tile, 'newton_adventure.gfx', null);
  if (null != gfx) {
    animation = $loadFromAnimation(this$static.game.view, $getLevelFilePath(this$static.game.data, this$static.questName, this$static.levelName, gfx));
  }
   else {
    frame = tile.tile.frame;
    image = frame.image;
    imageWidth = image.width_0;
    imageHeight = image.height_0;
    animation = new AnimationCollection_2($getTexture(textureCache, image.source), frame.x1 / imageWidth, frame.y1 / imageHeight, frame.x2 / imageWidth, frame.y2 / imageHeight);
  }
  return animation;
}

function $getFileFromMap(this$static, map, filePropertyName){
  var filename;
  filename = $getFileFromMapIfAvailable(this$static, map, filePropertyName);
  if (filename != null) {
    return filename;
  }
   else {
    throw new RuntimeException_1('error in tmx map file, cannot find property ' + filePropertyName);
  }
}

function $getFileFromMapIfAvailable(this$static, map, filePropertyName){
  var filename;
  filename = getProperty(map.properties, filePropertyName, null);
  if (filename == null) {
    filename = defaultMapProperties.get_1(filePropertyName);
    if (filename == null) {
      return null;
    }
  }
  return $getLevelFilePath(this$static.game.data, this$static.questName, this$static.levelName, filename);
}

function $getMapProperty(map){
  var value;
  value = getProperty(map.properties, 'newton_adventure.rotate_gravity_possible', null);
  if (null == value) {
    return defaultMapProperties.get_1('newton_adventure.rotate_gravity_possible');
  }
  return value;
}

function $getMovingPlatformPath(tile, x, y){
  var ax, ay, bx, by, dest;
  dest = initDim(_3Lnet_phys2d_math_Vector2f_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Vector2f, 2, 0);
  ax = parseFloat_0($getProperty(tile.tile, 'newton_adventure.moving_platform.a.x', '-1'));
  ay = parseFloat_0($getProperty(tile.tile, 'newton_adventure.moving_platform.a.y', '-1'));
  bx = parseFloat_0($getProperty(tile.tile, 'newton_adventure.moving_platform.b.x', '1'));
  by = parseFloat_0($getProperty(tile.tile, 'newton_adventure.moving_platform.b.y', '1'));
  ax += x;
  bx += x;
  ay += y;
  by += y;
  ax *= 2;
  bx *= 2;
  ay *= 2;
  by *= 2;
  dest[0] = new Vector2f_1(ax, ay);
  dest[1] = new Vector2f_1(bx, by);
  return dest;
}

function $getTileZOrder(tile, zOrderBase, defaultZ){
  var z, zprop;
  z = zOrderBase;
  zprop = $getProperty(tile.tile, 'newton_adventure.zorder', null);
  null == zprop?(z += defaultZ):(z += __parseAndValidateInt(zprop));
  return z;
}

--></script>
<script><!--
function $initFromTile(this$static, x, y, map, tile, zOrderBase){
  var accelerator, activable, activator, anchor, animation, apple, axe, bat, bomb, bombHole, boss, c, cannon, cloud, clue, coin, color, colored, colorizer, compass, crate, deadClock, door, gfx, helpSign, j, key, keylock, letter, mummy, pikes, platform, side, teleporter, textureCache, tileHeight, tileHeightScale, tileWidth, tileWidthScale, tileX, tileY, worldMap, deadclock, ax, ay;
  textureCache = this$static.game.view.textureCache;
  c = $getProperty(tile.tile, 'newton_adventure.type', 'unknown');
  tileWidthScale = $getWidth_0(tile.tile.frame) / map.tilewidth;
  tileHeightScale = $getHeight_0(tile.tile.frame) / map.tileheight;
  tileWidth = 2 * tileWidthScale;
  tileHeight = 2 * tileHeightScale;
  tileX = x * 2 + tileWidth / 2;
  tileY = y * 2 + tileHeight / 2;
  if ($equals_0(c, 'platform')) {
    gfx = $getProperty(tile.tile, 'newton_adventure.gfx', null);
    if (null != gfx) {
      animation = $loadFromAnimation(this$static.game.view, $getLevelFilePath(this$static.game.data, this$static.questName, this$static.levelName, gfx));
      platform = new AnimatedPlatform_0(this$static.world, tileWidth, tileHeight);
      $setTexture(platform, animation);
      $setPosition_0(platform, tileX, tileY);
      $setFriction(platform, parseFloat_0($getProperty(tile.tile, 'newton_adventure.friction', '10')));
      $setZOrder_0(platform, $getTileZOrder(tile, zOrderBase, 0));
      $add_9(this$static.world, platform);
    }
     else {
      platform = new StaticPlatform_0(tileWidth, tileHeight);
      $setTextureFromTile(tile, platform, textureCache);
      $set_4(platform.position_0, tileX, tileY);
      $set_4(platform.lastPosition, tileX, tileY);
      $setZOrder_2(platform, $getTileZOrder(tile, zOrderBase, 0));
      $setFriction(platform, parseFloat_0($getProperty(tile.tile, 'newton_adventure.friction', '10')));
      $addStaticPlatform_0(this$static.world, platform);
    }
  }
   else if ($equals_0(c, 'slash_platform')) {
    gfx = $getProperty(tile.tile, 'newton_adventure.gfx', null);
    if (null != gfx) {
      platform = new AnimatedPlatform_0(this$static.world, tileWidth, tileHeight);
      $setTexture(platform, $getAnimationForTile_0(this$static, tile, textureCache));
      $setPosition_0(platform, tileX, tileY);
      $setShape(platform, new Line_0(-tileWidth / 2, -tileHeight / 2, tileWidth / 2, tileHeight / 2));
      $setFriction(platform, parseFloat_0($getProperty(tile.tile, 'newton_adventure.friction', '10')));
      $setZOrder_0(platform, $getTileZOrder(tile, zOrderBase, 0));
      $add_9(this$static.world, platform);
    }
     else {
      platform = new StaticPlatform_0(tileWidth, tileHeight);
      $setTextureFromTile(tile, platform, textureCache);
      $setShape(platform, new Line_0(-tileWidth / 2, -tileHeight / 2, tileWidth / 2, tileHeight / 2));
      $set_4(platform.position_0, tileX, tileY);
      $set_4(platform.lastPosition, tileX, tileY);
      $setZOrder_2(platform, $getTileZOrder(tile, zOrderBase, 0));
      $setFriction(platform, parseFloat_0($getProperty(tile.tile, 'newton_adventure.friction', '10')));
      $addStaticPlatform_0(this$static.world, platform);
    }
  }
   else if ($equals_0(c, 'antislash_platform')) {
    gfx = $getProperty(tile.tile, 'newton_adventure.gfx', null);
    if (null != gfx) {
      platform = new AnimatedPlatform_0(this$static.world, tileWidth, tileHeight);
      $setTexture(platform, $getAnimationForTile_0(this$static, tile, textureCache));
      $setPosition_0(platform, tileX, tileY);
      $setShape(platform, new Line_0(-tileWidth / 2, tileHeight / 2, tileWidth / 2, -tileHeight / 2));
      $setFriction(platform, parseFloat_0($getProperty(tile.tile, 'newton_adventure.friction', '10')));
      $setZOrder_0(platform, $getTileZOrder(tile, zOrderBase, 0));
      $add_9(this$static.world, platform);
    }
     else {
      platform = new StaticPlatform_0(tileWidth, tileHeight);
      $setTextureFromTile(tile, platform, textureCache);
      $setShape(platform, new Line_0(-tileWidth / 2, tileHeight / 2, tileWidth / 2, -tileHeight / 2));
      $set_4(platform.position_0, tileX, tileY);
      $set_4(platform.lastPosition, tileX, tileY);
      $setZOrder_2(platform, $getTileZOrder(tile, zOrderBase, 0));
      $setFriction(platform, parseFloat_0($getProperty(tile.tile, 'newton_adventure.friction', '10')));
      $addStaticPlatform_0(this$static.world, platform);
    }
  }
   else if ($equals_0(c, 'up_right_half_platform')) {
    gfx = $getProperty(tile.tile, 'newton_adventure.gfx', null);
    if (null != gfx) {
      platform = new AnimatedPlatform_0(this$static.world, tileWidth, tileHeight);
      $setTexture(platform, $getAnimationForTile_0(this$static, tile, textureCache));
      $setPosition_0(platform, tileX, tileY);
      $setShape(platform, new ConvexPolygon_0(initValues(_3Lnet_phys2d_math_ROVector2f_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$ROVector2f, [new Vector2f_1(-tileWidth / 2, tileHeight / 2), new Vector2f_1(tileWidth / 2, -tileHeight / 2), new Vector2f_1(tileWidth / 2, tileHeight / 2)])));
      $setFriction(platform, parseFloat_0($getProperty(tile.tile, 'newton_adventure.friction', '10')));
      $setZOrder_0(platform, $getTileZOrder(tile, zOrderBase, 0));
      $add_9(this$static.world, platform);
    }
     else {
      platform = new StaticPlatform_0(tileWidth, tileHeight);
      $setTextureFromTile(tile, platform, textureCache);
      $setShape(platform, new ConvexPolygon_0(initValues(_3Lnet_phys2d_math_ROVector2f_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$ROVector2f, [new Vector2f_1(-tileWidth / 2, tileHeight / 2), new Vector2f_1(tileWidth / 2, -tileHeight / 2), new Vector2f_1(tileWidth / 2, tileHeight / 2)])));
      $set_4(platform.position_0, tileX, tileY);
      $set_4(platform.lastPosition, tileX, tileY);
      $setZOrder_2(platform, $getTileZOrder(tile, zOrderBase, 0));
      $setFriction(platform, parseFloat_0($getProperty(tile.tile, 'newton_adventure.friction', '10')));
      $addStaticPlatform_0(this$static.world, platform);
    }
  }
   else if ($equals_0(c, 'up_left_half_platform')) {
    gfx = $getProperty(tile.tile, 'newton_adventure.gfx', null);
    if (null != gfx) {
      platform = new AnimatedPlatform_0(this$static.world, tileWidth, tileHeight);
      $setTexture(platform, $getAnimationForTile_0(this$static, tile, textureCache));
      $setPosition_0(platform, tileX, tileY);
      $setShape(platform, new ConvexPolygon_0(initValues(_3Lnet_phys2d_math_ROVector2f_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$ROVector2f, [new Vector2f_1(-tileWidth / 2, tileHeight / 2), new Vector2f_1(-tileWidth / 2, -tileHeight / 2), new Vector2f_1(tileWidth / 2, tileHeight / 2)])));
      $setFriction(platform, parseFloat_0($getProperty(tile.tile, 'newton_adventure.friction', '10')));
      $setZOrder_0(platform, $getTileZOrder(tile, zOrderBase, 0));
      $add_9(this$static.world, platform);
    }
     else {
      platform = new StaticPlatform_0(tileWidth, tileHeight);
      $setTextureFromTile(tile, platform, textureCache);
      $setShape(platform, new ConvexPolygon_0(initValues(_3Lnet_phys2d_math_ROVector2f_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$ROVector2f, [new Vector2f_1(-tileWidth / 2, tileHeight / 2), new Vector2f_1(-tileWidth / 2, -tileHeight / 2), new Vector2f_1(tileWidth / 2, tileHeight / 2)])));
      $set_4(platform.position_0, tileX, tileY);
      $set_4(platform.lastPosition, tileX, tileY);
      $setZOrder_2(platform, $getTileZOrder(tile, zOrderBase, 0));
      $setFriction(platform, parseFloat_0($getProperty(tile.tile, 'newton_adventure.friction', '10')));
      $addStaticPlatform_0(this$static.world, platform);
    }
  }
   else if ($equals_0(c, 'down_left_half_platform')) {
    gfx = $getProperty(tile.tile, 'newton_adventure.gfx', null);
    if (null != gfx) {
      platform = new AnimatedPlatform_0(this$static.world, tileWidth, tileHeight);
      $setTexture(platform, $getAnimationForTile_0(this$static, tile, textureCache));
      $setPosition_0(platform, tileX, tileY);
      $setShape(platform, new ConvexPolygon_0(initValues(_3Lnet_phys2d_math_ROVector2f_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$ROVector2f, [new Vector2f_1(-tileWidth / 2, tileHeight / 2), new Vector2f_1(-tileWidth / 2, -tileHeight / 2), new Vector2f_1(tileWidth / 2, -tileHeight / 2)])));
      $setFriction(platform, parseFloat_0($getProperty(tile.tile, 'newton_adventure.friction', '10')));
      $setZOrder_0(platform, $getTileZOrder(tile, zOrderBase, 0));
      $add_9(this$static.world, platform);
    }
     else {
      platform = new StaticPlatform_0(tileWidth, tileHeight);
      $setTextureFromTile(tile, platform, textureCache);
      $setShape(platform, new ConvexPolygon_0(initValues(_3Lnet_phys2d_math_ROVector2f_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$ROVector2f, [new Vector2f_1(-tileWidth / 2, tileHeight / 2), new Vector2f_1(-tileWidth / 2, -tileHeight / 2), new Vector2f_1(tileWidth / 2, -tileHeight / 2)])));
      $set_4(platform.position_0, tileX, tileY);
      $set_4(platform.lastPosition, tileX, tileY);
      $setZOrder_2(platform, $getTileZOrder(tile, zOrderBase, 0));
      $setFriction(platform, parseFloat_0($getProperty(tile.tile, 'newton_adventure.friction', '10')));
      $addStaticPlatform_0(this$static.world, platform);
    }
  }
   else if ($equals_0(c, 'down_right_half_platform')) {
    gfx = $getProperty(tile.tile, 'newton_adventure.gfx', null);
    if (null != gfx) {
      platform = new AnimatedPlatform_0(this$static.world, tileWidth, tileHeight);
      $setTexture(platform, $getAnimationForTile_0(this$static, tile, textureCache));
      $setPosition_0(platform, tileX, tileY);
      $setShape(platform, new ConvexPolygon_0(initValues(_3Lnet_phys2d_math_ROVector2f_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$ROVector2f, [new Vector2f_1(-tileWidth / 2, -tileHeight / 2), new Vector2f_1(tileWidth / 2, -tileHeight / 2), new Vector2f_1(tileWidth / 2, tileHeight / 2)])));
      $setFriction(platform, parseFloat_0($getProperty(tile.tile, 'newton_adventure.friction', '10')));
      $setZOrder_0(platform, $getTileZOrder(tile, zOrderBase, 0));
      $add_9(this$static.world, platform);
    }
     else {
      platform = new StaticPlatform_0(tileWidth, tileHeight);
      $setTextureFromTile(tile, platform, textureCache);
      $setShape(platform, new ConvexPolygon_0(initValues(_3Lnet_phys2d_math_ROVector2f_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$ROVector2f, [new Vector2f_1(-tileWidth / 2, -tileHeight / 2), new Vector2f_1(tileWidth / 2, -tileHeight / 2), new Vector2f_1(tileWidth / 2, tileHeight / 2)])));
      $set_4(platform.position_0, tileX, tileY);
      $set_4(platform.lastPosition, tileX, tileY);
      $setZOrder_2(platform, $getTileZOrder(tile, zOrderBase, 0));
      $setFriction(platform, parseFloat_0($getProperty(tile.tile, 'newton_adventure.friction', '10')));
      $addStaticPlatform_0(this$static.world, platform);
    }
  }
   else if ($equals_0(c, 'hero')) {
    if (!this$static.hero) {
      this$static.hero = new Hero_0(this$static.world);
      $setPosition(this$static.hero, tileX, tileY);
      $setZOrder(this$static.hero, $getTileZOrder(tile, zOrderBase, 0));
      $setAnimation(this$static.hero, $loadFromAnimation(this$static.game.view, $getFileFromMap(this$static, map, 'newton_adventure.hero')));
      $setJumpSound(this$static.hero, $getSound(this$static.game.platform.toolkit.audio, (this$static.game , 'jump.wav')));
      $setPickupSound(this$static.hero, $getSound(this$static.game.platform.toolkit.audio, (this$static.game , 'pickup.wav')));
      $setHurtSound(this$static.hero, $getSound(this$static.game.platform.toolkit.audio, (this$static.game , 'hurt.wav')));
      deadClock = (deadclock = getProperty(map.properties, 'newton_adventure.deadclock', null) , null != deadclock?valueOf_4(mul((new Long_0(__parseAndValidateLong(deadclock))).value_0, P3b9aca00_longLit)):null);
      !!deadClock && $setDeadClock(this$static.hero, deadClock.value_0);
      $setHero(this$static.world, this$static.hero);
    }
  }
   else if ($equals_0(c, 'mummy')) {
    mummy = new Mummy_0(this$static.world, new Circle_0(1), (!this$static.mummyAnimation && (this$static.mummyAnimation = $loadFromAnimation(this$static.game.view, $getFileFromMap(this$static, this$static.map, 'newton_adventure.mummy'))) , this$static.mummyAnimation));
    $set_4(mummy.position_0, tileX, tileY);
    $set_4(mummy.lastPosition, tileX, tileY);
    $setZOrder(mummy, $getTileZOrder(tile, zOrderBase, 0));
    $add_9(this$static.world, mummy);
  }
   else if ($equals_0(c, 'bat')) {
    bat = new Bat_0(this$static.world, new Box_0(1, 0.5), (!this$static.batAnimation && (this$static.batAnimation = $loadFromAnimation(this$static.game.view, $getFileFromMap(this$static, this$static.map, 'newton_adventure.bat'))) , this$static.batAnimation));
    $set_4(bat.position_0, tileX, tileY);
    $set_4(bat.lastPosition, tileX, tileY);
    $setZOrder(bat, $getTileZOrder(tile, zOrderBase, 0));
    $add_9(this$static.world, bat);
  }
   else if ($equals_0(c, 'apple')) {
    apple = new Apple_0(this$static.world, defaultPickableObjectShape);
    $set_4(apple.position_0, tileX, tileY);
    $set_4(apple.lastPosition, tileX, tileY);
    $setTexture_0(apple, (!this$static.appleIconTexture && (this$static.appleIconTexture = $loadFromAnimation(this$static.game.view, $getFileFromMap(this$static, this$static.map, 'newton_adventure.apple'))) , this$static.appleIconTexture));
    $setZOrder_1(apple, $getTileZOrder(tile, zOrderBase, 0));
    $addApple_0(this$static.world, apple);
  }
   else if ($equals_0(c, 'coin')) {
    coin = new Coin_0(this$static.world, defaultPickableObjectShape);
    $set_4(coin.position_0, tileX, tileY);
    $set_4(coin.lastPosition, tileX, tileY);
    $setTexture_0(coin, (!this$static.coinTexture && (this$static.coinTexture = $loadFromAnimation(this$static.game.view, $getFileFromMap(this$static, this$static.map, 'newton_adventure.coin'))) , this$static.coinTexture));
    $setZOrder_1(coin, $getTileZOrder(tile, zOrderBase, 0));
    $addCoin(this$static.world, coin);
  }
   else if ($equals_0(c, 'letter')) {
    letter = new Letter_0(this$static.world, defaultPickableObjectShape);
    $set_4(letter.position_0, tileX, tileY);
    $set_4(letter.lastPosition, tileX, tileY);
    $setTexture_0(letter, $getAnimationForTile_0(this$static, tile, textureCache));
    $setZOrder_1(letter, $getTileZOrder(tile, zOrderBase + 10, 0));
    $addCoin(this$static.world, letter);
  }
   else if ($equals_0(c, 'world_map')) {
    worldMap = new WorldMap_0(this$static.world, defaultPickableObjectShape);
    $set_4(worldMap.position_0, tileX, tileY);
    $set_4(worldMap.lastPosition, tileX, tileY);
    $setTexture_0(worldMap, (!this$static.worldMapTexture && (this$static.worldMapTexture = $loadFromAnimation(this$static.game.view, $getFileFromMap(this$static, this$static.map, 'newton_adventure.world_map'))) , this$static.worldMapTexture));
    $setZOrder_1(worldMap, $getTileZOrder(tile, zOrderBase, 0));
    $add_9(this$static.world, worldMap);
  }
   else if ($equals_0(c, 'compass')) {
    compass = new Compass_0(this$static.world, defaultPickableObjectShape);
    $set_4(compass.position_0, tileX, tileY);
    $set_4(compass.lastPosition, tileX, tileY);
    $setTexture_0(compass, (!this$static.compassTexture && (this$static.compassTexture = $loadFromAnimation(this$static.game.view, $getFileFromMap(this$static, this$static.map, 'newton_adventure.compass'))) , this$static.compassTexture));
    $setZOrder_1(compass, $getTileZOrder(tile, zOrderBase, 0));
    $add_9(this$static.world, compass);
  }
   else if ($equals_0(c, 'key')) {
    key = new Key_0(this$static.world);
    $set_4(key.position_0, tileX, tileY);
    $set_4(key.lastPosition, tileX, tileY);
    $setTexture_8(key, (!this$static.keyTexture && (this$static.keyTexture = $loadFromAnimation(this$static.game.view, $getFileFromMap(this$static, this$static.map, 'newton_adventure.key'))) , this$static.keyTexture));
    $setZOrder(key, $getTileZOrder(tile, zOrderBase, 0));
    $setColor_4(key, valueOf_0($getProperty(tile.tile, 'newton_adventure.color', 'white')));
    $addKey(this$static.world, key);
  }
   else if ($equals_0(c, 'door')) {
    door = new Door_0(this$static.world, tileWidth, tileHeight);
    $set_4(door.position_0, tileX, tileY);
    $set_4(door.lastPosition, tileX, tileY);
    $setTexture_6(door, (!this$static.doorTexture && (this$static.doorTexture = $loadFromAnimation(this$static.game.view, $getFileFromMap(this$static, this$static.map, 'newton_adventure.door'))) , this$static.doorTexture));
    $setZOrder_0(door, $getTileZOrder(tile, zOrderBase, 0));
    $setColor_2(door, valueOf_0($getProperty(tile.tile, 'newton_adventure.color', 'white')));
    $add_9(this$static.world, door);
  }
   else if ($equals_0(c, 'door_to_bonus_world')) {
    door = new DoorToBonusWorld_0(this$static.world, tileWidth, tileHeight);
    $set_4(door.position_0, tileX, tileY);
    $set_4(door.lastPosition, tileX, tileY);
    $setTexture_6(door, (!this$static.doorToBonusWorldTexture && (this$static.doorToBonusWorldTexture = $loadFromAnimation(this$static.game.view, $getFileFromMap(this$static, this$static.map, 'newton_adventure.door_to_bonus_world'))) , this$static.doorToBonusWorldTexture));
    $setZOrder_0(door, $getTileZOrder(tile, zOrderBase, 0));
    $setColor_2(door, valueOf_0($getProperty(tile.tile, 'newton_adventure.color', 'white')));
    $add_9(this$static.world, door);
  }
   else if ($equals_0(c, 'cloud')) {
    cloud = new Cloud_0(this$static.world, tileWidth, tileHeight);
    $setTexture(cloud, $getAnimationForTile_0(this$static, tile, textureCache));
    $setPosition_0(cloud, tileX, tileY);
    $setZOrder_0(cloud, $getTileZOrder(tile, zOrderBase, 0));
    $setColor(cloud, valueOf_0($getProperty(tile.tile, 'newton_adventure.color', 'white')));
    $add_9(this$static.world, cloud);
  }
   else if (c.indexOf('pikes_') == 0) {
    gfx = $getProperty(tile.tile, 'newton_adventure.gfx', null);
    side = valueOf_1($replaceFirst(c, 'pikes_', '').toUpperCase());
    if (null != gfx) {
      pikes = new Pikes_0(this$static.world, side, tileWidth, tileHeight);
      $setTexture(pikes, $getAnimationForTile_0(this$static, tile, textureCache));
      $setPosition_0(pikes, tileX, tileY);
      $setZOrder_0(pikes, $getTileZOrder(tile, zOrderBase, 0));
      $add_9(this$static.world, pikes);
    }
     else {
      pikes = new StaticPikes_0(this$static.world, side, tileWidth, tileHeight);
      $setTextureFromTile(tile, pikes, textureCache);
      $set_4(pikes.position_0, tileX, tileY);
      $set_4(pikes.lastPosition, tileX, tileY);
      $setZOrder_2(pikes, $getTileZOrder(tile, zOrderBase, 0));
      $addStaticPlatform_0(this$static.world, pikes);
    }
  }
   else if ($equals_0(c, 'cannon_up')) {
    cannon = new Cannon_0(this$static.world, ($clinit_Cannon$Orientation() , UP), tileWidth, tileHeight);
    $setTexture(cannon, $getAnimationForTile_0(this$static, tile, textureCache));
    $setFireBallTexture_1(cannon, (!this$static.fireBallTexture && (this$static.fireBallTexture = $loadFromAnimation(this$static.game.view, $getFileFromMap(this$static, this$static.map, 'newton_adventure.fireball'))) , this$static.fireBallTexture));
    $setExplosionTexture_2(cannon, (!this$static.explosionAnimation && (this$static.explosionAnimation = $loadFromAnimation(this$static.game.view, $getFileFromMap(this$static, this$static.map, 'newton_adventure.explosion'))) , this$static.explosionAnimation));
    $setPosition_0(cannon, tileX, tileY);
    $setZOrder_0(cannon, $getTileZOrder(tile, zOrderBase, 0));
    $add_9(this$static.world, cannon);
  }
   else if ($equals_0(c, 'cannon_down')) {
    cannon = new Cannon_0(this$static.world, ($clinit_Cannon$Orientation() , DOWN), tileWidth, tileHeight);
    $setTexture(cannon, $getAnimationForTile_0(this$static, tile, textureCache));
    $setFireBallTexture_1(cannon, (!this$static.fireBallTexture && (this$static.fireBallTexture = $loadFromAnimation(this$static.game.view, $getFileFromMap(this$static, this$static.map, 'newton_adventure.fireball'))) , this$static.fireBallTexture));
    $setExplosionTexture_2(cannon, (!this$static.explosionAnimation && (this$static.explosionAnimation = $loadFromAnimation(this$static.game.view, $getFileFromMap(this$static, this$static.map, 'newton_adventure.explosion'))) , this$static.explosionAnimation));
    $setPosition_0(cannon, tileX, tileY);
    $setZOrder_0(cannon, $getTileZOrder(tile, zOrderBase, 0));
    $add_9(this$static.world, cannon);
  }
   else if ($equals_0(c, 'cannon_right')) {
    cannon = new Cannon_0(this$static.world, ($clinit_Cannon$Orientation() , RIGHT_0), tileWidth, tileHeight);
    $setTexture(cannon, $getAnimationForTile_0(this$static, tile, textureCache));
    $setFireBallTexture_1(cannon, (!this$static.fireBallTexture && (this$static.fireBallTexture = $loadFromAnimation(this$static.game.view, $getFileFromMap(this$static, this$static.map, 'newton_adventure.fireball'))) , this$static.fireBallTexture));
    $setExplosionTexture_2(cannon, (!this$static.explosionAnimation && (this$static.explosionAnimation = $loadFromAnimation(this$static.game.view, $getFileFromMap(this$static, this$static.map, 'newton_adventure.explosion'))) , this$static.explosionAnimation));
    $setPosition_0(cannon, tileX, tileY);
    $setZOrder_0(cannon, $getTileZOrder(tile, zOrderBase, 0));
    $add_9(this$static.world, cannon);
  }
   else if ($equals_0(c, 'cannon_left')) {
    cannon = new Cannon_0(this$static.world, ($clinit_Cannon$Orientation() , LEFT_0), tileWidth, tileHeight);
    $setTexture(cannon, $getAnimationForTile_0(this$static, tile, textureCache));
    $setFireBallTexture_1(cannon, (!this$static.fireBallTexture && (this$static.fireBallTexture = $loadFromAnimation(this$static.game.view, $getFileFromMap(this$static, this$static.map, 'newton_adventure.fireball'))) , this$static.fireBallTexture));
    $setExplosionTexture_2(cannon, (!this$static.explosionAnimation && (this$static.explosionAnimation = $loadFromAnimation(this$static.game.view, $getFileFromMap(this$static, this$static.map, 'newton_adventure.explosion'))) , this$static.explosionAnimation));
    $setPosition_0(cannon, tileX, tileY);
    $setZOrder_0(cannon, $getTileZOrder(tile, zOrderBase, 0));
    $add_9(this$static.world, cannon);
  }
   else if ($equals_0(c, 'mobile_pike_anchor')) {
    anchor = new MobilePikeAnchor_0(this$static.world);
    $setTexture_9(anchor, $getAnimationForTile_0(this$static, tile, textureCache));
    $set_4(anchor.position_0, tileX, tileY);
    $set_4(anchor.lastPosition, tileX, tileY);
    $setZOrder_0(anchor, $getTileZOrder(tile, zOrderBase, 0));
    $add_9(this$static.world, anchor);
    pikes = new MobilePikes_0(this$static.world);
    $setTexture_10(pikes, (!this$static.mobilePikesTexture && (this$static.mobilePikesTexture = $loadFromAnimation(this$static.game.view, $getFileFromMap(this$static, this$static.map, 'newton_adventure.mobilePikes'))) , this$static.mobilePikesTexture));
    $setPosition(pikes, anchor.position_0.x, anchor.position_0.y - 1.9500000476837158 - anchor.shape.getBounds().height_0 / 2);
    $add_9(this$static.world, pikes);
    $setZOrder(pikes, $getTileZOrder(tile, zOrderBase, 0));
    j = new BasicJoint_0(anchor, pikes, new Vector2f_2(anchor.position_0));
    j.relaxation = 0;
    $add_8(this$static.world, j);
  }
   else if ($equals_0(c, 'axe_anchor')) {
    anchor = new AxeAnchor_0(this$static.world);
    $setTexture_2(anchor, $getAnimationForTile_0(this$static, tile, textureCache));
    $set_4(anchor.position_0, tileX, tileY);
    $set_4(anchor.lastPosition, tileX, tileY);
    $setZOrder_0(anchor, $getTileZOrder(tile, zOrderBase, 0));
    $add_9(this$static.world, anchor);
    axe = new Axe_0(this$static.world);
    $setTexture_1(axe, (!this$static.axeTexture && (this$static.axeTexture = $loadFromAnimation(this$static.game.view, $getFileFromMap(this$static, this$static.map, 'newton_adventure.axe'))) , this$static.axeTexture));
    $setPosition(axe, anchor.position_0.x, anchor.position_0.y - 1.9500000476837158 - anchor.shape.getBounds().height_0 / 2);
    $setZOrder(axe, $getTileZOrder(tile, zOrderBase, 0));
    $add_9(this$static.world, axe);
    j = new BasicJoint_0(anchor, axe, new Vector2f_2(anchor.position_0));
    j.relaxation = 0;
    $add_8(this$static.world, j);
  }
   else if ($equals_0(c, 'bounce_platform')) {
    platform = new BouncePlatform_0(this$static.world, tileWidth, tileHeight);
    $setTexture(platform, $getAnimationForTile_0(this$static, tile, textureCache));
    $setPosition_0(platform, tileX, tileY);
    $setZOrder_0(platform, $getTileZOrder(tile, zOrderBase, 0));
    $add_9(this$static.world, platform);
  }
   else if ($equals_0(c, 'activator1')) {
    activator = new Activator_0(this$static.world, 1, (!this$static.activator1OnTexture && (this$static.activator1OnTexture = $loadFromAnimation(this$static.game.view, $getFileFromMap(this$static, this$static.map, 'newton_adventure.activator1.on'))) , this$static.activator1OnTexture), (!this$static.activator1OffTexture && (this$static.activator1OffTexture = $loadFromAnimation(this$static.game.view, $getFileFromMap(this$static, this$static.map, 'newton_adventure.activator1.off'))) , this$static.activator1OffTexture), tileWidth, tileHeight);
    $setPosition_0(activator, tileX, tileY);
    $setZOrder_0(activator, $getTileZOrder(tile, zOrderBase, 0));
    $add_9(this$static.world, activator);
  }
   else if ($equals_0(c, 'activator2')) {
    activator = new Activator_0(this$static.world, 2, (!this$static.activator2OnTexture && (this$static.activator2OnTexture = $loadFromAnimation(this$static.game.view, $getFileFromMap(this$static, this$static.map, 'newton_adventure.activator2.on'))) , this$static.activator2OnTexture), (!this$static.activator2OffTexture && (this$static.activator2OffTexture = $loadFromAnimation(this$static.game.view, $getFileFromMap(this$static, this$static.map, 'newton_adventure.activator2.off'))) , this$static.activator2OffTexture), tileWidth, tileHeight);
    $setPosition_0(activator, tileX, tileY);
    $setZOrder_0(activator, $getTileZOrder(tile, zOrderBase, 0));
    $add_9(this$static.world, activator);
  }
   else if ($equals_0(c, 'activator3')) {
    activator = new Activator_0(this$static.world, 3, (!this$static.activator3OnTexture && (this$static.activator3OnTexture = $loadFromAnimation(this$static.game.view, $getFileFromMap(this$static, this$static.map, 'newton_adventure.activator3.on'))) , this$static.activator3OnTexture), (!this$static.activator3OffTexture && (this$static.activator3OffTexture = $loadFromAnimation(this$static.game.view, $getFileFromMap(this$static, this$static.map, 'newton_adventure.activator3.off'))) , this$static.activator3OffTexture), tileWidth, tileHeight);
    $setPosition_0(activator, tileX, tileY);
    $setZOrder_0(activator, $getTileZOrder(tile, zOrderBase, 0));
    $add_9(this$static.world, activator);
  }
   else if ($equals_0(c, 'memory_activator1')) {
    activator = new MemoryActivator_0(this$static.world, 1, (!this$static.activator1OnTexture && (this$static.activator1OnTexture = $loadFromAnimation(this$static.game.view, $getFileFromMap(this$static, this$static.map, 'newton_adventure.activator1.on'))) , this$static.activator1OnTexture), (!this$static.activator1OffTexture && (this$static.activator1OffTexture = $loadFromAnimation(this$static.game.view, $getFileFromMap(this$static, this$static.map, 'newton_adventure.activator1.off'))) , this$static.activator1OffTexture), (!this$static.memoryActivatorHiddenTexture && (this$static.memoryActivatorHiddenTexture = $loadFromAnimation(this$static.game.view, $getFileFromMap(this$static, this$static.map, 'newton_adventure.memory_activator.hidden'))) , this$static.memoryActivatorHiddenTexture), tileWidth, tileHeight);
    $setPosition_0(activator, tileX, tileY);
    $setZOrder_0(activator, $getTileZOrder(tile, zOrderBase, 0));
    $add_9(this$static.world, activator);
  }
   else if ($equals_0(c, 'memory_activator2')) {
    activator = new MemoryActivator_0(this$static.world, 2, (!this$static.activator2OnTexture && (this$static.activator2OnTexture = $loadFromAnimation(this$static.game.view, $getFileFromMap(this$static, this$static.map, 'newton_adventure.activator2.on'))) , this$static.activator2OnTexture), (!this$static.activator2OffTexture && (this$static.activator2OffTexture = $loadFromAnimation(this$static.game.view, $getFileFromMap(this$static, this$static.map, 'newton_adventure.activator2.off'))) , this$static.activator2OffTexture), (!this$static.memoryActivatorHiddenTexture && (this$static.memoryActivatorHiddenTexture = $loadFromAnimation(this$static.game.view, $getFileFromMap(this$static, this$static.map, 'newton_adventure.memory_activator.hidden'))) , this$static.memoryActivatorHiddenTexture), tileWidth, tileHeight);
    $setPosition_0(activator, tileX, tileY);
    $setZOrder_0(activator, $getTileZOrder(tile, zOrderBase, 0));
    $add_9(this$static.world, activator);
  }
   else if ($equals_0(c, 'memory_activator3')) {
    activator = new MemoryActivator_0(this$static.world, 3, (!this$static.activator3OnTexture && (this$static.activator3OnTexture = $loadFromAnimation(this$static.game.view, $getFileFromMap(this$static, this$static.map, 'newton_adventure.activator3.on'))) , this$static.activator3OnTexture), (!this$static.activator3OffTexture && (this$static.activator3OffTexture = $loadFromAnimation(this$static.game.view, $getFileFromMap(this$static, this$static.map, 'newton_adventure.activator3.off'))) , this$static.activator3OffTexture), (!this$static.memoryActivatorHiddenTexture && (this$static.memoryActivatorHiddenTexture = $loadFromAnimation(this$static.game.view, $getFileFromMap(this$static, this$static.map, 'newton_adventure.memory_activator.hidden'))) , this$static.memoryActivatorHiddenTexture), tileWidth, tileHeight);
    $setPosition_0(activator, tileX, tileY);
    $setZOrder_0(activator, $getTileZOrder(tile, zOrderBase, 0));
    $add_9(this$static.world, activator);
  }
   else if ($equals_0(c, 'blocker1')) {
    activable = new Blocker_0(this$static.world, 1, tileWidth, tileHeight);
    $setTexture(activable, $getAnimationForTile(this$static, tile, (!this$static.blocker1Texture && (this$static.blocker1Texture = $loadFromAnimation(this$static.game.view, $getFileFromMap(this$static, this$static.map, 'newton_adventure.blocker1'))) , this$static.blocker1Texture)));
    $setPosition_0(activable, tileX, tileY);
    $setZOrder_0(activable, $getTileZOrder(tile, zOrderBase, 0));
    $add_9(this$static.world, activable);
  }
   else if ($equals_0(c, 'blocker2')) {
    activable = new Blocker_0(this$static.world, 2, tileWidth, tileHeight);
    $setTexture(activable, $getAnimationForTile(this$static, tile, (!this$static.blocker2Texture && (this$static.blocker2Texture = $loadFromAnimation(this$static.game.view, $getFileFromMap(this$static, this$static.map, 'newton_adventure.blocker2'))) , this$static.blocker2Texture)));
    $setPosition_0(activable, tileX, tileY);
    $setZOrder_0(activable, $getTileZOrder(tile, zOrderBase, 0));
    $add_9(this$static.world, activable);
  }
   else if ($equals_0(c, 'blocker3')) {
    activable = new Blocker_0(this$static.world, 3, tileWidth, tileHeight);
    $setTexture(activable, $getAnimationForTile(this$static, tile, (!this$static.blocker3Texture && (this$static.blocker3Texture = $loadFromAnimation(this$static.game.view, $getFileFromMap(this$static, this$static.map, 'newton_adventure.blocker3'))) , this$static.blocker3Texture)));
    $setPosition_0(activable, tileX, tileY);
    $setZOrder_0(activable, $getTileZOrder(tile, zOrderBase, 0));
    $add_9(this$static.world, activable);
  }
   else if ($equals_0(c, 'laser_blocker')) {
    activable = new LaserBlocker_0(this$static.world, tileWidth, tileHeight);
    $setTexture(activable, $getAnimationForTile(this$static, tile, (!this$static.blocker1Texture && (this$static.blocker1Texture = $loadFromAnimation(this$static.game.view, $getFileFromMap(this$static, this$static.map, 'newton_adventure.blocker1'))) , this$static.blocker1Texture)));
    $setPosition_0(activable, tileX, tileY);
    $setZOrder_0(activable, $getTileZOrder(tile, zOrderBase, 0));
    $add_9(this$static.world, activable);
  }
   else if ($equals_0(c, 'accelerator')) {
    accelerator = new Accelerator_0(this$static.world, tileWidth, tileHeight, (ax = parseFloat_0($getProperty(tile.tile, 'newton_adventure.accelerator.ax', '0.0')) , ay = parseFloat_0($getProperty(tile.tile, 'newton_adventure.accelerator.ay', '0.0')) , new Vector2f_1(ax, ay)));
    $setTexture(accelerator, $getAnimationForTile_0(this$static, tile, textureCache));
    $setPosition_0(accelerator, tileX, tileY);
    $setFriction(accelerator, parseFloat_0($getProperty(tile.tile, 'newton_adventure.friction', '10')));
    $setZOrder_0(accelerator, $getTileZOrder(tile, zOrderBase, 0));
    $add_9(this$static.world, accelerator);
  }
   else if ($equals_0(c, 'moving_platform')) {
    platform = new MovingPlatform_0(this$static.world, $getAnimationForTile_0(this$static, tile, textureCache), $getMovingPlatformPath(tile, x, y), tileWidth, tileHeight);
    $set_4(platform.position_0, tileX, tileY);
    $set_4(platform.lastPosition, tileX, tileY);
    $setFriction(platform, parseFloat_0($getProperty(tile.tile, 'newton_adventure.friction', '10')));
    $setZOrder(platform, $getTileZOrder(tile, zOrderBase, 0));
    $add_9(this$static.world, platform);
  }
   else if ($equals_0(c, 'dangerous_moving_platform')) {
    platform = new DangerousMovingPlatform_0(this$static.world, $getAnimationForTile_0(this$static, tile, textureCache), $getMovingPlatformPath(tile, x, y), tileWidth, tileHeight);
    $setColor_1(platform, valueOf_0($getProperty(tile.tile, 'newton_adventure.color', 'white')));
    $set_4(platform.position_0, tileX, tileY);
    $set_4(platform.lastPosition, tileX, tileY);
    $setFriction(platform, parseFloat_0($getProperty(tile.tile, 'newton_adventure.friction', '10')));
    $setZOrder(platform, $getTileZOrder(tile, zOrderBase, 0));
    $add_9(this$static.world, platform);
  }
   else if ($equals_0(c, 'teleporter')) {
    teleporter = new Teleporter_0(this$static.world, tileWidth, tileHeight);
    $setTexture(teleporter, $getAnimationForTile_0(this$static, tile, textureCache));
    $setPosition_0(teleporter, tileX, tileY);
    $setZOrder_0(teleporter, $getTileZOrder(tile, zOrderBase, 1));
    $setColor_6(teleporter, $getProperty(tile.tile, 'newton_adventure.teleporter.color', 'white'));
    $add_9(this$static.world, teleporter);
  }
   else if ($equals_0(c, 'colorizer')) {
    colorizer = new Colorizer_0(this$static.world, tileWidth, tileHeight);
    $setTexture(colorizer, $getAnimationForTile_0(this$static, tile, textureCache));
    $setPosition_0(colorizer, tileX, tileY);
    $setZOrder_0(colorizer, $getTileZOrder(tile, zOrderBase, 1));
    $setColor_0(colorizer, valueOf_0($getProperty(tile.tile, 'newton_adventure.color', 'white')));
    $add_9(this$static.world, colorizer);
  }
   else if ($equals_0(c, 'colored_platform')) {
    colored = new ColoredPlatform_0(this$static.world, tileWidth, tileHeight);
    $setTexture(colored, $getAnimationForTile_0(this$static, tile, textureCache));
    $setPosition_0(colored, tileX, tileY);
    $setZOrder_0(colored, $getTileZOrder(tile, zOrderBase, 1));
    color = valueOf_0($getProperty(tile.tile, 'newton_adventure.color', 'white'));
    $addColoredPlatform(this$static.world, color, colored);
  }
   else if ($equals_0(c, 'keylock')) {
    keylock = new KeyLock_0(this$static.world, tileWidth, tileHeight);
    $setTexture(keylock, $getAnimationForTile_0(this$static, tile, textureCache));
    $setPosition_0(keylock, tileX, tileY);
    $setZOrder_0(keylock, $getTileZOrder(tile, zOrderBase, 0));
    $setColor_5(keylock, valueOf_0($getProperty(tile.tile, 'newton_adventure.color', 'white')));
    $add_9(this$static.world, keylock);
  }
   else if ($equals_0(c, 'help_sign')) {
    helpSign = new HelpSign_0(this$static.world, tileWidth, tileHeight);
    $setTexture(helpSign, $getAnimationForTile_0(this$static, tile, textureCache));
    $setPosition_0(helpSign, tileX, tileY);
    $setZOrder_0(helpSign, $getTileZOrder(tile, zOrderBase, 0));
    $add_9(this$static.world, helpSign);
    clue = new Clue_0(this$static.world, tileWidth / 2, tileHeight / 2);
    $setTexture(clue, (!this$static.clueTexture && (this$static.clueTexture = $loadFromAnimation(this$static.game.view, $getFileFromMap(this$static, this$static.map, 'newton_adventure.clue'))) , this$static.clueTexture));
    clue.anchor = new Vector2f_1(tileX, tileY + tileHeight);
    $setZOrder_0(clue, $getTileZOrder(tile, zOrderBase, 0));
    $add_9(this$static.world, clue);
  }
   else if ($equals_0(c, 'bomb')) {
    bomb = new Bomb_0(this$static.world);
    $setTexture_3(bomb, (!this$static.bombTexture && (this$static.bombTexture = $loadFromAnimation(this$static.game.view, $getFileFromMap(this$static, this$static.map, 'newton_adventure.bomb'))) , this$static.bombTexture));
    $setFireBallTexture(bomb, (!this$static.fireBallTexture && (this$static.fireBallTexture = $loadFromAnimation(this$static.game.view, $getFileFromMap(this$static, this$static.map, 'newton_adventure.fireball'))) , this$static.fireBallTexture));
    $setExplosionTexture(bomb, (!this$static.explosionAnimation && (this$static.explosionAnimation = $loadFromAnimation(this$static.game.view, $getFileFromMap(this$static, this$static.map, 'newton_adventure.explosion'))) , this$static.explosionAnimation));
    $set_4(bomb.position_0, tileX, tileY);
    $set_4(bomb.lastPosition, tileX, tileY);
    $setZOrder(bomb, $getTileZOrder(tile, zOrderBase, 0));
    $add_9(this$static.world, bomb);
  }
   else if ($equals_0(c, 'bomb_hole')) {
    bombHole = new BombHole_0(this$static.world, tileWidth, tileHeight);
    $setBombTexture(bombHole, (!this$static.bombTexture && (this$static.bombTexture = $loadFromAnimation(this$static.game.view, $getFileFromMap(this$static, this$static.map, 'newton_adventure.bomb'))) , this$static.bombTexture));
    $setFireBallTexture_0(bombHole, (!this$static.fireBallTexture && (this$static.fireBallTexture = $loadFromAnimation(this$static.game.view, $getFileFromMap(this$static, this$static.map, 'newton_adventure.fireball'))) , this$static.fireBallTexture));
    $setExplosionTexture_0(bombHole, (!this$static.explosionAnimation && (this$static.explosionAnimation = $loadFromAnimation(this$static.game.view, $getFileFromMap(this$static, this$static.map, 'newton_adventure.explosion'))) , this$static.explosionAnimation));
    $setTexture(bombHole, $getAnimationForTile_0(this$static, tile, textureCache));
    $setPosition_0(bombHole, tileX, tileY);
    $setZOrder_0(bombHole, $getTileZOrder(tile, zOrderBase, 0));
    $add_9(this$static.world, bombHole);
  }
   else if ($equals_0(c, 'crate')) {
    crate = new Crate_0(this$static.world, tileWidth, tileHeight);
    $setTexture(crate, (!this$static.crateTexture && (this$static.crateTexture = $loadFromAnimation(this$static.game.view, $getFileFromMap(this$static, this$static.map, 'newton_adventure.crate'))) , this$static.crateTexture));
    $setPosition_0(crate, tileX, tileY);
    $setZOrder_0(crate, $getTileZOrder(tile, zOrderBase, 0));
    $add_9(this$static.world, crate);
  }
   else if ($equals_0(c, 'boss')) {
    boss = new Boss_0(this$static.world, tileX, tileY);
    $setTexture_4(boss, $getAnimationForTile_0(this$static, tile, textureCache));
    $setExplosionTexture_1(boss, (!this$static.explosionAnimation && (this$static.explosionAnimation = $loadFromAnimation(this$static.game.view, $getFileFromMap(this$static, this$static.map, 'newton_adventure.explosion'))) , this$static.explosionAnimation));
    $setZOrder(boss, $getTileZOrder(tile, zOrderBase, 0));
    $setZOrder(boss.leftHand, $getTileZOrder(tile, zOrderBase + 1, 0));
    $setZOrder(boss.rightHand, $getTileZOrder(tile, zOrderBase + 1, 0));
    $add_9(this$static.world, boss);
    $add_9(this$static.world, boss.leftHand);
    $add_9(this$static.world, boss.rightHand);
  }
   else {
    gfx = $getProperty(tile.tile, 'newton_adventure.gfx', null);
    if (null != gfx) {
      animation = $loadFromAnimation(this$static.game.view, $getLevelFilePath(this$static.game.data, this$static.questName, this$static.levelName, gfx));
      platform = new AnimatedPlatform_0(this$static.world, tileWidth, tileHeight);
      $setTexture(platform, animation);
      $setPosition_0(platform, tileX, tileY);
      platform.enabled = false;
      $setZOrder_0(platform, $getTileZOrder(tile, zOrderBase, 0));
      $add_9(this$static.world, platform);
    }
     else {
      platform = new StaticPlatform_0(tileWidth, tileHeight);
      $setTextureFromTile(tile, platform, textureCache);
      $set_4(platform.position_0, tileX, tileY);
      $set_4(platform.lastPosition, tileX, tileY);
      $setZOrder_2(platform, $getTileZOrder(tile, zOrderBase, 0));
      platform.enabled = false;
      $addStaticPlatform_0(this$static.world, platform);
    }
  }
}

--></script>
<script><!--
function $loadSome(this$static){
  var indexes, layerIndex, tile, tileLayer, x, y, zorderBase;
  indexes = $next_1(this$static.iterator);
  layerIndex = indexes[0];
  tileLayer = $get(this$static.map.layers, layerIndex);
  zorderBase = layerIndex * 1000000;
  x = indexes[1];
  y = indexes[2];
  tile = $getTileAt(tileLayer, x, y);
  !!tile && $initFromTile(this$static, x - this$static.map.width_0 / 2, -y + this$static.map.height_0 / 2, this$static.map, tile, zorderBase);
}

function $preloading(this$static){
  this$static.map = $openLevelTmx(this$static.game.data, this$static.questName, this$static.levelName);
}

function $setTextureFromTile(tile, platform, textureCache){
  var frame, image, imageHeight, imageWidth;
  frame = tile.tile.frame;
  image = frame.image;
  imageWidth = image.width_0;
  imageHeight = image.height_0;
  $setTexture_11(platform, $getTexture(textureCache, image.source));
  $setU1(platform, frame.x1 / imageWidth);
  $setV1(platform, frame.y1 / imageHeight);
  $setU2(platform, frame.x2 / imageWidth);
  $setV2(platform, frame.y2 / imageHeight);
}

function $startLoading(this$static, world){
  this$static.world = world;
  $setAppleIcon(world, (!this$static.appleIconTexture && (this$static.appleIconTexture = $loadFromAnimation(this$static.game.view, $getFileFromMap(this$static, this$static.map, 'newton_adventure.apple'))) , this$static.appleIconTexture));
  this$static.iterator = new MultidimensionnalIterator_0(initValues(_3I_classLit, makeCastMap([Q$int_$1, Q$Serializable]), -1, [this$static.map.layers.size, this$static.map.width_0, this$static.map.height_0]));
}

function TmxLoader_0(game, questName, levelName){
  $clinit_TmxLoader();
  this.game = game;
  this.questName = questName;
  this.levelName = levelName;
}

defineSeed(478, 1, {}, TmxLoader_0);
_.activator1OffTexture = null;
_.activator1OnTexture = null;
_.activator2OffTexture = null;
_.activator2OnTexture = null;
_.activator3OffTexture = null;
_.activator3OnTexture = null;
_.appleIconTexture = null;
_.axeTexture = null;
_.batAnimation = null;
_.blocker1Texture = null;
_.blocker2Texture = null;
_.blocker3Texture = null;
_.bombTexture = null;
_.clueTexture = null;
_.coinTexture = null;
_.compassTexture = null;
_.crateTexture = null;
_.doorTexture = null;
_.doorToBonusWorldTexture = null;
_.explosionAnimation = null;
_.fireBallTexture = null;
_.game = null;
_.hero = null;
_.iterator = null;
_.keyTexture = null;
_.levelName = null;
_.map = null;
_.memoryActivatorHiddenTexture = null;
_.mobilePikesTexture = null;
_.mummyAnimation = null;
_.questName = null;
_.world = null;
_.worldMapTexture = null;
var defaultMapProperties, defaultPickableObjectShape;
function UsedKey_0(world, texture, position){
  this.world = world;
  this.texture = texture;
  this.position_0 = position;
}

defineSeed(479, 332, {}, UsedKey_0);
_.draw = function draw_37(){
  $drawUsedKey(this.world.game.view, this, this.texture, this.world);
}
;
_.isDead_0 = function isDead_3(){
  return this.isDead;
}
;
_.update_1 = function update_48(frameTimeInfos){
  if (lt(this.endTime, P0_longLit)) {
    this.endTime = add_4(frameTimeInfos.currentTime_0, P11e1a300_longLit);
  }
   else {
    this.size = 2 * (2 - toDouble(sub(this.endTime, frameTimeInfos.currentTime_0)) / 300000000);
    this.isDead = gt(frameTimeInfos.currentTime_0, this.endTime);
  }
}
;
_.endTime = N1_longLit;
_.isDead = false;
_.position_0 = null;
_.size = 2;
_.texture = null;
_.world = null;
function $notifyCollision(this$static, body1, body2, point, normal, depth){
  var i;
  if (this$static.listeners.size == 0) {
    return;
  }
  new CollisionEvent_0(body1, body2, point, normal, depth);
  for (i = 0; i < this$static.listeners.size; ++i) {
    $get(this$static.listeners, i).nullMethod();
  }
}

function $resolve_0(this$static, bodyList){
  var arb, bi, bj, c, i, index, j, newArb;
  for (i = 0; i < bodyList.elements.size; ++i) {
    bi = $get(bodyList.elements, i);
    if (!bi.enabled) {
      continue;
    }
    for (j = i + 1; j < bodyList.elements.size; ++j) {
      bj = $get(bodyList.elements, j);
      if (!bj.enabled) {
        continue;
      }
      if (neq(and(bi.bitmask, bj.bitmask), P0_longLit)) {
        continue;
      }
      if ($contains_5(bi.excluded, bj)) {
        continue;
      }
      if (bi.invMass == 0 && bj.invMass == 0) {
        continue;
      }
      if (!$touches_0(bi.shape.getBounds(), bi.position_0.x, bi.position_0.y, bj.shape.getBounds(), bj.position_0.x, bj.position_0.y)) {
        $remove_17(this$static.arbiters, new Arbiter_0(bi, bj));
        continue;
      }
      newArb = new Arbiter_0(bi, bj);
      newArb.numContacts = collide(newArb.contacts, newArb.body1, newArb.body2);
      if (newArb.numContacts > 0) {
        bi.collided(bj);
        bj.collided(bi);
        if ($contains_4(this$static.arbiters, newArb)) {
          index = $indexOf_4(this$static.arbiters, newArb);
          arb = $get_10(this$static.arbiters, index);
          $update_11(arb, newArb.contacts, newArb.numContacts);
        }
         else {
          c = newArb.contacts[0];
          $notifyCollision(this$static, bi, bj, c.position_0, c.normal, c.separation);
          $add_15(this$static.arbiters, newArb);
          newArb.numContacts > 0 && (newArb.friction = sqrt(newArb.body1.surfaceFriction * newArb.body2.surfaceFriction));
        }
      }
       else {
        $remove_17(this$static.arbiters, newArb);
      }
    }
  }
}

defineSeed(482, 1, {});
_.collisionStrategy = null;
_.totalTime = 0;
function $add_8(this$static, joint){
  $add_17(this$static.joints, joint);
}

function $cleanUpArbiters(this$static){
  var arbiter, i;
  for (i = 0; i < this$static.arbiters.elements.size; ++i) {
    arbiter = $get_10(this$static.arbiters, i);
    if (!arbiter.body1.added || !arbiter.body2.added) {
      $remove_17(this$static.arbiters, arbiter);
      --i;
    }
  }
}

function $clearArbiters(this$static, b){
  var i;
  for (i = 0; i < this$static.arbiters.elements.size; ++i) {
    if ($concerns($get_10(this$static.arbiters, i), b)) {
      $remove_17(this$static.arbiters, $get_10(this$static.arbiters, i));
      --i;
    }
  }
}

function $getContacts(this$static, body){
  var arb, collisions, contact, event_0, i, j;
  collisions = new ArrayList_0;
  for (i = 0; i < this$static.arbiters.elements.size; ++i) {
    arb = $get_10(this$static.arbiters, i);
    if ($concerns(arb, body)) {
      for (j = 0; j < arb.numContacts; ++j) {
        contact = arb.contacts[j];
        event_0 = new CollisionEvent_0(arb.body1, arb.body2, contact.position_0, contact.normal, contact.separation);
        setCheck(collisions.array, collisions.size++, event_0);
      }
    }
  }
  return $toArray_0(collisions, initDim(_3Lnet_phys2d_raw_CollisionEvent_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$CollisionEvent, 0, 0));
}

function $setGravity(this$static, x, y){
  this$static.gravity.x = x;
  this$static.gravity.y = y;
}

function $step_0(this$static){
  var arb, b, bodies, damping, i, j, joints, k, temp, rot1, rot2, K1, K2, K3, K, p1, p2, dp, accum2;
  for (i = 0; i < this$static.bodies.elements.size; ++i) {
    for (j = 0; j < this$static.sources.size; ++j) {
      $get(this$static.sources, j).nullMethod($get_11(this$static.bodies, i));
    }
  }
  bodies = this$static.bodies;
  joints = this$static.joints;
  this$static.totalTime += 0.01666666753590107;
  $collideBodies(this$static.collisionStrategy, this$static, this$static.bodies);
  for (i = 0; i < bodies.elements.size; ++i) {
    b = $get(bodies.elements, i);
    if (b.invMass == 0) {
      continue;
    }
    if (b.isResting_0() && false) {
      continue;
    }
    temp = new Vector2f_2(b.force_0);
    $scale_0(temp, b.invMass);
    (b.gravity || b.I == 3.4028234663852886E38) && $add_14(temp, this$static.gravity);
    temp.x *= 0.01666666753590107;
    temp.y *= 0.01666666753590107;
    $adjustVelocity(b, temp);
    damping = new Vector2f_2(b.velocity);
    $scale_0(damping, -b.damping * b.invMass);
    $adjustVelocity(b, damping);
    $adjustAngularVelocity(b, 0.01666666753590107 * b.invI * b.torque);
    $adjustAngularVelocity(b, -b.angularVelocity * b.invI * b.rotDamping);
  }
  for (i = 0; i < this$static.arbiters.elements.size; ++i) {
    arb = $get_10(this$static.arbiters, i);
    $preStep(arb);
  }
  for (i = 0; i < joints.elements.size; ++i) {
    j = $get(joints.elements, i);
    rot1 = new Matrix2f_1(j.body1.rotation);
    rot2 = new Matrix2f_1(j.body2.rotation);
    j.r1 = mul_0(rot1, j.localAnchor1);
    j.r2 = mul_0(rot2, j.localAnchor2);
    K1 = new Matrix2f_0;
    K1.col1.x = j.body1.invMass + j.body2.invMass;
    K1.col2.x = 0;
    K1.col1.y = 0;
    K1.col2.y = j.body1.invMass + j.body2.invMass;
    K2 = new Matrix2f_0;
    K2.col1.x = j.body1.invI * j.r1.y * j.r1.y;
    K2.col2.x = -j.body1.invI * j.r1.x * j.r1.y;
    K2.col1.y = -j.body1.invI * j.r1.x * j.r1.y;
    K2.col2.y = j.body1.invI * j.r1.x * j.r1.x;
    K3 = new Matrix2f_0;
    K3.col1.x = j.body2.invI * j.r2.y * j.r2.y;
    K3.col2.x = -j.body2.invI * j.r2.x * j.r2.y;
    K3.col1.y = -j.body2.invI * j.r2.x * j.r2.y;
    K3.col2.y = j.body2.invI * j.r2.x * j.r2.x;
    K = add_10(add_10(K1, K2), K3);
    j.M = $invert(K);
    p1 = new Vector2f_2(j.body1.position_0);
    $add_14(p1, j.r1);
    p2 = new Vector2f_2(j.body2.position_0);
    $add_14(p2, j.r2);
    dp = new Vector2f_2(p2);
    dp.x -= p1.x;
    dp.y -= p1.y;
    j.bias = new Vector2f_2(dp);
    $scale_0(j.bias, -0.10000000149011612);
    $scale_0(j.bias, 59.999996185302734);
    $scale_0(j.accumulatedImpulse, j.relaxation);
    accum2 = new Vector2f_2(j.accumulatedImpulse);
    $scale_0(accum2, j.body2.invMass);
    $adjustVelocity(j.body2, accum2);
    $adjustAngularVelocity(j.body2, j.body2.invI * cross_1(j.r2, j.accumulatedImpulse));
  }
  for (i = 0; i < this$static.iterations; ++i) {
    for (k = 0; k < this$static.arbiters.elements.size; ++k) {
      arb = $get_10(this$static.arbiters, k);
      $applyImpulse(arb);
    }
    for (k = 0; k < joints.elements.size; ++k) {
      j = $get(joints.elements, k);
      $applyImpulse_0(j);
    }
  }
  for (i = 0; i < bodies.elements.size; ++i) {
    b = $get(bodies.elements, i);
    if (b.invMass == 0) {
      continue;
    }
    $adjustPosition(b, b.velocity);
    $adjustPosition(b, b.biasedVelocity);
    $adjustRotation(b, 0.01666666753590107 * b.angularVelocity);
    $adjustRotation(b, 0.01666666753590107 * b.biasedAngularVelocity);
    $set_4(b.biasedVelocity, 0, 0);
    b.biasedAngularVelocity = 0;
    $set_4(b.force_0, 0, 0);
    b.torque = 0;
  }
  $cleanUpArbiters(this$static);
}

function World_1(gravity, strategy){
  this.bodies = new BodyList_0;
  this.arbiters = new ArbiterList_0;
  this.listeners = new ArrayList_0;
  this.collisionStrategy = strategy;
  this.joints = new JointList_0;
  this.gravity = new Vector2f_1(0, 0);
  this.sources = new ArrayList_0;
  this.gravity = gravity;
  this.iterations = 2;
}

defineSeed(481, 482, {});
_.hitTolerance = 0;
_.iterations = 0;
function $add_9(this$static, body){
  instanceOf(body, Q$Updatable) && $add_12(this$static.updatableBodies, body);
  $configureRestingBodyDetection(body, this$static.hitTolerance);
  body.bitmask = P0_longLit;
  body.added = true;
  $add_16(this$static.bodies, body);
  !!this$static.collisionStrategy && $addBody(this$static.collisionStrategy, body);
}

function $addApple_0(this$static, apple){
  ++this$static.nbCollectableApple;
  $add_9(this$static, apple);
}

function $addCoin(this$static, coin){
  ++this$static.nbCollectableCoin;
  $add_9(this$static, coin);
}

function $addColoredPlatform(this$static, color, colored){
  $add_9(this$static, colored);
  $add_16($get_8(this$static.coloredStaticBodies, color), colored);
}

function $addKey(this$static, key){
  $add_9(this$static, key);
  $add_0(this$static.keys, key);
}

function $addStaticPlatform_0(this$static, platform){
  $add_7(this$static.staticPlatformDrawer, platform);
  $add_9(this$static, platform);
}

function $addTopLevelEntities(this$static, e){
  $add_6(this$static.topLevelEntities, e);
}

function $cheatActivateAll(this$static){
  var a, allBodies, b, i;
  allBodies = this$static.bodies;
  for (i = 0; i < allBodies.elements.size; ++i) {
    b = $get(allBodies.elements, i);
    if (instanceOf(b, Q$Blocker)) {
      a = b;
      a.activated = true;
    }
  }
}

function $draw_1(this$static){
  $drawWorld(this$static.game.view, this$static);
}

function $findNextTeleporter(this$static, previousTeleporter){
  var body, firstTeleporterWithSameColor, i, previousTeleporterFound, teleporter;
  firstTeleporterWithSameColor = null;
  previousTeleporterFound = false;
  for (i = 0; i < this$static.bodies.elements.size; ++i) {
    body = $get_11(this$static.bodies, i);
    if (instanceOf(body, Q$Teleporter)) {
      teleporter = body;
      if ($equals_0(teleporter.color, previousTeleporter.color)) {
        if (previousTeleporterFound) {
          return teleporter;
        }
        !firstTeleporterWithSameColor && (firstTeleporterWithSameColor = teleporter);
        teleporter == previousTeleporter && (previousTeleporterFound = true);
      }
    }
  }
  return firstTeleporterWithSameColor;
}

function $getColoredStaticBodyList(this$static, color){
  return $get_8(this$static.coloredStaticBodies, color);
}

function $getVisibleBodies(this$static, camera_x1, camera_y1, camera_x2, camera_y2){
  return this$static.collisionStrategy?$findVisibleBodies(this$static.collisionStrategy, camera_x1, camera_y1, camera_x2, camera_y2):this$static.bodies;
}

function $goToBonusWorld(this$static){
  $add_0(this$static.postUpdateActions, new World$1_0(this$static));
}

function $postStep(this$static){
  var runnable, runnable$iterator;
  for (runnable$iterator = new AbstractList$IteratorImpl_0(this$static.postStepActions); runnable$iterator.i < runnable$iterator.this$0_0.size_0();) {
    runnable = $next_2(runnable$iterator);
    runnable.this$0.hero.enabled = true;
    $setPosition(runnable.this$0.hero, runnable.val$teleporter.position_0.x, runnable.val$teleporter.position_0.y + 1);
    $add_9(runnable.this$0, runnable.this$0.hero);
  }
  $clear(this$static.postStepActions);
}

function $progressiveRotateGravity(this$static, angle){
  var rot;
  if (this$static.isRotateGravityPossible) {
    this$static.gravityAngle += angle;
    rot = new Matrix2f_1(this$static.gravityAngle);
    this$static.gravityVector = mul_0(rot, new Vector2f_1(0, -2));
    $setGravity(this$static, this$static.gravityVector.x, this$static.gravityVector.y);
  }
}

function $remove_9(this$static, body){
  body.enabled = false;
  !!this$static.collisionStrategy && $removeBody(this$static.collisionStrategy, body);
  instanceOf(body, Q$Updatable) && $remove(this$static.updatableBodies, body);
  $clearArbiters(this$static, body);
  body.added = false;
  $remove_18(this$static.bodies, body);
}

function $removeApple(this$static, apple){
  var body, i;
  $remove_9(this$static, apple);
  --this$static.nbCollectableApple;
  if (this$static.nbCollectableApple <= 0) {
    for (i = 0; i < this$static.bodies.elements.size; ++i) {
      body = $get_11(this$static.bodies, i);
      if (instanceOf(body, Q$DoorToBonusWorld)) {
        $play_0($getSound(this$static.game.platform.toolkit.audio, (this$static.game , 'door_to_bonus_world_unlocked.wav')).val$sound);
        $open(body);
      }
    }
  }
}

function $removeCoin(this$static, coin){
  var body, i, levelWithDoor;
  $remove_9(this$static, coin);
  --this$static.nbCollectableCoin;
  if (this$static.nbCollectableCoin <= 0) {
    levelWithDoor = false;
    for (i = 0; i < this$static.bodies.elements.size; ++i) {
      body = $get_11(this$static.bodies, i);
      if (instanceOf(body, Q$Door)) {
        $open(body);
        levelWithDoor = true;
      }
    }
    levelWithDoor || (this$static.objectivesCompleted = true);
  }
}

function $removeKey(this$static, key){
  $remove_1(this$static.keys, key);
  $remove_9(this$static, key);
}

function $resolve_1(this$static, bodyList){
  var body, i;
  $resolve_0(this$static, bodyList);
  for (i = 0; i < bodyList.elements.size; ++i) {
    body = $get(bodyList.elements, i);
    instanceOf(body, Q$CollisionDetectionOnly) && $clearArbiters(this$static, body);
  }
}

function $resume(this$static){
  var body, i;
  for (i = 0; i < this$static.bodies.elements.size; ++i) {
    body = $get_11(this$static.bodies, i);
    instanceOf(body, Q$DoorToBonusWorld) && (body.isClose = true);
  }
}

function $rotateGravity(this$static, angle){
  if (this$static.isRotateGravityPossible) {
    if (!this$static.nonProgressiveGravityRotationActive) {
      this$static.gravityAngleTarget = this$static.gravityAngle + angle;
      this$static.nonProgressiveGravityRotationStep = 2 * angle / 60;
      this$static.nonProgressiveGravityRotationActive = true;
    }
  }
}

function $setAppleIcon(this$static, appleIcon){
  this$static.appleIconPlay = (appleIcon.animations.map.size_0() == 0?new AnimationCollection$NotReadyFirstAnimation_0(appleIcon):$iterator_0($values(appleIcon.animations)).val$outerIter.next_0().getValue()).start_0();
}

function $setBackgroundTexture(this$static, backgroundTexture){
  this$static.backgroundTexture = backgroundTexture;
}

function $setHero(this$static, hero){
  this$static.hero = hero;
  $add_9(this$static, hero);
}

function $setIsRotateGravityPossible(this$static, isRotateGravityPossible){
  this$static.isRotateGravityPossible = isRotateGravityPossible;
}

function $showHelp_0(this$static){
  $add_0(this$static.postUpdateActions, new World$4_0(this$static));
}

function $step_1(this$static){
  if (this$static.nonProgressiveGravityRotationActive) {
    if (abs(this$static.gravityAngle - this$static.gravityAngleTarget) < abs(this$static.nonProgressiveGravityRotationStep)) {
      this$static.gravityAngle = this$static.gravityAngleTarget;
      this$static.nonProgressiveGravityRotationStep = 0;
      this$static.nonProgressiveGravityRotationActive = false;
    }
    $progressiveRotateGravity(this$static, this$static.nonProgressiveGravityRotationStep);
  }
   else {
    $step(this$static.hero);
    $step_0(this$static);
    $postStep(this$static);
  }
}

function $teleportFrom(this$static, previousTeleporter){
  var teleporter;
  teleporter = $findNextTeleporter(this$static, previousTeleporter);
  $remove_9(this$static, this$static.hero);
  $add_0(this$static.postStepActions, new World$2_0(this$static, teleporter));
}

function $update_10(this$static){
  var action, action$iterator, frameTimeInfos, u, u$iterator;
  frameTimeInfos = this$static.game.frameTimeInfos;
  $update_1(this$static.appleIconPlay, div(frameTimeInfos.elapsedTime, Pf4240_longLit));
  for (u$iterator = new AbstractList$IteratorImpl_0(new ArrayList_2(this$static.updatableBodies)); u$iterator.i < u$iterator.this$0_0.size_0();) {
    u = $next_2(u$iterator);
    u.update_1(frameTimeInfos);
  }
  $update_3(this$static.topLevelEntities, frameTimeInfos);
  try {
    for (action$iterator = new AbstractList$IteratorImpl_0(this$static.postUpdateActions); action$iterator.i < action$iterator.this$0_0.size_0();) {
      action = $next_2(action$iterator);
      action.run();
    }
  }
   finally {
    $clear(this$static.postUpdateActions);
  }
}

function World_2(game, questName){
  var color, color$array, color$index, color$max;
  World_1.call(this, new Vector2f_1(0, -2), new StaticQuadSpaceStrategy_0);
  this.gravityVector = new Vector2f_0;
  this.updatableBodies = new LinkedList_0;
  this.topLevelEntities = new EntityList_0;
  this.keys = new ArrayList_0;
  this.postStepActions = new ArrayList_0;
  this.postUpdateActions = new ArrayList_0;
  this.game = game;
  $progressiveRotateGravity(this, 0);
  this.questName = questName;
  this.coloredStaticBodies = new EnumMap_0(Lim_bci_newtonadv_util_NewtonColor_2_classLit);
  for (color$array = ($clinit_NewtonColor() , $clinit_NewtonColor() , $VALUES_18) , color$index = 0 , color$max = color$array.length; color$index < color$max; ++color$index) {
    color = color$array[color$index];
    $put_4(this.coloredStaticBodies, color, new BodyList_0);
  }
  this.explodeSound = $getSound(game.platform.toolkit.audio, 'explode.wav');
  this.staticPlatformDrawer = new PlaynStaticPlatformDrawer_0;
}

defineSeed(480, 481, {}, World_2);
_.appleIconPlay = null;
_.backgroundTexture = null;
_.coloredStaticBodies = null;
_.explodeSound = null;
_.game = null;
_.gravityAngle = 0;
_.gravityAngleTarget = 0;
_.hero = null;
_.isRotateGravityPossible = true;
_.nbCollectableApple = 0;
_.nbCollectableCoin = 0;
_.nonProgressiveGravityRotationActive = false;
_.nonProgressiveGravityRotationStep = 0;
_.objectivesCompleted = false;
_.questName = null;
_.staticPlatformDrawer = null;
function World$1_0(this$0){
  this.this$0 = this$0;
}

defineSeed(483, 1, {}, World$1_0);
_.run = function run(){
  $play_0($getSound(this.this$0.game.platform.toolkit.audio, (this.this$0.game , 'go_to_bonus_world.wav')).val$sound);
  $goToRandomBonusLevel(this.this$0.game, this.this$0.questName);
}
;
_.this$0 = null;
function World$2_0(this$0, val$teleporter){
  this.this$0 = this$0;
  this.val$teleporter = val$teleporter;
}

defineSeed(484, 1, {}, World$2_0);
_.this$0 = null;
_.val$teleporter = null;
function World$4_0(this$0){
  this.this$0 = this$0;
}

defineSeed(485, 1, {}, World$4_0);
_.run = function run_0(){
  $showHelp(this.this$0.game);
}
;
_.this$0 = null;
function WorldMap_0(world, shape){
  PickableObject_0.call(this, world, shape);
}

defineSeed(486, 429, makeCastMap([Q$Drawable, Q$Updatable, Q$CollisionDetectionOnly, Q$WorldMap, Q$StaticBody]), WorldMap_0);
function $decodeCsvTo(this$static, width, height, gidArray){
  var index, str, values, x, y;
  values = $split($replaceAll(this$static.data, '[\\s]', ''), ',', 0);
  index = 0;
  for (y = 0; y < height; ++y) {
    for (x = 0; x < width; ++x) {
      str = values[index++];
      gidArray[x][y] = __parseAndValidateInt(str);
    }
  }
}

function $decodeTo(this$static, width, height, data){
  if ($equals_0('csv', this$static.encoding)) {
    $decodeCsvTo(this$static, width, height, data);
  }
   else {
    throw new RuntimeException_1('Unsupported tiled layer data encoding: ' + this$static.encoding);
  }
}

function $setData(this$static, data){
  this$static.data = data;
}

function $setEncoding(this$static, encoding){
  this$static.encoding = encoding;
}

function TmxData_0(){
}

defineSeed(487, 1, {}, TmxData_0);
_.data = null;
_.encoding = null;
function $getHeight_0(this$static){
  return this$static.y2 - this$static.y1;
}

function $getWidth_0(this$static){
  return this$static.x2 - this$static.x1;
}

function TmxFrame_0(image, x1, y1, x2, y2){
  this.image = image;
  this.x1 = x1;
  this.y1 = y1;
  this.x2 = x2;
  this.y2 = y2;
}

defineSeed(488, 1, {}, TmxFrame_0);
_.image = null;
_.x1 = 0;
_.x2 = 0;
_.y1 = 0;
_.y2 = 0;
function $setHeight_1(this$static, height){
  this$static.height_0 = height;
}

function $setSource(this$static, source){
  this$static.source = source;
}

function $setWidth_1(this$static, width){
  this$static.width_0 = width;
}

function TmxImage_0(){
}

defineSeed(489, 1, {}, TmxImage_0);
_.height_0 = 0;
_.source = null;
_.width_0 = 0;
function $getTileAt(this$static, tx, ty){
  tx -= this$static.x;
  ty -= this$static.y;
  return tx >= 0 && ty >= 0 && tx < this$static.width_0 && ty < this$static.height_0?this$static.tiles[tx][ty]:null;
}

function $setData_0(this$static, data){
  this$static.data = data;
}

function $setHeight_2(this$static, height){
  this$static.height_0 = height;
}

function $setTileAt(this$static, tx, ty, tile){
  tx -= this$static.x;
  ty -= this$static.y;
  this$static.tiles[tx][ty] = tile;
}

function $setWidth_2(this$static, width){
  this$static.width_0 = width;
}

function $setX_0(this$static, x){
  this$static.x = x;
}

function $setY_0(this$static, y){
  this$static.y = y;
}

function TmxLayer_0(){
  new ArrayList_0;
}

defineSeed(490, 1, {}, TmxLayer_0);
_.data = null;
_.height_0 = 0;
_.tiles = null;
_.width_0 = 0;
_.x = 0;
_.y = 0;
function $decode(map){
  var data, effect, effect$array, effect$index, effect$max, effects, gid, instance, it, layer, layer$iterator, pooledInstance, tileInstancePool, tileset, x, y;
  tileInstancePool = new HashMap_0;
  for (layer$iterator = new AbstractList$IteratorImpl_0(map.layers); layer$iterator.i < layer$iterator.this$0_0.size_0();) {
    layer = $next_2(layer$iterator);
    data = initDims([_3_3I_classLit, _3I_classLit], [makeCastMap([Q$Serializable, Q$Object_$1]), makeCastMap([Q$int_$1, Q$Serializable])], [Q$int_$1, -1], [layer.width_0, layer.height_0], 2, 1);
    $decodeTo(layer.data, layer.width_0, layer.height_0, data);
    for (x = 0; x < layer.width_0; ++x) {
      for (y = 0; y < layer.height_0; ++y) {
        gid = data[x][y];
        if (0 != gid) {
          effects = noneOf(Lim_bci_tmxloader_TmxTileInstanceEffect_2_classLit);
          for (effect$array = ($clinit_TmxTileInstanceEffect() , $clinit_TmxTileInstanceEffect() , $VALUES_23) , effect$index = 0 , effect$max = effect$array.length; effect$index < effect$max; ++effect$index) {
            effect = effect$array[effect$index];
            (gid & effect.gidFlag) != 0 && $add_10(effects, effect);
            gid &= ~effect.gidFlag;
          }
          it = new AbstractList$ListIteratorImpl_0(map.tilesets, map.tilesets.size);
          while (it.i > 0) {
            tileset = $previous(it);
            if (tileset.firstgid <= gid) {
              instance = new TmxTileInstance_0($getTileById(tileset, gid - tileset.firstgid), effects);
              pooledInstance = tileInstancePool.get_1(instance);
              pooledInstance?(instance = pooledInstance):tileInstancePool.put(instance, instance);
              $setTileAt(layer, x, y, instance);
              break;
            }
          }
        }
      }
    }
  }
  map.ready_0 = true;
}

function $findChild(parent_0, name_0){
  var child, child$iterator;
  for (child$iterator = $listIterator(parent_0.children, 0); child$iterator.currentNode != child$iterator.this$0.header;) {
    child = $next_7(child$iterator);
    if ($equals_0(name_0, child.name_0)) {
      return child;
    }
  }
  return null;
}

function $parseData(xmlData){
  var data;
  data = new TmxData_0;
  $setEncoding(data, xmlData.attributes.get_1('encoding'));
  $setData(data, xmlData.content_0);
  return data;
}

function $parseImage(xmlImage){
  var image;
  if (xmlImage) {
    image = new TmxImage_0;
    $setSource(image, xmlImage.attributes.get_1('source'));
    $setWidth_1(image, getMandatoryIntAttribute(xmlImage, 'width'));
    $setHeight_1(image, getMandatoryIntAttribute(xmlImage, 'height'));
    return image;
  }
   else {
    return null;
  }
}

function $parseMap(xmlMap, map){
  var child, child$iterator, layer, layers;
  $setWidth_3(map, getMandatoryIntAttribute(xmlMap, 'width'));
  $setHeight_3(map, getMandatoryIntAttribute(xmlMap, 'height'));
  $setTilewidth(map, getMandatoryIntAttribute(xmlMap, 'tilewidth'));
  $setTileheight(map, getMandatoryIntAttribute(xmlMap, 'tileheight'));
  valueOf_2(xmlMap.attributes.get_1('orientation').toUpperCase());
  $setProperties(map, $parseProperties($findChild(xmlMap, 'properties')));
  layers = new ArrayList_0;
  for (child$iterator = $listIterator(xmlMap.children, 0); child$iterator.currentNode != child$iterator.this$0.header;) {
    child = $next_7(child$iterator);
    if ($equals_0('layer', child.name_0)) {
      layer = new TmxLayer_0;
      child.attributes.get_1('name');
      $setX_0(layer, getIntAttribute(child, 'x', 0));
      $setY_0(layer, getIntAttribute(child, 'x', 0));
      $setWidth_2(layer, getMandatoryIntAttribute(child, 'width'));
      $setHeight_2(layer, getMandatoryIntAttribute(child, 'height'));
      $parseProperties($findChild(child, 'properties'));
      $setData_0(layer, $parseData($findChild(child, 'data')));
      layer.tiles = initDims([_3_3Lim_bci_tmxloader_TmxTileInstance_2_classLit, _3Lim_bci_tmxloader_TmxTileInstance_2_classLit], [makeCastMap([Q$Serializable, Q$Object_$1]), makeCastMap([Q$TmxTileInstance_$1, Q$Serializable, Q$Object_$1])], [Q$TmxTileInstance_$1, Q$TmxTileInstance], [layer.width_0, layer.height_0], 2, 0);
      setCheck(layers.array, layers.size++, layer);
    }
  }
  map.layers = layers;
}

function $parseProperties(xmlProperties){
  var child, child$iterator, properties, property;
  properties = new ArrayList_0;
  if (xmlProperties) {
    for (child$iterator = $listIterator(xmlProperties.children, 0); child$iterator.currentNode != child$iterator.this$0.header;) {
      child = $next_7(child$iterator);
      if ($equals_0('property', child.name_0)) {
        property = new TmxProperty_0;
        $setName(property, child.attributes.get_1('name'));
        $setValue(property, child.attributes.get_1('value'));
        setCheck(properties.array, properties.size++, property);
      }
    }
  }
  return properties;
}

function $parseTile(tileset, xmlTile){
  var frame, image, tile, xmlImage;
  tile = new TmxTile_0;
  $setId(tile, getMandatoryIntAttribute(xmlTile, 'id'));
  $setProperties_0(tile, $parseProperties($findChild(xmlTile, 'properties')));
  xmlImage = $findChild(xmlTile, 'image');
  if (xmlImage) {
    image = new TmxImage_0;
    $setSource(image, xmlImage.attributes.get_1('source'));
    $setWidth_1(image, getIntAttribute(xmlImage, 'width', tileset.tilewidth));
    $setHeight_1(image, getIntAttribute(xmlImage, 'height', tileset.tileheight));
    frame = new TmxFrame_0(image, 0, 0, image.width_0, image.height_0);
    tile.frame = frame;
  }
  return tile;
}

--></script>
<script><!--
function $parseTileset(xmlTileset, map, tileset){
  var child, child$iterator, tiles;
  xmlTileset.attributes.get_1('name');
  $setMargin(tileset, getIntAttribute(xmlTileset, 'margin', 0));
  $setSpacing(tileset, getIntAttribute(xmlTileset, 'spacing', 0));
  $setTilewidth_0(tileset, getIntAttribute(xmlTileset, 'tilewidth', map.tilewidth));
  $setTileheight_0(tileset, getIntAttribute(xmlTileset, 'tileheight', map.tileheight));
  $parseProperties($findChild(xmlTileset, 'properties'));
  $setImage(tileset, $parseImage($findChild(xmlTileset, 'image')));
  tiles = new ArrayList_0;
  for (child$iterator = $listIterator(xmlTileset.children, 0); child$iterator.currentNode != child$iterator.this$0.header;) {
    child = $next_7(child$iterator);
    $equals_0('tile', child.name_0) && $add_0(tiles, $parseTile(tileset, child));
  }
  tileset.tiles = tiles;
}

function $parseTilesets(xmlMap, map){
  var child, child$iterator, source, tileset, tilesets;
  tilesets = new ArrayList_0;
  for (child$iterator = $listIterator(xmlMap.children, 0); child$iterator.currentNode != child$iterator.this$0.header;) {
    child = $next_7(child$iterator);
    if ($equals_0('tileset', child.name_0)) {
      tileset = new TmxTileset_0;
      source = child.attributes.get_1('source');
      $setFirstgid(tileset, getMandatoryIntAttribute(child, 'firstgid'));
      if (null != source) {
        tileset.source = source;
      }
       else {
        $parseTileset(child, map, tileset);
        $afterUnmarshal(tileset);
        tileset.ready_0 = true;
      }
      setCheck(tilesets.array, tilesets.size++, tileset);
    }
  }
  map.tilesets = tilesets;
}

function $parseTmx(map, xml){
  var $e0, doc, ex;
  try {
    doc = parseXml(xml);
    $parseMap(doc.root, map);
    $parseTilesets(doc.root, map);
  }
   catch ($e0) {
    $e0 = caught_0($e0);
    if (instanceOf($e0, Q$XmlParseException)) {
      ex = $e0;
      throw new RuntimeException_2('Cannot load tmx', ex);
    }
     else 
      throw $e0;
  }
}

function $parseTsx(map, tileset, xml){
  var $e0, ex;
  try {
    $parseTileset(parseXml(xml).root, map, tileset);
    $afterUnmarshal(tileset);
    tileset.ready_0 = true;
  }
   catch ($e0) {
    $e0 = caught_0($e0);
    if (instanceOf($e0, Q$XmlParseException)) {
      ex = $e0;
      throw new RuntimeException_2('Cannot load tmx', ex);
    }
     else 
      throw $e0;
  }
}

function getIntAttribute(xml, name_0, defaultValue){
  var value;
  value = xml.attributes.get_1(name_0);
  return null != value?__parseAndValidateInt(value):defaultValue;
}

function getMandatoryIntAttribute(xml, name_0){
  var value;
  value = xml.attributes.get_1(name_0);
  if (null != value) {
    return __parseAndValidateInt(value);
  }
   else {
    throw new RuntimeException_1('Missing attribute ' + name_0 + ' for tag ' + xml.name_0);
  }
}

function $setHeight_3(this$static, height){
  this$static.height_0 = height;
}

function $setProperties(this$static, properties){
  this$static.properties = properties;
}

function $setTileheight(this$static, tileheight){
  this$static.tileheight = tileheight;
}

function $setTilewidth(this$static, tilewidth){
  this$static.tilewidth = tilewidth;
}

function $setWidth_3(this$static, width){
  this$static.width_0 = width;
}

function TmxMap_0(){
  this.tilesets = new ArrayList_0;
  this.properties = new ArrayList_0;
  this.layers = new ArrayList_0;
}

defineSeed(492, 1, {}, TmxMap_0);
_.height_0 = 0;
_.ready_0 = false;
_.tileheight = 0;
_.tilewidth = 0;
_.width_0 = 0;
function $clinit_TmxMapOrientation(){
  $clinit_TmxMapOrientation = nullMethod;
  ORTHOGONAL = new TmxMapOrientation_0('ORTHOGONAL', 0);
  ISOMETRIC = new TmxMapOrientation_0('ISOMETRIC', 1);
  STAGGERED = new TmxMapOrientation_0('STAGGERED', 2);
  $VALUES_22 = initValues(_3Lim_bci_tmxloader_TmxMapOrientation_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$TmxMapOrientation, [ORTHOGONAL, ISOMETRIC, STAGGERED]);
}

function TmxMapOrientation_0(enum$name, enum$ordinal){
  Enum_0.call(this, enum$name, enum$ordinal);
}

function valueOf_2(name_0){
  $clinit_TmxMapOrientation();
  return valueOf(($clinit_TmxMapOrientation$Map() , $MAP_1), name_0);
}

function values_23(){
  $clinit_TmxMapOrientation();
  return $VALUES_22;
}

defineSeed(493, 11, makeCastMap([Q$TmxMapOrientation, Q$Serializable, Q$Comparable, Q$Enum]), TmxMapOrientation_0);
var $VALUES_22, ISOMETRIC, ORTHOGONAL, STAGGERED;
function $clinit_TmxMapOrientation$Map(){
  $clinit_TmxMapOrientation$Map = nullMethod;
  $MAP_1 = createValueOfMap(($clinit_TmxMapOrientation() , $VALUES_22));
}

var $MAP_1;
function $setName(this$static, name_0){
  this$static.name_0 = name_0;
}

function $setValue(this$static, value){
  this$static.value_0 = value;
}

function TmxProperty_0(){
}

defineSeed(495, 1, {}, TmxProperty_0);
_.name_0 = null;
_.value_0 = null;
function $getProperty(this$static, name_0, defaultValue){
  return getProperty(this$static.properties, name_0, defaultValue);
}

function $setFrame(this$static, frame){
  this$static.frame = frame;
}

function $setId(this$static, id){
  this$static.id_0 = id;
}

function $setProperties_0(this$static, properties){
  this$static.properties = properties;
}

function TmxTile_0(){
  this.properties = new ArrayList_0;
}

defineSeed(496, 1, {}, TmxTile_0);
_.frame = null;
_.id_0 = 0;
function TmxTileInstance_0(tile, effect){
  this.tile = tile;
  this.effect = effect;
}

defineSeed(497, 1, makeCastMap([Q$TmxTileInstance]), TmxTileInstance_0);
_.equals$ = function equals_11(obj){
  var other;
  if (obj == null) {
    return false;
  }
  if (Lim_bci_tmxloader_TmxTileInstance_2_classLit != getClass__devirtual$(obj)) {
    return false;
  }
  other = obj;
  if (!equals_12(this.tile, other.tile)) {
    return false;
  }
  if (!equals_12(this.effect, other.effect)) {
    return false;
  }
  return true;
}
;
_.hashCode$ = function hashCode_13(){
  var hash;
  hash = 623 + (this.tile?getHashCode(this.tile):0);
  hash = 89 * hash + (this.effect?$hashCode(this.effect):0);
  return hash;
}
;
_.effect = null;
_.tile = null;
function $clinit_TmxTileInstanceEffect(){
  $clinit_TmxTileInstanceEffect = nullMethod;
  FLIPPED_HORIZONTALLY = new TmxTileInstanceEffect_0('FLIPPED_HORIZONTALLY', 0, -2147483648);
  FLIPPED_VERTICALLY = new TmxTileInstanceEffect_0('FLIPPED_VERTICALLY', 1, 1073741824);
  FLIPPED_DIAGONALLY = new TmxTileInstanceEffect_0('FLIPPED_DIAGONALLY', 2, 536870912);
  $VALUES_23 = initValues(_3Lim_bci_tmxloader_TmxTileInstanceEffect_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$TmxTileInstanceEffect, [FLIPPED_HORIZONTALLY, FLIPPED_VERTICALLY, FLIPPED_DIAGONALLY]);
}

function TmxTileInstanceEffect_0(enum$name, enum$ordinal, gidFlag){
  Enum_0.call(this, enum$name, enum$ordinal);
  this.gidFlag = gidFlag;
}

function values_24(){
  $clinit_TmxTileInstanceEffect();
  return $VALUES_23;
}

defineSeed(498, 11, makeCastMap([Q$TmxTileInstanceEffect, Q$Serializable, Q$Comparable, Q$Enum]), TmxTileInstanceEffect_0);
_.gidFlag = 0;
var $VALUES_23, FLIPPED_DIAGONALLY, FLIPPED_HORIZONTALLY, FLIPPED_VERTICALLY;
function $afterUnmarshal(this$static){
  var id, maxX, maxY, tile, tile$iterator, x, y;
  $clear_2(this$static.tilesById);
  for (tile$iterator = new AbstractList$IteratorImpl_0(this$static.tiles); tile$iterator.i < tile$iterator.this$0_0.size_0();) {
    tile = $next_2(tile$iterator);
    $put_0(this$static.tilesById, valueOf_3(tile.id_0), tile);
  }
  if (this$static.image) {
    maxX = this$static.image.width_0 - this$static.margin;
    maxY = this$static.image.height_0 - this$static.margin;
    id = 0;
    for (y = this$static.margin; y < maxY; y += this$static.tileheight + this$static.spacing) {
      for (x = this$static.margin; x < maxX; x += this$static.tilewidth + this$static.spacing) {
        tile = $get_1(this$static.tilesById, valueOf_3(id));
        if (!tile) {
          tile = new TmxTile_0;
          tile.id_0 = id;
          $put_0(this$static.tilesById, valueOf_3(id), tile);
        }
        !tile.frame && $setFrame(tile, new TmxFrame_0(this$static.image, x, y, x + this$static.tilewidth, y + this$static.tileheight));
        ++id;
      }
    }
  }
}

function $getTileById(this$static, i){
  return $get_1(this$static.tilesById, valueOf_3(i));
}

function $setFirstgid(this$static, firstgid){
  this$static.firstgid = firstgid;
}

function $setImage(this$static, image){
  this$static.image = image;
}

function $setMargin(this$static, margin){
  this$static.margin = margin;
}

function $setSpacing(this$static, spacing){
  this$static.spacing = spacing;
}

function $setTileheight_0(this$static, tileheight){
  this$static.tileheight = tileheight;
}

function $setTilewidth_0(this$static, tilewidth){
  this$static.tilewidth = tilewidth;
}

function TmxTileset_0(){
  new ArrayList_0;
  this.tilesById = new TreeMap_0;
  this.tiles = new ArrayList_0;
}

defineSeed(499, 1, {}, TmxTileset_0);
_.firstgid = 0;
_.image = null;
_.margin = 0;
_.ready_0 = false;
_.source = null;
_.spacing = 0;
_.tileheight = 0;
_.tilewidth = 0;
function equals_12(a, b){
  return maskUndefined(a) === maskUndefined(b) || a != null && equals__devirtual$(a, b);
}

function getProperty(properties, name_0, defaultValue){
  var p, p$iterator;
  for (p$iterator = new AbstractList$IteratorImpl_0(properties); p$iterator.i < p$iterator.this$0_0.size_0();) {
    p = $next_2(p$iterator);
    if ($equals_0(p.name_0, name_0)) {
      return p.value_0;
    }
  }
  return defaultValue;
}

function ArithmeticException_0(){
  RuntimeException_1.call(this, 'divide by zero');
}

defineSeed(501, 77, makeCastMap([Q$Serializable, Q$Exception, Q$RuntimeException, Q$Throwable]), ArithmeticException_0);
function IndexOutOfBoundsException_0(){
  RuntimeException_0.call(this);
}

function IndexOutOfBoundsException_1(message){
  RuntimeException_1.call(this, message);
}

defineSeed(503, 77, makeCastMap([Q$Serializable, Q$Exception, Q$RuntimeException, Q$Throwable]), IndexOutOfBoundsException_0, IndexOutOfBoundsException_1);
function ArrayIndexOutOfBoundsException_0(msg){
  IndexOutOfBoundsException_1.call(this, msg);
}

defineSeed(502, 503, makeCastMap([Q$Serializable, Q$Exception, Q$RuntimeException, Q$Throwable]), ArrayIndexOutOfBoundsException_0);
function ArrayStoreException_0(){
  RuntimeException_0.call(this);
}

function ArrayStoreException_1(message){
  RuntimeException_1.call(this, message);
}

defineSeed(504, 77, makeCastMap([Q$Serializable, Q$Exception, Q$RuntimeException, Q$Throwable]), ArrayStoreException_0, ArrayStoreException_1);
function Error_1(message, cause){
  Throwable_1.call(this, message, cause);
}

defineSeed(506, 52, makeCastMap([Q$Serializable, Q$Throwable]));
function AssertionError_0(message){
  Error_1.call(this, '' + message, instanceOf(message, Q$Throwable)?message:null);
}

defineSeed(505, 506, makeCastMap([Q$Serializable, Q$Throwable]), AssertionError_0);
function $clinit_Boolean(){
  $clinit_Boolean = nullMethod;
  FALSE = new Boolean_1(false);
  TRUE = new Boolean_1(true);
}

function Boolean_1(value){
  this.value_0 = value;
}

defineSeed(507, 1, makeCastMap([Q$Serializable, Q$Boolean, Q$Comparable]), Boolean_1);
_.compareTo$ = function compareTo_1(other){
  return this.value_0 == other.value_0?0:this.value_0?1:-1;
}
;
_.equals$ = function equals_13(o){
  return instanceOf(o, Q$Boolean) && o.value_0 == this.value_0;
}
;
_.hashCode$ = function hashCode_14(){
  return this.value_0?1231:1237;
}
;
_.toString$ = function toString_19(){
  return this.value_0?'true':'false';
}
;
_.value_0 = false;
var FALSE, TRUE;
function digit(c){
  if (c >= 48 && c < 58) {
    return c - 48;
  }
  if (c >= 97 && c < 97) {
    return c - 97 + 10;
  }
  if (c >= 65 && c < 65) {
    return c - 65 + 10;
  }
  return -1;
}

function isSpace(c){
  switch (c) {
    case 10:
    case 9:
    case 12:
    case 13:
    case 32:
      return true;
    default:return false;
  }
}

function Class_0(){
}

function asString(number){
  return typeof number == 'number'?'S' + (number < 0?-number:number):number;
}

function createForArray(seedId, componentType){
  var clazz;
  clazz = new Class_0;
  clazz.typeName = 'Class$' + (isInstantiableOrPrimitive(seedId != 0?-seedId:0)?asString(seedId != 0?-seedId:0):'' + getHashCode(clazz));
  isInstantiable(seedId != 0?-seedId:0) && setClassLiteral(seedId != 0?-seedId:0, clazz);
  clazz.modifiers = 4;
  clazz.componentType = componentType;
  return clazz;
}

function createForClass(seedId){
  var clazz;
  clazz = new Class_0;
  clazz.typeName = 'Class$' + (isInstantiableOrPrimitive(seedId)?asString(seedId):'' + getHashCode(clazz));
  isInstantiable(seedId) && setClassLiteral(seedId, clazz);
  return clazz;
}

function createForEnum(seedId, enumConstantsFunc){
  var clazz;
  clazz = new Class_0;
  clazz.typeName = 'Class$' + (isInstantiableOrPrimitive(seedId)?asString(seedId):'' + getHashCode(clazz));
  isInstantiable(seedId) && setClassLiteral(seedId, clazz);
  clazz.modifiers = enumConstantsFunc?8:0;
  clazz.enumConstantsFunc = enumConstantsFunc;
  return clazz;
}

function createForInterface(){
  var clazz;
  clazz = new Class_0;
  clazz.typeName = 'Class$' + (isInstantiableOrPrimitive(0)?asString(0):'' + getHashCode(clazz));
  isInstantiable(0) && setClassLiteral(0, clazz);
  clazz.modifiers = 2;
  return clazz;
}

function createForPrimitive(seedId){
  var clazz;
  clazz = new Class_0;
  clazz.typeName = 'Class$' + (isInstantiableOrPrimitive(seedId)?asString(seedId):'' + getHashCode(clazz));
  isInstantiable(seedId) && setClassLiteral(seedId, clazz);
  clazz.modifiers = 1;
  return clazz;
}

function getSeedFunction(clazz){
  var func = seedTable[clazz.seedId];
  clazz = null;
  return func;
}

function isInstantiable(seedId){
  return typeof seedId == 'number' && seedId > 0;
}

function isInstantiableOrPrimitive(seedId){
  return seedId != null && seedId != 0;
}

function setClassLiteral(seedId, clazz){
  var proto;
  clazz.seedId = seedId;
  if (seedId == 2) {
    proto = String.prototype;
  }
   else {
    if (seedId > 0) {
      var seed = getSeedFunction(clazz);
      if (seed) {
        proto = seed.prototype;
      }
       else {
        seed = seedTable[seedId] = function(){
        }
        ;
        seed.___clazz$ = clazz;
        return;
      }
    }
     else {
      return;
    }
  }
  proto.___clazz$ = clazz;
}

defineSeed(509, 1, {}, Class_0);
_.toString$ = function toString_20(){
  return ((this.modifiers & 2) != 0?'interface ':(this.modifiers & 1) != 0?'':'class ') + this.typeName;
}
;
_.componentType = null;
_.enumConstantsFunc = null;
_.modifiers = 0;
_.seedId = 0;
_.typeName = null;
function __parseAndValidateDouble(s){
  var toReturn;
  toReturn = __parseDouble(s);
  if (isNaN(toReturn)) {
    throw new NumberFormatException_0('For input string: "' + s + '"');
  }
  return toReturn;
}

function __parseAndValidateInt(s){
  var i, length_0, startIndex, toReturn;
  if (s == null) {
    throw new NumberFormatException_0('null');
  }
  length_0 = s.length;
  startIndex = length_0 > 0 && s.charCodeAt(0) == 45?1:0;
  for (i = startIndex; i < length_0; ++i) {
    if (digit(s.charCodeAt(i)) == -1) {
      throw new NumberFormatException_0('For input string: "' + s + '"');
    }
  }
  toReturn = parseInt(s, 10);
  if (isNaN(toReturn)) {
    throw new NumberFormatException_0('For input string: "' + s + '"');
  }
   else if (toReturn < -2147483648 || toReturn > 2147483647) {
    throw new NumberFormatException_0('For input string: "' + s + '"');
  }
  return toReturn;
}

function __parseAndValidateLong(s){
  var c, firstTime, head, i, length_0, maxDigits, maxValue, negative, radixPower, toReturn;
  if (s == null) {
    throw new NumberFormatException_0('null');
  }
  length_0 = s.length;
  negative = length_0 > 0 && s.charCodeAt(0) == 45;
  if (negative) {
    s = $substring(s, 1);
    --length_0;
  }
  if (length_0 == 0) {
    throw new NumberFormatException_0('For input string: "' + s + '"');
  }
  while (s.length > 0 && s.charCodeAt(0) == 48) {
    s = $substring(s, 1);
    --length_0;
  }
  if (length_0 > ($clinit_Number$__ParseLong() , maxLengthForRadix)[10]) {
    throw new NumberFormatException_0('For input string: "' + s + '"');
  }
  for (i = 0; i < length_0; ++i) {
    c = s.charCodeAt(i);
    if (c >= 48 && c < 58) {
      continue;
    }
    if (c >= 97 && c < 97) {
      continue;
    }
    if (c >= 65 && c < 65) {
      continue;
    }
    throw new NumberFormatException_0('For input string: "' + s + '"');
  }
  toReturn = P0_longLit;
  maxDigits = maxDigitsForRadix[10];
  radixPower = fromInt(maxDigitsRadixPower[10]);
  maxValue = maxValueForRadix[10];
  firstTime = true;
  head = length_0 % maxDigits;
  if (head > 0) {
    toReturn = fromInt(__parseInt(s.substr(0, head - 0), 10));
    s = $substring(s, head);
    length_0 -= head;
    firstTime = false;
  }
  while (length_0 >= maxDigits) {
    head = __parseInt(s.substr(0, maxDigits - 0), 10);
    s = $substring(s, maxDigits);
    length_0 -= maxDigits;
    if (firstTime) {
      firstTime = false;
    }
     else {
      if (gt(toReturn, maxValue)) {
        throw new NumberFormatException_0(s);
      }
      toReturn = mul(toReturn, radixPower);
    }
    toReturn = add_4(toReturn, fromInt(head));
  }
  if (lt(toReturn, P0_longLit)) {
    throw new NumberFormatException_0('For input string: "' + s + '"');
  }
  negative && (toReturn = neg(toReturn));
  return toReturn;
}

function __parseDouble(str){
  var floatRegex = floatRegex_0;
  !floatRegex && (floatRegex = floatRegex_0 = /^\s*[+-]?((\d+\.?\d*)|(\.\d+))([eE][+-]?\d+)?[dDfF]?\s*$/i);
  if (floatRegex.test(str)) {
    return parseFloat(str);
  }
   else {
    return Number.NaN;
  }
}

function __parseInt(s, radix){
  return parseInt(s, radix);
}

defineSeed(511, 1, makeCastMap([Q$Serializable, Q$Number]));
var floatRegex_0 = null;
function Double_0(value){
  this.value_0 = value;
}

function compare_2(x, y){
  if (isNaN(x)) {
    return isNaN(y)?0:1;
  }
   else if (isNaN(y)) {
    return -1;
  }
  return x < y?-1:x > y?1:0;
}

defineSeed(510, 511, makeCastMap([Q$Serializable, Q$Comparable, Q$Double, Q$Number]), Double_0);
_.compareTo$ = function compareTo_2(b){
  return compare_2(this.value_0, b.value_0);
}
;
_.equals$ = function equals_14(o){
  return instanceOf(o, Q$Double) && o.value_0 == this.value_0;
}
;
_.hashCode$ = function hashCode_15(){
  return round_int(this.value_0);
}
;
_.toString$ = function toString_21(){
  return '' + this.value_0;
}
;
_.value_0 = 0;
function Float_0(value){
  this.value_0 = value;
}

function compare_3(x, y){
  return x < y?-1:x > y?1:0;
}

function parseFloat_0(s){
  var doubleValue;
  doubleValue = __parseAndValidateDouble(s);
  if (doubleValue > 3.4028234663852886E38) {
    return Infinity;
  }
   else if (doubleValue < -3.4028234663852886E38) {
    return -Infinity;
  }
  return doubleValue;
}

defineSeed(512, 511, makeCastMap([Q$Serializable, Q$Comparable, Q$Float, Q$Number]), Float_0);
_.compareTo$ = function compareTo_3(b){
  return this.value_0 < b.value_0?-1:this.value_0 > b.value_0?1:0;
}
;
_.equals$ = function equals_15(o){
  return instanceOf(o, Q$Float) && o.value_0 == this.value_0;
}
;
_.hashCode$ = function hashCode_16(){
  return round_int(this.value_0);
}
;
_.toString$ = function toString_22(){
  return '' + this.value_0;
}
;
_.value_0 = 0;
function IllegalArgumentException_0(){
  RuntimeException_0.call(this);
}

function IllegalArgumentException_1(message){
  RuntimeException_1.call(this, message);
}

defineSeed(513, 77, makeCastMap([Q$Serializable, Q$Exception, Q$RuntimeException, Q$Throwable]), IllegalArgumentException_0, IllegalArgumentException_1);
function IllegalStateException_0(){
  RuntimeException_0.call(this);
}

function IllegalStateException_1(s){
  RuntimeException_1.call(this, s);
}

defineSeed(514, 77, makeCastMap([Q$Serializable, Q$Exception, Q$RuntimeException, Q$Throwable]), IllegalStateException_0, IllegalStateException_1);
function Integer_0(value){
  this.value_0 = value;
}

function numberOfLeadingZeros_0(i){
  var m_0, n, y;
  if (i < 0) {
    return 0;
  }
   else if (i == 0) {
    return 32;
  }
   else {
    y = -(~~i >> 16);
    m_0 = ~~y >> 16 & 16;
    n = 16 - m_0;
    i = ~~i >> m_0;
    y = i - 256;
    m_0 = ~~y >> 16 & 8;
    n += m_0;
    i <<= m_0;
    y = i - 4096;
    m_0 = ~~y >> 16 & 4;
    n += m_0;
    i <<= m_0;
    y = i - 16384;
    m_0 = ~~y >> 16 & 2;
    n += m_0;
    i <<= m_0;
    y = ~~i >> 14;
    m_0 = y & ~(~~y >> 1);
    return n + 2 - m_0;
  }
}

function numberOfTrailingZeros(i){
  var r, rtn;
  if (i == 0) {
    return 32;
  }
   else {
    rtn = 0;
    for (r = 1; (r & i) == 0; r <<= 1) {
      ++rtn;
    }
    return rtn;
  }
}

function toPowerOfTwoString(value){
  var buf, digits, pos;
  buf = initDim(_3C_classLit, makeCastMap([Q$Serializable]), -1, 8, 1);
  digits = ($clinit_Number$__Digits() , digits_0);
  pos = 7;
  if (value >= 0) {
    while (value > 15) {
      buf[pos--] = digits[value & 15];
      value >>= 4;
    }
  }
   else {
    while (pos > 0) {
      buf[pos--] = digits[value & 15];
      value >>= 4;
    }
  }
  buf[pos] = digits[value & 15];
  return __valueOf(buf, pos, 8);
}

function valueOf_3(i){
  var rebase, result;
  if (i > -129 && i < 128) {
    rebase = i + 128;
    result = ($clinit_Integer$BoxedValues() , boxedValues_0)[rebase];
    !result && (result = boxedValues_0[rebase] = new Integer_0(i));
    return result;
  }
  return new Integer_0(i);
}

defineSeed(515, 511, makeCastMap([Q$Serializable, Q$Comparable, Q$Integer, Q$Number]), Integer_0);
_.compareTo$ = function compareTo_4(b){
  return this.value_0 < b.value_0?-1:this.value_0 > b.value_0?1:0;
}
;
_.equals$ = function equals_16(o){
  return instanceOf(o, Q$Integer) && o.value_0 == this.value_0;
}
;
_.hashCode$ = function hashCode_17(){
  return this.value_0;
}
;
_.toString$ = function toString_23(){
  return '' + this.value_0;
}
;
_.value_0 = 0;
function $clinit_Integer$BoxedValues(){
  $clinit_Integer$BoxedValues = nullMethod;
  boxedValues_0 = initDim(_3Ljava_lang_Integer_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Integer, 256, 0);
}

var boxedValues_0;
function Long_0(value){
  this.value_0 = value;
}

function signum(i){
  return eq(i, P0_longLit)?0:lt(i, P0_longLit)?-1:1;
}

function valueOf_4(i){
  var rebase, result;
  if (gt(i, N81_longLit) && lt(i, P80_longLit)) {
    rebase = toInt(i) + 128;
    result = ($clinit_Long$BoxedValues() , boxedValues_1)[rebase];
    !result && (result = boxedValues_1[rebase] = new Long_0(i));
    return result;
  }
  return new Long_0(i);
}

defineSeed(517, 511, makeCastMap([Q$Serializable, Q$Comparable, Q$Long, Q$Number]), Long_0);
_.compareTo$ = function compareTo_5(b){
  return lt(this.value_0, b.value_0)?-1:gt(this.value_0, b.value_0)?1:0;
}
;
_.equals$ = function equals_17(o){
  return instanceOf(o, Q$Long) && eq(o.value_0, this.value_0);
}
;
_.hashCode$ = function hashCode_18(){
  return toInt(this.value_0);
}
;
_.toString$ = function toString_24(){
  return '' + toString_12(this.value_0);
}
;
_.value_0 = P0_longLit;
function $clinit_Long$BoxedValues(){
  $clinit_Long$BoxedValues = nullMethod;
  boxedValues_1 = initDim(_3Ljava_lang_Long_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Long, 256, 0);
}

var boxedValues_1;
function abs(x){
  return x <= 0?0 - x:x;
}

function floor(x){
  return Math.floor(x);
}

function max_0(x, y){
  return x > y?x:y;
}

function max_1(x, y){
  return x > y?x:y;
}

function min(x, y){
  return x < y?x:y;
}

function min_0(x, y){
  return x < y?x:y;
}

function min_1(y){
  return lt(P64_longLit, y)?P64_longLit:y;
}

function pow(x, exp){
  return Math.pow(x, exp);
}

function round(x){
  return Math.round(x);
}

function sqrt(x){
  return Math.sqrt(x);
}

function NullPointerException_0(){
  RuntimeException_0.call(this);
}

function NullPointerException_1(message){
  RuntimeException_1.call(this, message);
}

defineSeed(520, 77, makeCastMap([Q$Serializable, Q$Exception, Q$RuntimeException, Q$Throwable]), NullPointerException_0, NullPointerException_1);
function $clinit_Number$__Digits(){
  $clinit_Number$__Digits = nullMethod;
  digits_0 = initValues(_3C_classLit, makeCastMap([Q$Serializable]), -1, [48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122]);
}

var digits_0;
function $clinit_Number$__ParseLong(){
  $clinit_Number$__ParseLong = nullMethod;
  var i;
  maxDigitsForRadix = initValues(_3I_classLit, makeCastMap([Q$int_$1, Q$Serializable]), -1, [-1, -1, 30, 19, 15, 13, 11, 11, 10, 9, 9, 8, 8, 8, 8, 7, 7, 7, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5]);
  maxDigitsRadixPower = initDim(_3I_classLit, makeCastMap([Q$int_$1, Q$Serializable]), -1, 37, 1);
  maxLengthForRadix = initValues(_3I_classLit, makeCastMap([Q$int_$1, Q$Serializable]), -1, [-1, -1, 63, 40, 32, 28, 25, 23, 21, 20, 19, 19, 18, 18, 17, 17, 16, 16, 16, 15, 15, 15, 15, 14, 14, 14, 14, 14, 14, 13, 13, 13, 13, 13, 13, 13, 13]);
  maxValueForRadix = initDim(_3J_classLit, makeCastMap([Q$Serializable]), -1, 37, 3);
  for (i = 2; i <= 36; ++i) {
    maxDigitsRadixPower[i] = round_int(pow(i, maxDigitsForRadix[i]));
    maxValueForRadix[i] = div(P7fffffffffffffff_longLit, fromInt(maxDigitsRadixPower[i]));
  }
}

var maxDigitsForRadix, maxDigitsRadixPower, maxLengthForRadix, maxValueForRadix;
function NumberFormatException_0(message){
  IllegalArgumentException_1.call(this, message);
}

defineSeed(523, 513, makeCastMap([Q$Serializable, Q$Exception, Q$RuntimeException, Q$Throwable]), NumberFormatException_0);
function StackTraceElement_0(methodName, fileName){
  this.className = 'Unknown';
  this.methodName = methodName;
  this.fileName = fileName;
  this.lineNumber = -1;
}

defineSeed(524, 1, makeCastMap([Q$Serializable, Q$StackTraceElement]), StackTraceElement_0);
_.toString$ = function toString_25(){
  return this.className + '.' + this.methodName + '(' + (this.fileName != null?this.fileName:'Unknown Source') + (this.lineNumber >= 0?':' + this.lineNumber:'') + ')';
}
;
_.className = null;
_.fileName = null;
_.lineNumber = 0;
_.methodName = null;
function $charAt(this$static, index){
  return this$static.charCodeAt(index);
}

function $endsWith(this$static, suffix){
  return this$static.lastIndexOf(suffix) != -1 && this$static.lastIndexOf(suffix) == this$static.length - suffix.length;
}

function $equals_0(this$static, other){
  if (!instanceOf(other, Q$String)) {
    return false;
  }
  return String(this$static) == other;
}

function $equalsIgnoreCase(this$static, other){
  if (other == null)
    return false;
  return this$static == other || this$static.toLowerCase() == other.toLowerCase();
}

function $indexOf_2(this$static, str){
  return this$static.indexOf(str);
}

function $indexOf_3(this$static, str, startIndex){
  return this$static.indexOf(str, startIndex);
}

function $lastIndexOf(this$static, str){
  return this$static.lastIndexOf(str);
}

function $lastIndexOf_0(this$static, str, start){
  return this$static.lastIndexOf(str, start);
}

function $replace_0(this$static, from, to){
  var regex, replacement;
  regex = $replaceAll(from, '([/\\\\\\.\\*\\+\\?\\|\\(\\)\\[\\]\\{\\}$^])', '\\\\$1');
  replacement = $replaceAll($replaceAll(to, '\\\\', '\\\\\\\\'), '\\$', '\\\\$');
  return $replaceAll(this$static, regex, replacement);
}

function $replaceAll(this$static, regex, replace){
  replace = __translateReplaceString(replace);
  return this$static.replace(RegExp(regex, 'g'), replace);
}

function $replaceFirst(this$static, regex, replace){
  replace = __translateReplaceString(replace);
  return this$static.replace(RegExp(regex), replace);
}

function $split(this$static, regex, maxMatch){
  var compiled = new RegExp(regex, 'g');
  var out = [];
  var count = 0;
  var trail = this$static;
  var lastTrail = null;
  while (true) {
    var matchObj = compiled.exec(trail);
    if (matchObj == null || trail == '' || count == maxMatch - 1 && maxMatch > 0) {
      out[count] = trail;
      break;
    }
     else {
      out[count] = trail.substring(0, matchObj.index);
      trail = trail.substring(matchObj.index + matchObj[0].length, trail.length);
      compiled.lastIndex = 0;
      if (lastTrail == trail) {
        out[count] = trail.substring(0, 1);
        trail = trail.substring(1);
      }
      lastTrail = trail;
      count++;
    }
  }
  if (maxMatch == 0 && this$static.length > 0) {
    var lastNonEmpty = out.length;
    while (lastNonEmpty > 0 && out[lastNonEmpty - 1] == '') {
      --lastNonEmpty;
    }
    lastNonEmpty < out.length && out.splice(lastNonEmpty, out.length - lastNonEmpty);
  }
  var jr = __createArray(out.length);
  for (var i = 0; i < out.length; ++i) {
    jr[i] = out[i];
  }
  return jr;
}

function $substring(this$static, beginIndex){
  return this$static.substr(beginIndex, this$static.length - beginIndex);
}

function $substring_0(this$static, beginIndex, endIndex){
  return this$static.substr(beginIndex, endIndex - beginIndex);
}

function $trim(this$static){
  if (this$static.length == 0 || this$static[0] > ' ' && this$static[this$static.length - 1] > ' ') {
    return this$static;
  }
  var r1 = this$static.replace(/^(\s*)/, '');
  var r2 = r1.replace(/\s*$/, '');
  return r2;
}

function __createArray(numElements){
  return initDim(_3Ljava_lang_String_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$String, numElements, 0);
}

function __translateReplaceString(replaceStr){
  var pos;
  pos = 0;
  while (0 <= (pos = replaceStr.indexOf('\\', pos))) {
    replaceStr.charCodeAt(pos + 1) == 36?(replaceStr = replaceStr.substr(0, pos - 0) + '$' + $substring(replaceStr, ++pos)):(replaceStr = replaceStr.substr(0, pos - 0) + $substring(replaceStr, ++pos));
  }
  return replaceStr;
}

function __valueOf(x, start, end){
  x = x.slice(start, end);
  return String.fromCharCode.apply(null, x);
}

--></script>
<script><!--
function compareTo_7(thisStr, otherStr){
  thisStr = String(thisStr);
  if (thisStr == otherStr) {
    return 0;
  }
  return thisStr < otherStr?-1:1;
}

function fromCodePoint(codePoint){
  var hiSurrogate, loSurrogate;
  if (codePoint >= 65536) {
    hiSurrogate = 55296 + (~~(codePoint - 65536) >> 10 & 1023) & 65535;
    loSurrogate = 56320 + (codePoint - 65536 & 1023) & 65535;
    return String.fromCharCode(hiSurrogate) + String.fromCharCode(loSurrogate);
  }
   else {
    return String.fromCharCode(codePoint & 65535);
  }
}

_ = String.prototype;
_.castableTypeMap$ = makeCastMap([Q$String, Q$Serializable, Q$CharSequence, Q$Comparable]);
_.compareTo$ = function compareTo_6(other){
  return compareTo_7(this, other);
}
;
_.equals$ = function equals_18(other){
  return $equals_0(this, other);
}
;
_.hashCode$ = function hashCode_19(){
  return getHashCode_0(this);
}
;
_.toString$ = _.toString;
function $clinit_String$HashCache(){
  $clinit_String$HashCache = nullMethod;
  back_0 = {};
  front_0 = {};
}

function compute(str){
  var hashCode, i, n, nBatch;
  hashCode = 0;
  n = str.length;
  nBatch = n - 4;
  i = 0;
  while (i < nBatch) {
    hashCode = str.charCodeAt(i + 3) + 31 * (str.charCodeAt(i + 2) + 31 * (str.charCodeAt(i + 1) + 31 * (str.charCodeAt(i) + 31 * hashCode))) | 0;
    i += 4;
  }
  while (i < n) {
    hashCode = hashCode * 31 + $charAt(str, i++);
  }
  return hashCode | 0;
}

function getHashCode_0(str){
  $clinit_String$HashCache();
  var key = ':' + str;
  var result = front_0[key];
  if (result != null) {
    return result;
  }
  result = back_0[key];
  result == null && (result = compute(str));
  increment();
  return front_0[key] = result;
}

function increment(){
  if (count_0 == 256) {
    back_0 = front_0;
    front_0 = {};
    count_0 = 0;
  }
  ++count_0;
}

var back_0, count_0 = 0, front_0;
function $append_4(this$static, x){
  $append_1(this$static.impl, x);
  return this$static;
}

function $append_5(this$static, x){
  $append_3(this$static.impl, x);
  return this$static;
}

function StringBuffer_0(){
  this.impl = new StringBufferImplAppend_0;
}

defineSeed(526, 1, makeCastMap([Q$CharSequence]), StringBuffer_0);
_.toString$ = function toString_26(){
  return this.impl.string;
}
;
function $$init_2(this$static){
  this$static.impl = new StringBufferImplAppend_0;
}

function $append_6(this$static, x){
  $appendNonNull(this$static.impl, String.fromCharCode(x));
  return this$static;
}

function $append_7(this$static, x){
  $append(this$static.impl, x);
  return this$static;
}

function $append_8(this$static, x){
  $append_0(this$static.impl, x);
  return this$static;
}

function $append_9(this$static, x){
  $append_1(this$static.impl, x);
  return this$static;
}

function $append_10(this$static, x){
  $appendNonNull(this$static.impl, '' + toString_12(x));
  return this$static;
}

function $append_11(this$static, x){
  $append_2(this$static.impl, x);
  return this$static;
}

function $append_12(this$static, x){
  $append_3(this$static.impl, x);
  return this$static;
}

function $append_13(this$static, x){
  $appendNonNull(this$static.impl, String.fromCharCode.apply(null, x));
  return this$static;
}

function $charAt_0(this$static, index){
  return $charAt(this$static.impl.string, index);
}

function $setLength(this$static, newLength){
  var oldLength;
  oldLength = this$static.impl.string.length;
  newLength < oldLength?($replace(this$static.impl, newLength, oldLength) , this$static):newLength > oldLength && $append_13(this$static, initDim(_3C_classLit, makeCastMap([Q$Serializable]), -1, newLength - oldLength, 1));
}

function StringBuilder_0(){
  $$init_2(this);
}

function StringBuilder_1(s){
  $$init_2(this);
  $append_3(this.impl, s);
}

defineSeed(527, 1, makeCastMap([Q$CharSequence]), StringBuilder_0, StringBuilder_1);
_.toString$ = function toString_27(){
  return this.impl.string;
}
;
function arraycopy(src, srcOfs, dest, destOfs, len){
  var destArray, destComp, destEnd, destType, destlen, srcArray, srcComp, srcType, srclen;
  if (src == null || dest == null) {
    throw new NullPointerException_0;
  }
  srcType = getClass__devirtual$(src);
  destType = getClass__devirtual$(dest);
  if ((srcType.modifiers & 4) == 0 || (destType.modifiers & 4) == 0) {
    throw new ArrayStoreException_1('Must be array types');
  }
  srcComp = srcType.componentType;
  destComp = destType.componentType;
  if (!((srcComp.modifiers & 1) != 0?srcComp == destComp:(destComp.modifiers & 1) == 0)) {
    throw new ArrayStoreException_1('Array types must match');
  }
  srclen = src.length;
  destlen = dest.length;
  if (srcOfs < 0 || destOfs < 0 || len < 0 || srcOfs + len > srclen || destOfs + len > destlen) {
    throw new IndexOutOfBoundsException_0;
  }
  if (((srcComp.modifiers & 1) == 0 || (srcComp.modifiers & 4) != 0) && srcType != destType) {
    srcArray = src;
    destArray = dest;
    if (maskUndefined(src) === maskUndefined(dest) && srcOfs < destOfs) {
      srcOfs += len;
      for (destEnd = destOfs + len; destEnd-- > destOfs;) {
        setCheck(destArray, destEnd, srcArray[--srcOfs]);
      }
    }
     else {
      for (destEnd = destOfs + len; destOfs < destEnd;) {
        setCheck(destArray, destOfs++, srcArray[srcOfs++]);
      }
    }
  }
   else {
    Array.prototype.splice.apply(dest, [destOfs, len].concat(src.slice(srcOfs, srcOfs + len)));
  }
}

function UnsupportedOperationException_0(){
  RuntimeException_0.call(this);
}

function UnsupportedOperationException_1(message){
  RuntimeException_1.call(this, message);
}

defineSeed(529, 77, makeCastMap([Q$Serializable, Q$Exception, Q$RuntimeException, Q$Throwable]), UnsupportedOperationException_0, UnsupportedOperationException_1);
function $clear_3(this$static){
  this$static.position_0 = 0;
  this$static.mark = -1;
  this$static.limit = this$static.capacity;
  return this$static;
}

function $flip(this$static){
  this$static.limit = this$static.position_0;
  this$static.position_0 = 0;
  this$static.mark = -1;
  return this$static;
}

function $position(this$static){
  if (0 > this$static.limit) {
    throw new IllegalArgumentException_0;
  }
  this$static.position_0 = 0;
  this$static.mark != -1 && this$static.mark > this$static.position_0 && (this$static.mark = -1);
  return this$static;
}

function Buffer_0(capacity){
  if (capacity < 0) {
    throw new IllegalArgumentException_0;
  }
  this.capacity = this.limit = capacity;
}

defineSeed(530, 1, {});
_.capacity = 0;
_.limit = 0;
_.mark = -1;
_.position_0 = 0;
function BufferOverflowException_0(){
  RuntimeException_0.call(this);
}

defineSeed(531, 77, makeCastMap([Q$Serializable, Q$Exception, Q$RuntimeException, Q$Throwable]), BufferOverflowException_0);
function BufferUnderflowException_0(){
  RuntimeException_0.call(this);
}

defineSeed(532, 77, makeCastMap([Q$Serializable, Q$Exception, Q$RuntimeException, Q$Throwable]), BufferUnderflowException_0);
function $$init_3(this$static){
  this$static.order = ($clinit_ByteOrder() , BIG_ENDIAN);
}

function $asShortBuffer(this$static){
  if (this$static.order != ($clinit_ByteOrder() , $clinit_ByteOrder() , NATIVE_ORDER)) {
    throw new RuntimeException_1('Native order supported only.');
  }
  return new ShortBuffer_0($slice(this$static));
}

function $compareTo(this$static, otherBuffer){
  var compareRemaining, otherByte, otherPos, thisByte, thisPos;
  compareRemaining = this$static.limit - this$static.position_0 < otherBuffer.limit - otherBuffer.position_0?this$static.limit - this$static.position_0:otherBuffer.limit - otherBuffer.position_0;
  thisPos = this$static.position_0;
  otherPos = otherBuffer.position_0;
  while (compareRemaining > 0) {
    thisByte = this$static.byteArray[thisPos];
    otherByte = otherBuffer.byteArray[otherPos];
    if (thisByte != otherByte) {
      return thisByte < otherByte?-1:1;
    }
    ++thisPos;
    ++otherPos;
    --compareRemaining;
  }
  return this$static.limit - this$static.position_0 - (otherBuffer.limit - otherBuffer.position_0);
}

function $get_2(this$static, index){
  return this$static.byteArray[index];
}

function $order(this$static, byteOrder){
  this$static.order = byteOrder;
  return this$static;
}

function $slice(this$static){
  var slice;
  slice = new ByteBuffer_2(this$static.byteArray.buffer, this$static.limit - this$static.position_0, this$static.byteArray.byteOffset + this$static.position_0);
  slice.order = this$static.order;
  return slice;
}

function ByteBuffer_0(capacity){
  ByteBuffer_1.call(this, new ArrayBuffer(capacity));
}

function ByteBuffer_1(buf){
  Buffer_0.call(this, buf.byteLength);
  $$init_3(this);
  this.byteArray = new Int8Array(buf);
}

function ByteBuffer_2(buffer, capacity, offset){
  Buffer_0.call(this, capacity);
  $$init_3(this);
  this.byteArray = new Int8Array(buffer, offset, capacity);
}

function allocateDirect(capacity){
  if (capacity < 0) {
    throw new IllegalArgumentException_0;
  }
  return new ByteBuffer_0(capacity);
}

defineSeed(533, 530, makeCastMap([Q$Comparable, Q$ByteBuffer, Q$HasArrayBufferView]), ByteBuffer_0, ByteBuffer_2);
_.compareTo$ = function compareTo_8(otherBuffer){
  return $compareTo(this, otherBuffer);
}
;
_.equals$ = function equals_19(other){
  var equalSoFar, myPosition, otherBuffer, otherPosition;
  if (!instanceOf(other, Q$ByteBuffer)) {
    return false;
  }
  otherBuffer = other;
  if (this.limit - this.position_0 != otherBuffer.limit - otherBuffer.position_0) {
    return false;
  }
  myPosition = this.position_0;
  otherPosition = otherBuffer.position_0;
  equalSoFar = true;
  while (equalSoFar && myPosition < this.limit) {
    equalSoFar = $get_2(this, myPosition++) == $get_2(otherBuffer, otherPosition++);
  }
  return equalSoFar;
}
;
_.getElementSize = function getElementSize(){
  return 1;
}
;
_.getElementType = function getElementType(){
  return 5120;
}
;
_.getTypedArray = function getTypedArray(){
  return this.byteArray;
}
;
_.hashCode$ = function hashCode_20(){
  var hash, myPosition;
  myPosition = this.position_0;
  hash = 0;
  while (myPosition < this.limit) {
    hash = hash + $get_2(this, myPosition++);
  }
  return hash;
}
;
_.toString$ = function toString_28(){
  var buf;
  buf = new StringBuffer_0;
  $append_5(buf, Ljava_nio_ByteBuffer_2_classLit.typeName);
  buf.impl.string += ', status: capacity=';
  $append_4(buf, this.capacity);
  buf.impl.string += ' position=';
  $append_4(buf, this.position_0);
  buf.impl.string += ' limit=';
  $append_4(buf, this.limit);
  return buf.impl.string;
}
;
_.byteArray = null;
function $clinit_ByteOrder(){
  $clinit_ByteOrder = nullMethod;
  BIG_ENDIAN = new ByteOrder_0('BIG_ENDIAN');
  LITTLE_ENDIAN = new ByteOrder_0('LITTLE_ENDIAN');
  NATIVE_ORDER = LITTLE_ENDIAN;
}

function ByteOrder_0(name_0){
  this.name_0 = name_0;
}

defineSeed(534, 1, {}, ByteOrder_0);
_.toString$ = function toString_29(){
  return this.name_0;
}
;
_.name_0 = null;
var BIG_ENDIAN, LITTLE_ENDIAN, NATIVE_ORDER = null;
function $compareTo_0(this$static, otherBuffer){
  var compareRemaining, otherFloat, otherPos, thisFloat, thisPos;
  compareRemaining = this$static.limit - this$static.position_0 < otherBuffer.limit - otherBuffer.position_0?this$static.limit - this$static.position_0:otherBuffer.limit - otherBuffer.position_0;
  thisPos = this$static.position_0;
  otherPos = otherBuffer.position_0;
  while (compareRemaining > 0) {
    thisFloat = this$static.floatArray[thisPos];
    otherFloat = otherBuffer.floatArray[otherPos];
    if (thisFloat != otherFloat && (thisFloat == thisFloat || otherFloat == otherFloat)) {
      return thisFloat < otherFloat?-1:1;
    }
    ++thisPos;
    ++otherPos;
    --compareRemaining;
  }
  return this$static.limit - this$static.position_0 - (otherBuffer.limit - otherBuffer.position_0);
}

function $get_3(this$static, index){
  return this$static.floatArray[index];
}

function $get_4(this$static, dest){
  return $get_5(this$static, dest, dest.length);
}

function $get_5(this$static, dest, len){
  var i, length_0;
  length_0 = dest.length;
  if (len < 0 || gt(fromInt(len), fromInt(length_0))) {
    throw new IndexOutOfBoundsException_0;
  }
  if (len > this$static.limit - this$static.position_0) {
    throw new BufferUnderflowException_0;
  }
  for (i = 0; i < len; ++i) {
    dest[i] = this$static.floatArray[this$static.position_0++];
  }
  return this$static;
}

function $put_1(this$static, c){
  this$static.floatArray[this$static.position_0++] = c;
  return this$static;
}

function $put_2(this$static, src, len){
  var i, length_0;
  length_0 = src.length;
  if (len < 0 || gt(fromInt(len), fromInt(length_0))) {
    throw new IndexOutOfBoundsException_0;
  }
  if (len > this$static.limit - this$static.position_0) {
    throw new BufferOverflowException_0;
  }
  for (i = 0; i < len; ++i) {
    $put_1(this$static, src[i]);
  }
  return this$static;
}

function FloatBuffer_0(byteBuffer){
  Buffer_0.call(this, ~~byteBuffer.capacity >> 2);
  this.byteBuffer = byteBuffer;
  $clear_3(this.byteBuffer);
  this.floatArray = create_1(byteBuffer.byteArray.buffer, byteBuffer.byteArray.byteOffset, this.capacity);
}

function allocate(capacity){
  var bb;
  if (capacity < 0) {
    throw new IllegalArgumentException_0;
  }
  bb = allocateDirect(capacity * 4);
  $order(bb, ($clinit_ByteOrder() , $clinit_ByteOrder() , NATIVE_ORDER));
  return new FloatBuffer_0($slice(bb));
}

defineSeed(535, 530, makeCastMap([Q$Comparable, Q$FloatBuffer, Q$HasArrayBufferView]), FloatBuffer_0);
_.compareTo$ = function compareTo_9(otherBuffer){
  return $compareTo_0(this, otherBuffer);
}
;
_.equals$ = function equals_20(other){
  var equalSoFar, myPosition, otherBuffer, otherPosition;
  if (!instanceOf(other, Q$FloatBuffer)) {
    return false;
  }
  otherBuffer = other;
  if (this.limit - this.position_0 != otherBuffer.limit - otherBuffer.position_0) {
    return false;
  }
  myPosition = this.position_0;
  otherPosition = otherBuffer.position_0;
  equalSoFar = true;
  while (equalSoFar && myPosition < this.limit) {
    equalSoFar = $get_3(this, myPosition++) == $get_3(otherBuffer, otherPosition++);
  }
  return equalSoFar;
}
;
_.getElementSize = function getElementSize_0(){
  return 4;
}
;
_.getElementType = function getElementType_0(){
  return 5126;
}
;
_.getTypedArray = function getTypedArray_0(){
  return this.floatArray;
}
;
_.toString$ = function toString_30(){
  var buf;
  buf = new StringBuffer_0;
  $append_5(buf, Ljava_nio_FloatBuffer_2_classLit.typeName);
  buf.impl.string += ', status: capacity=';
  $append_4(buf, this.capacity);
  buf.impl.string += ' position=';
  $append_4(buf, this.position_0);
  buf.impl.string += ' limit=';
  $append_4(buf, this.limit);
  return buf.impl.string;
}
;
_.byteBuffer = null;
_.floatArray = null;
function $compareTo_1(this$static, otherBuffer){
  var compareRemaining, otherByte, otherPos, thisByte, thisPos;
  compareRemaining = this$static.limit - this$static.position_0 < otherBuffer.limit - otherBuffer.position_0?this$static.limit - this$static.position_0:otherBuffer.limit - otherBuffer.position_0;
  thisPos = this$static.position_0;
  otherPos = otherBuffer.position_0;
  while (compareRemaining > 0) {
    thisByte = this$static.shortArray[thisPos];
    otherByte = otherBuffer.shortArray[otherPos];
    if (thisByte != otherByte) {
      return thisByte < otherByte?-1:1;
    }
    ++thisPos;
    ++otherPos;
    --compareRemaining;
  }
  return this$static.limit - this$static.position_0 - (otherBuffer.limit - otherBuffer.position_0);
}

function $get_6(this$static, index){
  return this$static.shortArray[index];
}

function $put_3(this$static, src, len){
  var i, length_0;
  length_0 = src.length;
  if (len < 0 || gt(fromInt(len), fromInt(length_0))) {
    throw new IndexOutOfBoundsException_0;
  }
  if (len > this$static.limit - this$static.position_0) {
    throw new BufferOverflowException_0;
  }
  for (i = 0; i < len; ++i) {
    this$static.shortArray[this$static.position_0++] = src[i];
  }
  return this$static;
}

function ShortBuffer_0(byteBuffer){
  Buffer_0.call(this, ~~byteBuffer.capacity >> 1);
  this.byteBuffer = byteBuffer;
  $clear_3(this.byteBuffer);
  this.shortArray = create_2(byteBuffer.byteArray.buffer, byteBuffer.byteArray.byteOffset, this.capacity);
}

defineSeed(536, 530, makeCastMap([Q$Comparable, Q$ShortBuffer, Q$HasArrayBufferView]), ShortBuffer_0);
_.compareTo$ = function compareTo_10(otherBuffer){
  return $compareTo_1(this, otherBuffer);
}
;
_.equals$ = function equals_21(other){
  var equalSoFar, myPosition, otherBuffer, otherPosition;
  if (!instanceOf(other, Q$ShortBuffer)) {
    return false;
  }
  otherBuffer = other;
  if (this.limit - this.position_0 != otherBuffer.limit - otherBuffer.position_0) {
    return false;
  }
  myPosition = this.position_0;
  otherPosition = otherBuffer.position_0;
  equalSoFar = true;
  while (equalSoFar && myPosition < this.limit) {
    equalSoFar = $get_6(this, myPosition++) == $get_6(otherBuffer, otherPosition++);
  }
  return equalSoFar;
}
;
_.getElementSize = function getElementSize_1(){
  return 2;
}
;
_.getElementType = function getElementType_1(){
  return 5122;
}
;
_.getTypedArray = function getTypedArray_1(){
  return this.shortArray;
}
;
_.hashCode$ = function hashCode_21(){
  var hash, myPosition;
  myPosition = this.position_0;
  hash = 0;
  while (myPosition < this.limit) {
    hash = hash + $get_6(this, myPosition++);
  }
  return hash;
}
;
_.toString$ = function toString_31(){
  var buf;
  buf = new StringBuffer_0;
  $append_5(buf, Ljava_nio_ShortBuffer_2_classLit.typeName);
  buf.impl.string += ', status: capacity=';
  $append_4(buf, this.capacity);
  buf.impl.string += ' position=';
  $append_4(buf, this.position_0);
  buf.impl.string += ' limit=';
  $append_4(buf, this.limit);
  return buf.impl.string;
}
;
_.byteBuffer = null;
_.shortArray = null;
function $addAllHashEntries(this$static, dest){
  var hashCodeMap = this$static.hashCodeMap;
  for (var hashCode in hashCodeMap) {
    var hashCodeInt = parseInt(hashCode, 10);
    if (hashCode == hashCodeInt) {
      var array = hashCodeMap[hashCodeInt];
      for (var i = 0, c = array.length; i < c; ++i) {
        dest.add(array[i]);
      }
    }
  }
}

function $addAllStringEntries(this$static, dest){
  var stringMap = this$static.stringMap;
  for (var key in stringMap) {
    if (key.charCodeAt(0) == 58) {
      var entry = new AbstractHashMap$MapEntryString_0(this$static, key.substring(1));
      dest.add(entry);
    }
  }
}

function $clearImpl(this$static){
  this$static.hashCodeMap = [];
  this$static.stringMap = {};
  this$static.nullSlotLive = false;
  this$static.nullSlot = null;
  this$static.size = 0;
}

function $containsHashValue(this$static, value){
  var hashCodeMap = this$static.hashCodeMap;
  for (var hashCode in hashCodeMap) {
    var hashCodeInt = parseInt(hashCode, 10);
    if (hashCode == hashCodeInt) {
      var array = hashCodeMap[hashCodeInt];
      for (var i = 0, c = array.length; i < c; ++i) {
        var entry = array[i];
        var entryValue = entry.getValue();
        if (this$static.equalsBridge(value, entryValue)) {
          return true;
        }
      }
    }
  }
  return false;
}

function $containsStringValue(this$static, value){
  var stringMap = this$static.stringMap;
  for (var key in stringMap) {
    if (key.charCodeAt(0) == 58) {
      var entryValue = stringMap[key];
      if (this$static.equalsBridge(value, entryValue)) {
        return true;
      }
    }
  }
  return false;
}

function $getHashValue(this$static, key, hashCode){
  var array = this$static.hashCodeMap[hashCode];
  if (array) {
    for (var i = 0, c = array.length; i < c; ++i) {
      var entry = array[i];
      var entryKey = entry.getKey();
      if (this$static.equalsBridge(key, entryKey)) {
        return entry.getValue();
      }
    }
  }
  return null;
}

function $getStringValue(this$static, key){
  return this$static.stringMap[':' + key];
}

function $hasHashValue(this$static, key, hashCode){
  var array = this$static.hashCodeMap[hashCode];
  if (array) {
    for (var i = 0, c = array.length; i < c; ++i) {
      var entry = array[i];
      var entryKey = entry.getKey();
      if (this$static.equalsBridge(key, entryKey)) {
        return true;
      }
    }
  }
  return false;
}

function $putHashValue(this$static, key, value, hashCode){
  var array = this$static.hashCodeMap[hashCode];
  if (array) {
    for (var i = 0, c = array.length; i < c; ++i) {
      var entry = array[i];
      var entryKey = entry.getKey();
      if (this$static.equalsBridge(key, entryKey)) {
        var previous = entry.getValue();
        entry.setValue(value);
        return previous;
      }
    }
  }
   else {
    array = this$static.hashCodeMap[hashCode] = [];
  }
  var entry = new MapEntryImpl_0(key, value);
  array.push(entry);
  ++this$static.size;
  return null;
}

function $putNullSlot(this$static, value){
  var result;
  result = this$static.nullSlot;
  this$static.nullSlot = value;
  if (!this$static.nullSlotLive) {
    this$static.nullSlotLive = true;
    ++this$static.size;
  }
  return result;
}

function $putStringValue(this$static, key, value){
  var result, stringMap = this$static.stringMap;
  key = ':' + key;
  key in stringMap?(result = stringMap[key]):++this$static.size;
  stringMap[key] = value;
  return result;
}

function $removeHashValue(this$static, key, hashCode){
  var array = this$static.hashCodeMap[hashCode];
  if (array) {
    for (var i = 0, c = array.length; i < c; ++i) {
      var entry = array[i];
      var entryKey = entry.getKey();
      if (this$static.equalsBridge(key, entryKey)) {
        array.length == 1?delete this$static.hashCodeMap[hashCode]:array.splice(i, 1);
        --this$static.size;
        return entry.getValue();
      }
    }
  }
  return null;
}

function $removeNullSlot(this$static){
  var result;
  result = this$static.nullSlot;
  this$static.nullSlot = null;
  if (this$static.nullSlotLive) {
    this$static.nullSlotLive = false;
    --this$static.size;
  }
  return result;
}

function $removeStringValue(this$static, key){
  var result, stringMap = this$static.stringMap;
  key = ':' + key;
  if (key in stringMap) {
    result = stringMap[key];
    --this$static.size;
    delete stringMap[key];
  }
  return result;
}

defineSeed(537, 198, makeCastMap([Q$Map]));
_.clear_0 = function clear(){
  $clearImpl(this);
}
;
_.containsKey = function containsKey_2(key){
  return key == null?this.nullSlotLive:instanceOf(key, Q$String)?':' + key in this.stringMap:$hasHashValue(this, key, this.getHashCode(key));
}
;
_.containsValue = function containsValue_1(value){
  if (this.nullSlotLive && this.equals(this.nullSlot, value)) {
    return true;
  }
   else if ($containsStringValue(this, value)) {
    return true;
  }
   else if ($containsHashValue(this, value)) {
    return true;
  }
  return false;
}
;
_.entrySet_0 = function entrySet_2(){
  return new AbstractHashMap$EntrySet_0(this);
}
;
_.equalsBridge = function equalsBridge(value1, value2){
  return this.equals(value1, value2);
}
;
_.get_1 = function get_11(key){
  return key == null?this.nullSlot:instanceOf(key, Q$String)?this.stringMap[':' + key]:$getHashValue(this, key, this.getHashCode(key));
}
;
_.put = function put_2(key, value){
  return key == null?$putNullSlot(this, value):instanceOf(key, Q$String)?$putStringValue(this, key, value):$putHashValue(this, key, value, this.getHashCode(key));
}
;
_.remove_1 = function remove_12(key){
  return key == null?$removeNullSlot(this):instanceOf(key, Q$String)?$removeStringValue(this, key):$removeHashValue(this, key, this.getHashCode(key));
}
;
_.size_0 = function size_5(){
  return this.size;
}
;
_.hashCodeMap = null;
_.nullSlot = null;
_.nullSlotLive = false;
_.size = 0;
_.stringMap = null;
function $contains(this$static, o){
  var entry, key, value;
  if (instanceOf(o, Q$Map$Entry)) {
    entry = o;
    key = entry.getKey();
    if (this$static.this$0.containsKey(key)) {
      value = this$static.this$0.get_1(key);
      return this$static.this$0.equals(entry.getValue(), value);
    }
  }
  return false;
}

function AbstractHashMap$EntrySet_0(this$0){
  this.this$0 = this$0;
}

defineSeed(538, 202, makeCastMap([Q$Set]), AbstractHashMap$EntrySet_0);
_.contains_0 = function contains_3(o){
  return $contains(this, o);
}
;
_.iterator_0 = function iterator_4(){
  return new AbstractHashMap$EntrySetIterator_0(this.this$0);
}
;
_.remove = function remove_13(entry){
  var key;
  if ($contains(this, entry)) {
    key = entry.getKey();
    this.this$0.remove_1(key);
    return true;
  }
  return false;
}
;
_.size_0 = function size_6(){
  return this.this$0.size_0();
}
;
_.this$0 = null;
function AbstractHashMap$EntrySetIterator_0(this$0){
  var list;
  this.this$0 = this$0;
  list = new ArrayList_0;
  this$0.nullSlotLive && $add_0(list, new AbstractHashMap$MapEntryNull_0(this$0));
  $addAllStringEntries(this$0, list);
  $addAllHashEntries(this$0, list);
  this.iter = new AbstractList$IteratorImpl_0(list);
}

defineSeed(539, 1, {}, AbstractHashMap$EntrySetIterator_0);
_.hasNext = function hasNext_1(){
  return $hasNext_0(this.iter);
}
;
_.next_0 = function next_2(){
  return this.last = $next_2(this.iter);
}
;
_.remove_2 = function remove_14(){
  if (!this.last) {
    throw new IllegalStateException_1('Must call next() before remove().');
  }
   else {
    $remove_10(this.iter);
    this.this$0.remove_1(this.last.getKey());
    this.last = null;
  }
}
;
_.iter = null;
_.last = null;
_.this$0 = null;
defineSeed(541, 1, makeCastMap([Q$Map$Entry]));
_.equals$ = function equals_22(other){
  var entry;
  if (instanceOf(other, Q$Map$Entry)) {
    entry = other;
    if (equalsWithNullCheck(this.getKey(), entry.getKey()) && equalsWithNullCheck(this.getValue(), entry.getValue())) {
      return true;
    }
  }
  return false;
}
;
_.hashCode$ = function hashCode_22(){
  var keyHash, valueHash;
  keyHash = 0;
  valueHash = 0;
  this.getKey() != null && (keyHash = hashCode__devirtual$(this.getKey()));
  this.getValue() != null && (valueHash = hashCode__devirtual$(this.getValue()));
  return keyHash ^ valueHash;
}
;
_.toString$ = function toString_32(){
  return this.getKey() + '=' + this.getValue();
}
;
function AbstractHashMap$MapEntryNull_0(this$0){
  this.this$0 = this$0;
}

defineSeed(540, 541, makeCastMap([Q$Map$Entry]), AbstractHashMap$MapEntryNull_0);
_.getKey = function getKey_0(){
  return null;
}
;
_.getValue = function getValue_5(){
  return this.this$0.nullSlot;
}
;
_.setValue = function setValue_0(object){
  return $putNullSlot(this.this$0, object);
}
;
_.this$0 = null;
function AbstractHashMap$MapEntryString_0(this$0, key){
  this.this$0 = this$0;
  this.key_0 = key;
}

defineSeed(542, 541, makeCastMap([Q$Map$Entry]), AbstractHashMap$MapEntryString_0);
_.getKey = function getKey_1(){
  return this.key_0;
}
;
_.getValue = function getValue_6(){
  return $getStringValue(this.this$0, this.key_0);
}
;
_.setValue = function setValue_1(object){
  return $putStringValue(this.this$0, this.key_0, object);
}
;
_.key_0 = null;
_.this$0 = null;
function $hasNext_0(this$static){
  return this$static.i < this$static.this$0_0.size_0();
}

function $next_2(this$static){
  if (this$static.i >= this$static.this$0_0.size_0()) {
    throw new NoSuchElementException_0;
  }
  return this$static.this$0_0.get(this$static.last = this$static.i++);
}

function $remove_10(this$static){
  if (this$static.last < 0) {
    throw new IllegalStateException_0;
  }
  this$static.this$0_0.remove_0(this$static.last);
  this$static.i = this$static.last;
  this$static.last = -1;
}

function AbstractList$IteratorImpl_0(this$0){
  this.this$0_0 = this$0;
}

defineSeed(543, 1, {}, AbstractList$IteratorImpl_0);
_.hasNext = function hasNext_2(){
  return $hasNext_0(this);
}
;
_.next_0 = function next_3(){
  return $next_2(this);
}
;
_.remove_2 = function remove_15(){
  $remove_10(this);
}
;
_.i = 0;
_.last = -1;
_.this$0_0 = null;
function $previous(this$static){
  if (this$static.i <= 0) {
    throw new NoSuchElementException_0;
  }
  return this$static.this$0.get(this$static.last = --this$static.i);
}

function AbstractList$ListIteratorImpl_0(this$0, start){
  var size;
  this.this$0 = this$0;
  this.this$0_0 = this$0;
  size = this$0.size_0();
  (start < 0 || start > size) && indexOutOfBounds(start, size);
  this.i = start;
}

defineSeed(544, 543, {}, AbstractList$ListIteratorImpl_0);
_.hasPrevious = function hasPrevious(){
  return this.i > 0;
}
;
_.previous_0 = function previous_0(){
  return $previous(this);
}
;
_.this$0 = null;
function $iterator(this$static){
  var outerIter;
  outerIter = this$static.val$entrySet.iterator_0();
  return new AbstractMap$1$1_0(outerIter);
}

function AbstractMap$1_0(this$0, val$entrySet){
  this.this$0 = this$0;
  this.val$entrySet = val$entrySet;
}

defineSeed(545, 202, makeCastMap([Q$Set]), AbstractMap$1_0);
_.contains_0 = function contains_4(key){
  return this.this$0.containsKey(key);
}
;
_.iterator_0 = function iterator_5(){
  return $iterator(this);
}
;
_.size_0 = function size_7(){
  return this.val$entrySet.size_0();
}
;
_.this$0 = null;
_.val$entrySet = null;
function $next_3(this$static){
  var entry;
  entry = this$static.val$outerIter.next_0();
  return entry.getKey();
}

function AbstractMap$1$1_0(val$outerIter){
  this.val$outerIter = val$outerIter;
}

defineSeed(546, 1, {}, AbstractMap$1$1_0);
_.hasNext = function hasNext_3(){
  return this.val$outerIter.hasNext();
}
;
_.next_0 = function next_4(){
  return $next_3(this);
}
;
_.remove_2 = function remove_16(){
  this.val$outerIter.remove_2();
}
;
_.val$outerIter = null;
function $iterator_0(this$static){
  var outerIter;
  outerIter = this$static.val$entrySet.iterator_0();
  return new AbstractMap$2$1_0(outerIter);
}

function AbstractMap$2_0(this$0, val$entrySet){
  this.this$0 = this$0;
  this.val$entrySet = val$entrySet;
}

defineSeed(547, 21, {}, AbstractMap$2_0);
--></script>
<script><!--
_.contains_0 = function contains_5(value){
  return this.this$0.containsValue(value);
}
;
_.iterator_0 = function iterator_6(){
  return $iterator_0(this);
}
;
_.size_0 = function size_8(){
  return this.val$entrySet.size_0();
}
;
_.this$0 = null;
_.val$entrySet = null;
function $next_4(this$static){
  var value;
  value = this$static.val$outerIter.next_0().getValue();
  return value;
}

function AbstractMap$2$1_0(val$outerIter){
  this.val$outerIter = val$outerIter;
}

defineSeed(548, 1, {}, AbstractMap$2$1_0);
_.hasNext = function hasNext_4(){
  return this.val$outerIter.hasNext();
}
;
_.next_0 = function next_5(){
  return $next_4(this);
}
;
_.remove_2 = function remove_17(){
  this.val$outerIter.remove_2();
}
;
_.val$outerIter = null;
defineSeed(549, 20, makeCastMap([Q$List]));
_.add_0 = function add_5(index, element){
  var iter;
  iter = $listIterator(this, index);
  $addBefore(iter.this$0, element, iter.currentNode);
  ++iter.currentIndex;
  iter.lastNode = null;
}
;
_.get = function get_12(index){
  var $e0, iter;
  iter = $listIterator(this, index);
  try {
    return $next_7(iter);
  }
   catch ($e0) {
    $e0 = caught_0($e0);
    if (instanceOf($e0, Q$NoSuchElementException)) {
      throw new IndexOutOfBoundsException_1("Can't get element " + index);
    }
     else 
      throw $e0;
  }
}
;
_.iterator_0 = function iterator_7(){
  return $listIterator(this, 0);
}
;
_.remove_0 = function remove_18(index){
  var $e0, iter, old;
  iter = $listIterator(this, index);
  try {
    old = $next_7(iter);
  }
   catch ($e0) {
    $e0 = caught_0($e0);
    if (instanceOf($e0, Q$NoSuchElementException)) {
      throw new IndexOutOfBoundsException_1("Can't remove element " + index);
    }
     else 
      throw $e0;
  }
  $remove_15(iter);
  return old;
}
;
function insertionSort(array, low, high, comp){
  var i, j, t;
  for (i = low + 1; i < high; ++i) {
    for (j = i; j > low && comp.compare(array[j - 1], array[j]) > 0; --j) {
      t = array[j];
      setCheck(array, j, array[j - 1]);
      setCheck(array, j - 1, t);
    }
  }
}

function merge(src, srcLow, srcMid, srcHigh, dest, destLow, destHigh, comp){
  var topIdx;
  topIdx = srcMid;
  while (destLow < destHigh) {
    topIdx >= srcHigh || srcLow < srcMid && comp.compare(src[srcLow], src[topIdx]) <= 0?setCheck(dest, destLow++, src[srcLow++]):setCheck(dest, destLow++, src[topIdx++]);
  }
}

function mergeSort(x, fromIndex, toIndex, comp){
  var temp;
  temp = cloneSubrange(x, fromIndex, toIndex);
  mergeSort_0(temp, x, fromIndex, toIndex, -fromIndex, comp);
}

function mergeSort_0(temp, array, low, high, ofs, comp){
  var length_0, tempHigh, tempLow, tempMid;
  length_0 = high - low;
  if (length_0 < 7) {
    insertionSort(array, low, high, comp);
    return;
  }
  tempLow = low + ofs;
  tempHigh = high + ofs;
  tempMid = tempLow + (~~(tempHigh - tempLow) >> 1);
  mergeSort_0(array, temp, tempLow, tempMid, -ofs, comp);
  mergeSort_0(array, temp, tempMid, tempHigh, -ofs, comp);
  if (comp.compare(temp[tempMid - 1], temp[tempMid]) <= 0) {
    while (low < high) {
      setCheck(array, low++, temp[tempLow++]);
    }
    return;
  }
  merge(temp, tempLow, tempMid, tempHigh, array, low, high, comp);
}

function sort(x, toIndex, c){
  verifySortIndices(toIndex, x.length);
  mergeSort(x, 0, toIndex, c?c:($clinit_Comparators() , $clinit_Comparators() , NATURAL));
}

function sort_0(x, c){
  mergeSort(x, 0, x.length, c?c:($clinit_Comparators() , $clinit_Comparators() , NATURAL));
}

function verifySortIndices(toIndex, length_0){
  if (0 > toIndex) {
    throw new IllegalArgumentException_1('fromIndex(0) > toIndex(' + toIndex + ')');
  }
  if (toIndex > length_0) {
    throw new ArrayIndexOutOfBoundsException_0('fromIndex(0) or toIndex(' + toIndex + ') out of bounds (0 - ' + length_0 + ')');
  }
}

function $get_7(this$static, index){
  checkIndex(index, this$static.array.length);
  return this$static.array[index];
}

function Arrays$ArrayList_0(array){
  this.array = array;
}

defineSeed(551, 20, makeCastMap([Q$Serializable, Q$List]), Arrays$ArrayList_0);
_.contains_0 = function contains_6(o){
  return $indexOf(this, o) != -1;
}
;
_.get = function get_13(index){
  return $get_7(this, index);
}
;
_.size_0 = function size_9(){
  return this.array.length;
}
;
_.array = null;
function $clinit_Collections(){
  $clinit_Collections = nullMethod;
  EMPTY_LIST = new Collections$EmptyList_0;
  EMPTY_SET = new Collections$EmptySet_0;
  reverseComparator = new Collections$1_0;
}

function max_2(coll, comp){
  $clinit_Collections();
  var it, max, t;
  !comp && (comp = ($clinit_Comparators() , $clinit_Comparators() , NATURAL));
  it = new AbstractList$IteratorImpl_0(coll);
  max = $next_2(it);
  while (it.i < it.this$0_0.size_0()) {
    t = $next_2(it);
    comp.compare(t, max) > 0 && (max = t);
  }
  return max;
}

function replaceContents(target, x){
  var i, size;
  size = target.size;
  for (i = 0; i < size; ++i) {
    $set(target, i, x[i]);
  }
}

function reverseOrder(cmp){
  $clinit_Collections();
  if (!cmp) {
    return reverseComparator;
  }
  return new Collections$3_0(cmp);
}

function sort_1(target, c){
  $clinit_Collections();
  var x;
  x = cloneSubrange(target.array, 0, target.size);
  mergeSort(x, 0, x.length, c?c:($clinit_Comparators() , $clinit_Comparators() , NATURAL));
  replaceContents(target, x);
}

var EMPTY_LIST, EMPTY_SET, reverseComparator;
function Collections$1_0(){
}

defineSeed(553, 1, {}, Collections$1_0);
_.compare = function compare_4(o1, o2){
  return o2.compareTo$(o1);
}
;
function Collections$3_0(val$cmp){
  this.val$cmp = val$cmp;
}

defineSeed(554, 1, {}, Collections$3_0);
_.compare = function compare_5(t1, t2){
  return $compare(t2, t1);
}
;
_.val$cmp = null;
function Collections$EmptyList_0(){
}

defineSeed(555, 20, makeCastMap([Q$Serializable, Q$List]), Collections$EmptyList_0);
_.contains_0 = function contains_7(object){
  return false;
}
;
_.get = function get_14(location_0){
  throw new IndexOutOfBoundsException_0;
}
;
_.size_0 = function size_10(){
  return 0;
}
;
function Collections$EmptySet_0(){
}

defineSeed(556, 202, makeCastMap([Q$Serializable, Q$Set]), Collections$EmptySet_0);
_.contains_0 = function contains_8(object){
  return false;
}
;
_.iterator_0 = function iterator_8(){
  return new Collections$EmptySet$1_0;
}
;
_.size_0 = function size_11(){
  return 0;
}
;
function Collections$EmptySet$1_0(){
}

defineSeed(557, 1, {}, Collections$EmptySet$1_0);
_.hasNext = function hasNext_5(){
  return false;
}
;
_.next_0 = function next_6(){
  throw new NoSuchElementException_0;
}
;
_.remove_2 = function remove_19(){
  throw new UnsupportedOperationException_0;
}
;
function $clinit_Comparators(){
  $clinit_Comparators = nullMethod;
  NATURAL = new Comparators$1_0;
}

var NATURAL;
function Comparators$1_0(){
}

defineSeed(559, 1, {}, Comparators$1_0);
_.compare = function compare_6(o1, o2){
  return o1.compareTo$(o2);
}
;
function Date_1(){
  this.jsdate = new Date;
}

function padTwo(number){
  return number < 10?'0' + number:'' + number;
}

defineSeed(560, 1, makeCastMap([Q$Serializable, Q$Comparable, Q$Date]), Date_1);
_.compareTo$ = function compareTo_11(other){
  return signum(sub(fromDouble(this.jsdate.getTime()), fromDouble(other.jsdate.getTime())));
}
;
_.equals$ = function equals_23(obj){
  return instanceOf(obj, Q$Date) && eq(fromDouble(this.jsdate.getTime()), fromDouble(obj.jsdate.getTime()));
}
;
_.hashCode$ = function hashCode_23(){
  var time;
  time = fromDouble(this.jsdate.getTime());
  return toInt(xor(time, shru(time, 32)));
}
;
_.toString$ = function toString_33(){
  var hourOffset, minuteOffset, offset;
  offset = -this.jsdate.getTimezoneOffset();
  hourOffset = (offset >= 0?'+':'') + ~~(offset / 60);
  minuteOffset = (offset < 0?-offset:offset) % 60 < 10?'0' + (offset < 0?-offset:offset) % 60:'' + (offset < 0?-offset:offset) % 60;
  return ($clinit_Date$StringData() , DAYS)[this.jsdate.getDay()] + ' ' + MONTHS[this.jsdate.getMonth()] + ' ' + padTwo(this.jsdate.getDate()) + ' ' + padTwo(this.jsdate.getHours()) + ':' + padTwo(this.jsdate.getMinutes()) + ':' + padTwo(this.jsdate.getSeconds()) + ' GMT' + hourOffset + minuteOffset + ' ' + this.jsdate.getFullYear();
}
;
_.jsdate = null;
function $clinit_Date$StringData(){
  $clinit_Date$StringData = nullMethod;
  DAYS = initValues(_3Ljava_lang_String_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$String, ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat']);
  MONTHS = initValues(_3Ljava_lang_String_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$String, ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']);
}

var DAYS, MONTHS;
function $containsKey_0(this$static, key){
  return $contains_1(this$static.keySet, key);
}

function $get_8(this$static, k){
  return $contains_1(this$static.keySet, k)?this$static.values[k.ordinal]:null;
}

function $put_4(this$static, key, value){
  $add_10(this$static.keySet, key);
  return $set_3(this$static, key.ordinal, value);
}

function $remove_11(this$static, key){
  return $remove_12(this$static.keySet, key)?$set_3(this$static, key.ordinal, null):null;
}

function $set_3(this$static, ordinal, value){
  var was;
  was = this$static.values[ordinal];
  setCheck(this$static.values, ordinal, value);
  return was;
}

function EnumMap_0(type){
  this.keySet = noneOf(type);
  this.values = initDim(_3Ljava_lang_Object_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Object, this.keySet.all.length, 0);
}

defineSeed(562, 198, makeCastMap([Q$Map]), EnumMap_0);
_.containsKey = function containsKey_3(key){
  return $contains_1(this.keySet, key);
}
;
_.containsValue = function containsValue_2(value){
  var key, key$iterator;
  for (key$iterator = new EnumSet$EnumSetImpl$IteratorImpl_0(this.keySet); key$iterator.i < key$iterator.this$1.all.length;) {
    key = $next_5(key$iterator);
    if (equalsWithNullCheck(value, this.values[key.ordinal])) {
      return true;
    }
  }
  return false;
}
;
_.entrySet_0 = function entrySet_3(){
  return new EnumMap$EntrySet_0(this);
}
;
_.get_1 = function get_15(k){
  return $get_8(this, k);
}
;
_.put = function put_3(key, value){
  return $put_4(this, key, value);
}
;
_.remove_1 = function remove_20(key){
  return $remove_11(this, key);
}
;
_.size_0 = function size_12(){
  return this.keySet.size;
}
;
_.keySet = null;
_.values = null;
function $contains_0(this$static, o){
  var entry, key, value;
  if (instanceOf(o, Q$Map$Entry)) {
    entry = o;
    key = entry.getKey();
    if ($containsKey_0(this$static.this$0, key)) {
      value = $get_8(this$static.this$0, key);
      return equalsWithNullCheck(entry.getValue(), value);
    }
  }
  return false;
}

function EnumMap$EntrySet_0(this$0){
  this.this$0 = this$0;
}

defineSeed(563, 202, makeCastMap([Q$Set]), EnumMap$EntrySet_0);
_.contains_0 = function contains_9(o){
  return $contains_0(this, o);
}
;
_.iterator_0 = function iterator_9(){
  return new EnumMap$EntrySetIterator_0(this.this$0);
}
;
_.remove = function remove_21(entry){
  var key;
  if ($contains_0(this, entry)) {
    key = entry.getKey();
    $remove_11(this.this$0, key);
    return true;
  }
  return false;
}
;
_.size_0 = function size_13(){
  return this.this$0.keySet.size;
}
;
_.this$0 = null;
function EnumMap$EntrySetIterator_0(this$0){
  this.this$0 = this$0;
  this.it = new EnumSet$EnumSetImpl$IteratorImpl_0(this.this$0.keySet);
}

defineSeed(564, 1, {}, EnumMap$EntrySetIterator_0);
_.hasNext = function hasNext_6(){
  return $hasNext_1(this.it);
}
;
_.next_0 = function next_7(){
  return this.key_0 = $next_5(this.it) , new EnumMap$MapEntry_0(this.this$0, this.key_0);
}
;
_.remove_2 = function remove_22(){
  if (!this.key_0) {
    throw new IllegalStateException_0;
  }
  $remove_11(this.this$0, this.key_0);
  this.key_0 = null;
}
;
_.key_0 = null;
_.this$0 = null;
function EnumMap$MapEntry_0(this$0, key){
  this.this$0 = this$0;
  this.key_0 = key;
}

defineSeed(565, 541, makeCastMap([Q$Map$Entry]), EnumMap$MapEntry_0);
_.getKey = function getKey_2(){
  return this.key_0;
}
;
_.getValue = function getValue_7(){
  return this.this$0.values[this.key_0.ordinal];
}
;
_.setValue = function setValue_2(value){
  var old;
  old = this.this$0.values[this.key_0.ordinal];
  setCheck(this.this$0.values, this.key_0.ordinal, value);
  return old;
}
;
_.key_0 = null;
_.this$0 = null;
function noneOf(elementType){
  var all;
  all = elementType.enumConstantsFunc && elementType.enumConstantsFunc();
  return new EnumSet$EnumSetImpl_0(all, createFrom(all, all.length));
}

defineSeed(566, 202, makeCastMap([Q$Set]));
function $add_10(this$static, e){
  var ordinal;
  if (!e) {
    throw new NullPointerException_0;
  }
  ordinal = e.ordinal;
  if (!this$static.set_0[ordinal]) {
    setCheck(this$static.set_0, ordinal, e);
    ++this$static.size;
    return true;
  }
  return false;
}

function $contains_1(this$static, o){
  var e;
  if (instanceOf(o, Q$Enum)) {
    e = o;
    return this$static.set_0[e.ordinal] == e;
  }
  return false;
}

function $remove_12(this$static, o){
  var e;
  if (instanceOf(o, Q$Enum)) {
    e = o;
    if (this$static.set_0[e.ordinal] == e) {
      setCheck(this$static.set_0, e.ordinal, null);
      --this$static.size;
      return true;
    }
  }
  return false;
}

function EnumSet$EnumSetImpl_0(all, set){
  this.all = all;
  this.set_0 = set;
  this.size = 0;
}

defineSeed(567, 566, makeCastMap([Q$Set]), EnumSet$EnumSetImpl_0);
_.add = function add_6(e){
  return $add_10(this, e);
}
;
_.contains_0 = function contains_10(o){
  return $contains_1(this, o);
}
;
_.iterator_0 = function iterator_10(){
  return new EnumSet$EnumSetImpl$IteratorImpl_0(this);
}
;
_.remove = function remove_23(o){
  return $remove_12(this, o);
}
;
_.size_0 = function size_14(){
  return this.size;
}
;
_.all = null;
_.set_0 = null;
_.size = 0;
function $findNext(this$static){
  var c;
  ++this$static.i;
  for (c = this$static.this$1.all.length; this$static.i < c; ++this$static.i) {
    if (this$static.this$1.set_0[this$static.i]) {
      return;
    }
  }
}

function $hasNext_1(this$static){
  return this$static.i < this$static.this$1.all.length;
}

function $next_5(this$static){
  if (this$static.i >= this$static.this$1.all.length) {
    throw new NoSuchElementException_0;
  }
  this$static.last = this$static.i;
  $findNext(this$static);
  return this$static.this$1.set_0[this$static.last];
}

function EnumSet$EnumSetImpl$IteratorImpl_0(this$1){
  this.this$1 = this$1;
  $findNext(this);
}

defineSeed(568, 1, {}, EnumSet$EnumSetImpl$IteratorImpl_0);
_.hasNext = function hasNext_7(){
  return $hasNext_1(this);
}
;
_.next_0 = function next_8(){
  return $next_5(this);
}
;
_.remove_2 = function remove_24(){
  if (this.last < 0) {
    throw new IllegalStateException_0;
  }
  setCheck(this.this$1.set_0, this.last, null);
  --this.this$1.size;
  this.last = -1;
}
;
_.i = -1;
_.last = -1;
_.this$1 = null;
function HashMap_0(){
  $clearImpl(this);
}

defineSeed(569, 537, makeCastMap([Q$Serializable, Q$Map]), HashMap_0);
_.equals = function equals_24(value1, value2){
  return maskUndefined(value1) === maskUndefined(value2) || value1 != null && equals__devirtual$(value1, value2);
}
;
_.getHashCode = function getHashCode_1(key){
  return ~~hashCode__devirtual$(key);
}
;
function $add_11(this$static, o){
  var old;
  old = this$static.map.put(o, this$static);
  return old == null;
}

function $contains_2(this$static, o){
  return this$static.map.containsKey(o);
}

function $remove_13(this$static, o){
  return this$static.map.remove_1(o) != null;
}

function HashSet_0(){
  this.map = new HashMap_0;
}

defineSeed(570, 202, makeCastMap([Q$Serializable, Q$Set]), HashSet_0);
_.add = function add_7(o){
  return $add_11(this, o);
}
;
_.contains_0 = function contains_11(o){
  return this.map.containsKey(o);
}
;
_.isEmpty = function isEmpty_2(){
  return this.map.size_0() == 0;
}
;
_.iterator_0 = function iterator_11(){
  return $iterator($keySet(this.map));
}
;
_.remove = function remove_25(o){
  return $remove_13(this, o);
}
;
_.size_0 = function size_15(){
  return this.map.size_0();
}
;
_.toString$ = function toString_34(){
  return $toString($keySet(this.map));
}
;
_.map = null;
function $$init_4(this$static){
  this$static.head = new LinkedHashMap$ChainEntry_0(this$static);
  this$static.map = new HashMap_0;
  this$static.head.prev = this$static.head;
  this$static.head.next = this$static.head;
}

function $containsKey_1(this$static, key){
  return this$static.map.containsKey(key);
}

function $get_9(this$static, key){
  var entry;
  entry = this$static.map.get_1(key);
  if (entry) {
    $recordAccess(this$static, entry);
    return entry.value_0;
  }
  return null;
}

function $put_5(this$static, key, value){
  var newEntry, old, oldValue;
  old = this$static.map.get_1(key);
  if (!old) {
    newEntry = new LinkedHashMap$ChainEntry_1(this$static, key, value);
    this$static.map.put(key, newEntry);
    $addToEnd(newEntry);
    return null;
  }
   else {
    oldValue = old.value_0;
    $setValue_0(old, value);
    $recordAccess(this$static, old);
    return oldValue;
  }
}

function $recordAccess(this$static, entry){
  if (this$static.accessOrder) {
    $remove_14(entry);
    $addToEnd(entry);
  }
}

function LinkedHashMap_0(){
  $clearImpl(this);
  $$init_4(this);
}

function LinkedHashMap_1(){
  $clearImpl(this);
  $$init_4(this);
}

defineSeed(571, 569, makeCastMap([Q$Serializable, Q$Map]), LinkedHashMap_0, LinkedHashMap_1);
_.clear_0 = function clear_0(){
  this.map.clear_0();
  this.head.prev = this.head;
  this.head.next = this.head;
}
;
_.containsKey = function containsKey_4(key){
  return this.map.containsKey(key);
}
;
_.containsValue = function containsValue_3(value){
  var node;
  node = this.head.next;
  while (node != this.head) {
    if (equalsWithNullCheck(node.value_0, value)) {
      return true;
    }
    node = node.next;
  }
  return false;
}
;
_.entrySet_0 = function entrySet_4(){
  return new LinkedHashMap$EntrySet_0(this);
}
;
_.get_1 = function get_16(key){
  return $get_9(this, key);
}
;
_.put = function put_4(key, value){
  return $put_5(this, key, value);
}
;
_.remove_1 = function remove_26(key){
  var entry;
  entry = this.map.remove_1(key);
  if (entry) {
    $remove_14(entry);
    return entry.value_0;
  }
  return null;
}
;
_.size_0 = function size_16(){
  return this.map.size_0();
}
;
_.accessOrder = false;
function $setValue_0(this$static, value){
  var old;
  old = this$static.value_0;
  this$static.value_0 = value;
  return old;
}

function MapEntryImpl_0(key, value){
  this.key_0 = key;
  this.value_0 = value;
}

defineSeed(573, 541, makeCastMap([Q$Map$Entry]), MapEntryImpl_0);
_.getKey = function getKey_3(){
  return this.key_0;
}
;
_.getValue = function getValue_8(){
  return this.value_0;
}
;
_.setValue = function setValue_3(value){
  return $setValue_0(this, value);
}
;
_.key_0 = null;
_.value_0 = null;
function $addToEnd(this$static){
  var tail;
  tail = this$static.this$0.head.prev;
  this$static.prev = tail;
  this$static.next = this$static.this$0.head;
  tail.next = this$static.this$0.head.prev = this$static;
}

function $remove_14(this$static){
  this$static.next.prev = this$static.prev;
  this$static.prev.next = this$static.next;
  this$static.next = this$static.prev = null;
}

function LinkedHashMap$ChainEntry_0(this$0){
  LinkedHashMap$ChainEntry_1.call(this, this$0, null, null);
}

function LinkedHashMap$ChainEntry_1(this$0, key, value){
  this.this$0 = this$0;
  MapEntryImpl_0.call(this, key, value);
  this.next = this.prev = null;
}

defineSeed(572, 573, makeCastMap([Q$Map$Entry]), LinkedHashMap$ChainEntry_0, LinkedHashMap$ChainEntry_1);
_.next = null;
_.prev = null;
_.this$0 = null;
function LinkedHashMap$EntrySet_0(this$0){
  this.this$0 = this$0;
}

defineSeed(574, 202, makeCastMap([Q$Set]), LinkedHashMap$EntrySet_0);
_.contains_0 = function contains_12(o){
  var entry, key, value;
  if (!instanceOf(o, Q$Map$Entry)) {
    return false;
  }
  entry = o;
  key = entry.getKey();
  if ($containsKey_1(this.this$0, key)) {
    value = $get_9(this.this$0, key);
    return equalsWithNullCheck(entry.getValue(), value);
  }
  return false;
}
;
_.iterator_0 = function iterator_12(){
  return new LinkedHashMap$EntrySet$EntryIterator_0(this);
}
;
_.size_0 = function size_17(){
  return this.this$0.map.size_0();
}
;
_.this$0 = null;
function $next_6(this$static){
  if (this$static.next == this$static.this$1.this$0.head) {
    throw new NoSuchElementException_0;
  }
  this$static.last = this$static.next;
  this$static.next = this$static.next.next;
  return this$static.last;
}

function LinkedHashMap$EntrySet$EntryIterator_0(this$1){
  this.this$1 = this$1;
  this.next = this$1.this$0.head.next;
}

defineSeed(575, 1, {}, LinkedHashMap$EntrySet$EntryIterator_0);
_.hasNext = function hasNext_8(){
  return this.next != this.this$1.this$0.head;
}
;
_.next_0 = function next_9(){
  return $next_6(this);
}
;
_.remove_2 = function remove_27(){
  if (!this.last) {
    throw new IllegalStateException_1('No current entry');
  }
  $remove_14(this.last);
  this.this$1.this$0.map.remove_1(this.last.key_0);
  this.last = null;
}
;
_.last = null;
_.next = null;
_.this$1 = null;
function $add_12(this$static, o){
  new LinkedList$Node_1(o, this$static.header);
  ++this$static.size;
  return true;
}

function $addBefore(this$static, o, target){
  new LinkedList$Node_1(o, target);
  ++this$static.size;
}

function $listIterator(this$static, index){
  var i, node;
  (index < 0 || index > this$static.size) && indexOutOfBounds(index, this$static.size);
  if (index >= ~~this$static.size >> 1) {
    node = this$static.header;
    for (i = this$static.size; i > index; --i) {
      node = node.prev;
    }
  }
   else {
    node = this$static.header.next;
    for (i = 0; i < index; ++i) {
      node = node.next;
    }
  }
  return new LinkedList$ListIteratorImpl_0(this$static, index, node);
}

function $poll_1(this$static){
  var node;
  return this$static.size == 0?null:($throwEmptyException(this$static) , --this$static.size , node = this$static.header.next , $remove_16(node) , node.value_0);
}

function $throwEmptyException(this$static){
  if (this$static.size == 0) {
    throw new NoSuchElementException_0;
  }
}

function LinkedList_0(){
  this.header = new LinkedList$Node_0;
  this.size = 0;
}

defineSeed(576, 549, makeCastMap([Q$Serializable, Q$List]), LinkedList_0);
_.add = function add_8(o){
  return $add_12(this, o);
}
;
_.listIterator_0 = function listIterator_1(index){
  return $listIterator(this, index);
}
;
_.size_0 = function size_18(){
  return this.size;
}
;
_.header = null;
_.size = 0;
function $next_7(this$static){
  if (this$static.currentNode == this$static.this$0.header) {
    throw new NoSuchElementException_0;
  }
  this$static.lastNode = this$static.currentNode;
  this$static.currentNode = this$static.currentNode.next;
  ++this$static.currentIndex;
  return this$static.lastNode.value_0;
}

function $remove_15(this$static){
  $verifyCurrentElement(this$static);
  this$static.currentNode == this$static.lastNode?(this$static.currentNode = this$static.lastNode.next):--this$static.currentIndex;
  $remove_16(this$static.lastNode);
  this$static.lastNode = null;
  --this$static.this$0.size;
}

function $verifyCurrentElement(this$static){
  if (!this$static.lastNode) {
    throw new IllegalStateException_0;
  }
}

function LinkedList$ListIteratorImpl_0(this$0, index, startNode){
  this.this$0 = this$0;
  this.currentNode = startNode;
  this.currentIndex = index;
}

defineSeed(577, 1, {}, LinkedList$ListIteratorImpl_0);
_.hasNext = function hasNext_9(){
  return this.currentNode != this.this$0.header;
}
;
_.hasPrevious = function hasPrevious_0(){
  return this.currentNode.prev != this.this$0.header;
}
;
_.next_0 = function next_10(){
  return $next_7(this);
}
;
_.previous_0 = function previous_1(){
  if (this.currentNode.prev == this.this$0.header) {
    throw new NoSuchElementException_0;
  }
  this.lastNode = this.currentNode = this.currentNode.prev;
  --this.currentIndex;
  return this.lastNode.value_0;
}
;
_.remove_2 = function remove_28(){
  $remove_15(this);
}
;
_.currentIndex = 0;
_.currentNode = null;
_.lastNode = null;
_.this$0 = null;
function $remove_16(this$static){
  this$static.next.prev = this$static.prev;
  this$static.prev.next = this$static.next;
  this$static.next = this$static.prev = this$static;
}

function LinkedList$Node_0(){
  this.next = this.prev = this;
}

function LinkedList$Node_1(value, nextNode){
  this.value_0 = value;
  this.next = nextNode;
  this.prev = nextNode.prev;
  nextNode.prev.next = this;
  nextNode.prev = this;
}

defineSeed(578, 1, {}, LinkedList$Node_0, LinkedList$Node_1);
_.next = null;
_.prev = null;
_.value_0 = null;
function NoSuchElementException_0(){
  RuntimeException_0.call(this);
}

defineSeed(579, 77, makeCastMap([Q$Serializable, Q$Exception, Q$RuntimeException, Q$Throwable, Q$NoSuchElementException]), NoSuchElementException_0);
function $clinit_Random(){
  $clinit_Random = nullMethod;
  var i, twoToTheXMinus24Tmp, twoToTheXMinus48Tmp;
  twoToTheXMinus24 = initDim(_3D_classLit, makeCastMap([Q$Serializable]), -1, 25, 1);
  twoToTheXMinus48 = initDim(_3D_classLit, makeCastMap([Q$Serializable]), -1, 33, 1);
  twoToTheXMinus48Tmp = 1.52587890625E-5;
  for (i = 32; i >= 0; --i) {
    twoToTheXMinus48[i] = twoToTheXMinus48Tmp;
    twoToTheXMinus48Tmp *= 0.5;
  }
  twoToTheXMinus24Tmp = 1;
  for (i = 24; i >= 0; --i) {
    twoToTheXMinus24[i] = twoToTheXMinus24Tmp;
    twoToTheXMinus24Tmp *= 0.5;
  }
}

function $nextInt(this$static, n){
  var bits, val;
  if (n > 0) {
    if ((n & -n) == n) {
      return round_int(n * $nextInternal(this$static, 31) * 4.6566128730773926E-10);
    }
    do {
      bits = $nextInternal(this$static, 31);
      val = bits % n;
    }
     while (bits - val + (n - 1) < 0);
    return round_int(val);
  }
  throw new IllegalArgumentException_0;
}

function $nextInternal(this$static, bits){
  var carry, dval, h_0, hi, l_0, lo;
  hi = this$static.seedhi * 15525485 + this$static.seedlo * 1502;
  lo = this$static.seedlo * 15525485 + 11;
  carry = Math.floor(lo * 5.9604644775390625E-8);
  hi += carry;
  lo -= carry * 16777216;
  hi %= 16777216;
  this$static.seedhi = hi;
  this$static.seedlo = lo;
  if (bits <= 24) {
    return floor(this$static.seedhi * twoToTheXMinus24[bits]);
  }
   else {
    h_0 = this$static.seedhi * (1 << bits - 24);
    l_0 = floor(this$static.seedlo * twoToTheXMinus48[bits]);
    dval = h_0 + l_0;
    dval >= 2147483648 && (dval -= 4294967296);
    return dval;
  }
}

function Random_0(){
  $clinit_Random();
  var hi, lo, seed;
  seed = uniqueSeed++ + (new Date).getTime();
  hi = round_int(Math.floor(seed * 5.9604644775390625E-8)) & 16777215;
  lo = round_int(seed - hi * 16777216);
  this.seedhi = hi ^ 1502;
  this.seedlo = lo ^ 15525485;
}

defineSeed(580, 1, {}, Random_0);
_.seedhi = 0;
_.seedlo = 0;
var twoToTheXMinus24, twoToTheXMinus48, uniqueSeed = 0;
function $compare_1(a, b){
  if (a == null || b == null) {
    throw new NullPointerException_0;
  }
  return a.compareTo$(b);
}

function $compare_2(a, b){
  return $compare_1(a, b);
}

function TreeMap$1_0(){
}

defineSeed(581, 1, {}, TreeMap$1_0);
_.compare = function compare_7(a, b){
  return $compare_1(a, b);
}
;
function $inOrderAdd(this$static, list, type, current, fromKey, toKey){
  if (!current) {
    return;
  }
  !!current.child[0] && $inOrderAdd(this$static, list, type, current.child[0], fromKey, toKey);
  $inRange(this$static, type, current.key_0, fromKey, toKey) && list.add(current);
  !!current.child[1] && $inOrderAdd(this$static, list, type, current.child[1], fromKey, toKey);
}

function $inRange(this$static, type, key, fromKey, toKey){
  if (type.toKeyValid()) {
    if ($compare_1(key, toKey) >= 0) {
      return false;
    }
  }
  if (type.fromKeyValid()) {
    if ($compare_1(key, fromKey) < 0) {
      return false;
    }
  }
  return true;
}

function TreeMap$EntryIterator_0(this$0){
  TreeMap$EntryIterator_1.call(this, this$0, ($clinit_TreeMap$SubMapType() , All));
}

function TreeMap$EntryIterator_1(this$0, type){
  var list;
  this.this$0 = this$0;
  list = new ArrayList_0;
  $inOrderAdd(this, list, type, this$0.root, null, null);
  this.iter = new AbstractList$IteratorImpl_0(list);
}

defineSeed(582, 1, {}, TreeMap$EntryIterator_0);
_.hasNext = function hasNext_10(){
  return $hasNext_0(this.iter);
}
;
_.next_0 = function next_11(){
  return this.last = $next_2(this.iter);
}
;
_.remove_2 = function remove_29(){
  $remove_10(this.iter);
  $remove_8(this.this$0, this.last.getKey());
}
;
_.iter = null;
_.last = null;
_.this$0 = null;
function TreeMap$EntrySet_0(this$0){
  this.this$0 = this$0;
}

defineSeed(583, 202, makeCastMap([Q$Set]), TreeMap$EntrySet_0);
_.contains_0 = function contains_13(o){
  var entry, lookupEntry;
  if (!instanceOf(o, Q$Map$Entry)) {
    return false;
  }
  entry = o;
  lookupEntry = $getEntry(this.this$0, entry.getKey());
  return !!lookupEntry && equalsWithNullCheck(lookupEntry.value_0, entry.getValue());
}
;
_.iterator_0 = function iterator_13(){
  return new TreeMap$EntryIterator_0(this.this$0);
}
;
_.remove = function remove_30(o){
  var entry, state;
  if (!instanceOf(o, Q$Map$Entry)) {
    return false;
  }
  entry = o;
  state = new TreeMap$State_0;
  state.matchValue = true;
  state.value_0 = entry.getValue();
  return $removeWithState(this.this$0, entry.getKey(), state);
}
;
_.size_0 = function size_19(){
  return this.this$0.size;
}
;
_.this$0 = null;
function TreeMap$Node_0(key, value){
  this.key_0 = key;
  this.value_0 = value;
  this.child = initDim(_3Ljava_util_TreeMap$Node_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$TreeMap$Node, 2, 0);
  this.isRed = true;
}

defineSeed(584, 1, makeCastMap([Q$Map$Entry, Q$TreeMap$Node]), TreeMap$Node_0);
--></script>
<script><!--
_.equals$ = function equals_25(o){
  var other;
  if (!instanceOf(o, Q$Map$Entry)) {
    return false;
  }
  other = o;
  return equalsWithNullCheck(this.key_0, other.getKey()) && equalsWithNullCheck(this.value_0, other.getValue());
}
;
_.getKey = function getKey_4(){
  return this.key_0;
}
;
_.getValue = function getValue_9(){
  return this.value_0;
}
;
_.hashCode$ = function hashCode_24(){
  var keyHash, valueHash;
  keyHash = this.key_0 != null?hashCode__devirtual$(this.key_0):0;
  valueHash = this.value_0 != null?hashCode__devirtual$(this.value_0):0;
  return keyHash ^ valueHash;
}
;
_.setValue = function setValue_4(value){
  var old;
  old = this.value_0;
  this.value_0 = value;
  return old;
}
;
_.toString$ = function toString_35(){
  return this.key_0 + '=' + this.value_0;
}
;
_.child = null;
_.isRed = false;
_.key_0 = null;
_.value_0 = null;
function TreeMap$State_0(){
}

defineSeed(585, 1, {}, TreeMap$State_0);
_.toString$ = function toString_36(){
  return 'State: mv=' + this.matchValue + ' value=' + this.value_0 + ' done=' + this.done + ' found=' + this.found;
}
;
_.done = false;
_.found = false;
_.matchValue = false;
_.value_0 = null;
function $clinit_TreeMap$SubMapType(){
  $clinit_TreeMap$SubMapType = nullMethod;
  All = new TreeMap$SubMapType_0('All', 0);
  Head = new TreeMap$SubMapType$1_0;
  Range_0 = new TreeMap$SubMapType$2_0;
  Tail = new TreeMap$SubMapType$3_0;
  $VALUES_24 = initValues(_3Ljava_util_TreeMap$SubMapType_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$TreeMap$SubMapType, [All, Head, Range_0, Tail]);
}

function TreeMap$SubMapType_0(enum$name, enum$ordinal){
  Enum_0.call(this, enum$name, enum$ordinal);
}

function values_25(){
  $clinit_TreeMap$SubMapType();
  return $VALUES_24;
}

defineSeed(586, 11, makeCastMap([Q$Serializable, Q$Comparable, Q$Enum, Q$TreeMap$SubMapType]), TreeMap$SubMapType_0);
_.fromKeyValid = function fromKeyValid(){
  return false;
}
;
_.toKeyValid = function toKeyValid(){
  return false;
}
;
var $VALUES_24, All, Head, Range_0, Tail;
function TreeMap$SubMapType$1_0(){
  Enum_0.call(this, 'Head', 1);
}

defineSeed(587, 586, makeCastMap([Q$Serializable, Q$Comparable, Q$Enum, Q$TreeMap$SubMapType]), TreeMap$SubMapType$1_0);
_.toKeyValid = function toKeyValid_0(){
  return true;
}
;
function TreeMap$SubMapType$2_0(){
  Enum_0.call(this, 'Range', 2);
}

defineSeed(588, 586, makeCastMap([Q$Serializable, Q$Comparable, Q$Enum, Q$TreeMap$SubMapType]), TreeMap$SubMapType$2_0);
_.fromKeyValid = function fromKeyValid_0(){
  return true;
}
;
_.toKeyValid = function toKeyValid_1(){
  return true;
}
;
function TreeMap$SubMapType$3_0(){
  Enum_0.call(this, 'Tail', 3);
}

defineSeed(589, 586, makeCastMap([Q$Serializable, Q$Comparable, Q$Enum, Q$TreeMap$SubMapType]), TreeMap$SubMapType$3_0);
_.fromKeyValid = function fromKeyValid_1(){
  return true;
}
;
function $add_13(this$static, o){
  return $put_0(this$static.map, o, ($clinit_Boolean() , FALSE)) == null;
}

function $contains_3(this$static, o){
  return !!$getEntry(this$static.map, o);
}

function TreeSet_0(){
  this.map = new TreeMap_0;
}

defineSeed(590, 202, makeCastMap([Q$Serializable, Q$Set]), TreeSet_0);
_.add = function add_9(o){
  return $add_13(this, o);
}
;
_.contains_0 = function contains_14(o){
  return $contains_3(this, o);
}
;
_.iterator_0 = function iterator_14(){
  return $iterator($keySet(this.map));
}
;
_.remove = function remove_31(o){
  return $remove_8(this.map, o) != null;
}
;
_.size_0 = function size_20(){
  return this.map.size;
}
;
_.map = null;
function equalsWithNullCheck(a, b){
  return maskUndefined(a) === maskUndefined(b) || a != null && equals__devirtual$(a, b);
}

function abs_0(a){
  return new Vector2f_1(abs(a.x), abs(a.y));
}

function add_10(A, B){
  var temp1, temp2;
  temp1 = new Vector2f_2(A.col1);
  $add_14(temp1, B.col1);
  temp2 = new Vector2f_2(A.col2);
  $add_14(temp2, B.col2);
  return new Matrix2f_2(temp1, temp2);
}

function cross(s, a){
  return new Vector2f_1(-s * a.y, s * a.x);
}

function cross_0(a, s){
  return new Vector2f_1(s * a.y, -s * a.x);
}

function cross_1(a, b){
  return a.x * b.y - a.y * b.x;
}

function getNormal(x, y){
  var normal;
  normal = new Vector2f_2(y);
  normal.x -= x.x;
  normal.y -= x.y;
  normal = new Vector2f_1(normal.y, -normal.x);
  $normalise(normal);
  return normal;
}

function mul_0(A, v){
  return new Vector2f_1(A.col1.x * v.x + A.col2.x * v.y, A.col1.y * v.x + A.col2.y * v.y);
}

function scale_0(a, scale){
  var temp;
  temp = new Vector2f_2(a);
  temp.x *= scale;
  temp.y *= scale;
  return temp;
}

function scale_1(a, scale, temp){
  $set_4(temp, a.x, a.y);
  temp.x *= scale;
  temp.y *= scale;
  return temp;
}

function scaleInSitu(a, scale){
  a.x *= scale;
  a.y *= scale;
  return a;
}

function sub_0(a, b){
  var temp;
  temp = new Vector2f_2(a);
  temp.x -= b.x;
  temp.y -= b.y;
  return temp;
}

function $$init_5(this$static){
  this$static.col1 = new Vector2f_0;
  this$static.col2 = new Vector2f_0;
}

function $invert(this$static){
  var B, a, b, c, d, det;
  a = this$static.col1.x;
  b = this$static.col2.x;
  c = this$static.col1.y;
  d = this$static.col2.y;
  B = new Matrix2f_0;
  det = a * d - b * c;
  if (det == 0) {
    throw new RuntimeException_1('Matrix2f: invert() - determinate is zero!');
  }
  det = 1 / det;
  B.col1.x = det * d;
  B.col2.x = -det * b;
  B.col1.y = -det * c;
  B.col2.y = det * a;
  return B;
}

function Matrix2f_0(){
  $$init_5(this);
}

function Matrix2f_1(angle){
  var c, s;
  $$init_5(this);
  c = Math.cos(angle);
  s = Math.sin(angle);
  this.col1.x = c;
  this.col2.x = -s;
  this.col1.y = s;
  this.col2.y = c;
}

function Matrix2f_2(col1, col2){
  $$init_5(this);
  $set_5(this.col1, col1);
  $set_5(this.col2, col2);
}

defineSeed(593, 1, {}, Matrix2f_0, Matrix2f_1, Matrix2f_2);
function $add_14(this$static, v){
  this$static.x += v.x;
  this$static.y += v.y;
}

function $distanceSquared(this$static, other){
  var dx, dy;
  dx = other.x - this$static.x;
  dy = other.y - this$static.y;
  return dx * dx + dy * dy;
}

function $dot(this$static, other){
  return this$static.x * other.x + this$static.y * other.y;
}

function $equalsDelta(this$static, other){
  return other.x - 0.5 < this$static.x && other.x + 0.5 > this$static.x && other.y - 0.5 < this$static.y && other.y + 0.5 > this$static.y;
}

function $length(this$static){
  return sqrt(this$static.x * this$static.x + this$static.y * this$static.y);
}

function $lengthSquared(this$static){
  return this$static.x * this$static.x + this$static.y * this$static.y;
}

function $normalise(this$static){
  var l_0;
  l_0 = sqrt(this$static.x * this$static.x + this$static.y * this$static.y);
  if (l_0 == 0)
    return;
  this$static.x /= l_0;
  this$static.y /= l_0;
}

function $projectOntoUnit(this$static, b, result){
  var dp;
  dp = b.x * this$static.x + b.y * this$static.y;
  result.x = dp * b.x;
  result.y = dp * b.y;
}

function $scale_0(this$static, a){
  this$static.x *= a;
  this$static.y *= a;
}

function $set_4(this$static, x, y){
  this$static.x = x;
  this$static.y = y;
}

function $set_5(this$static, other){
  $set_4(this$static, other.x, other.y);
}

function $sub(this$static, v){
  this$static.x -= v.x;
  this$static.y -= v.y;
}

function Vector2f_0(){
}

function Vector2f_1(x, y){
  this.x = x;
  this.y = y;
}

function Vector2f_2(other){
  Vector2f_1.call(this, other.x, other.y);
}

defineSeed(594, 1, makeCastMap([Q$ROVector2f, Q$Vector2f]), Vector2f_0, Vector2f_1, Vector2f_2);
_.toString$ = function toString_37(){
  return '[Vec ' + this.x + ',' + this.y + ' (' + sqrt(this.x * this.x + this.y * this.y) + ')]';
}
;
_.x = 0;
_.y = 0;
function $applyImpulse(this$static){
  var Pb, b1, b2, biasImpulse, c, i, impulse, maxTangentImpulse, normalImpulse, oldBiasImpulse, oldNormalImpulse, oldTangentImpulse, r1, r2, relativeVelocity, tangent, tangentImpulse, temp, vn, vnb, vt;
  b1 = this$static.body1;
  b2 = this$static.body2;
  for (i = 0; i < this$static.numContacts; ++i) {
    c = this$static.contacts[i];
    r1 = new Vector2f_2(c.position_0);
    $sub(r1, b1.position_0);
    r2 = new Vector2f_2(c.position_0);
    $sub(r2, b2.position_0);
    relativeVelocity = new Vector2f_2(b2.velocity);
    $add_14(relativeVelocity, cross(b2.angularVelocity, r2));
    $sub(relativeVelocity, b1.velocity);
    $sub(relativeVelocity, cross(b1.angularVelocity, r1));
    vn = $dot(relativeVelocity, c.normal);
    normalImpulse = c.massNormal * (c.restitution - vn);
    oldNormalImpulse = c.accumulatedNormalImpulse;
    c.accumulatedNormalImpulse = oldNormalImpulse + normalImpulse > 0?oldNormalImpulse + normalImpulse:0;
    normalImpulse = c.accumulatedNormalImpulse - oldNormalImpulse;
    impulse = scale_0(c.normal, normalImpulse);
    temp = new Vector2f_0;
    $adjustVelocity(b1, scale_1(impulse, -b1.invMass, temp));
    $adjustAngularVelocity(b1, -(b1.invI * (r1.x * impulse.y - r1.y * impulse.x)));
    $adjustVelocity(b2, scale_1(impulse, b2.invMass, temp));
    $adjustAngularVelocity(b2, b2.invI * (r2.x * impulse.y - r2.y * impulse.x));
    c.accumulatedNormalImpulse / b1.mass < 5 && c.accumulatedNormalImpulse / b2.mass < 5 && (c.restitution = 0);
    $set_5(relativeVelocity, b2.biasedVelocity);
    $add_14(relativeVelocity, cross(b2.biasedAngularVelocity, r2));
    $sub(relativeVelocity, b1.biasedVelocity);
    $sub(relativeVelocity, cross(b1.biasedAngularVelocity, r1));
    vnb = $dot(relativeVelocity, c.normal);
    biasImpulse = c.massNormal * (-vnb + c.bias);
    oldBiasImpulse = c.biasImpulse;
    c.biasImpulse = oldBiasImpulse + biasImpulse > 0?oldBiasImpulse + biasImpulse:0;
    biasImpulse = c.biasImpulse - oldBiasImpulse;
    Pb = scale_0(c.normal, biasImpulse);
    $adjustBiasedVelocity(b1, scale_1(Pb, -b1.invMass, temp));
    $adjustBiasedAngularVelocity(b1, -(b1.invI * (r1.x * Pb.y - r1.y * Pb.x)));
    $adjustBiasedVelocity(b2, scale_1(Pb, b2.invMass, temp));
    $adjustBiasedAngularVelocity(b2, b2.invI * (r2.x * Pb.y - r2.y * Pb.x));
    maxTangentImpulse = this$static.friction * c.accumulatedNormalImpulse;
    $set_5(relativeVelocity, b2.velocity);
    $add_14(relativeVelocity, cross(b2.angularVelocity, r2));
    $sub(relativeVelocity, b1.velocity);
    $sub(relativeVelocity, cross(b1.angularVelocity, r1));
    tangent = cross_0(c.normal, 1);
    vt = relativeVelocity.x * tangent.x + relativeVelocity.y * tangent.y;
    tangentImpulse = c.massTangent * -vt;
    oldTangentImpulse = c.accumulatedTangentImpulse;
    c.accumulatedTangentImpulse = -maxTangentImpulse > (oldTangentImpulse + tangentImpulse < maxTangentImpulse?oldTangentImpulse + tangentImpulse:maxTangentImpulse)?-maxTangentImpulse:oldTangentImpulse + tangentImpulse < maxTangentImpulse?oldTangentImpulse + tangentImpulse:maxTangentImpulse;
    tangentImpulse = c.accumulatedTangentImpulse - oldTangentImpulse;
    impulse = scale_0(tangent, tangentImpulse);
    $adjustVelocity(b1, scale_1(impulse, -b1.invMass, temp));
    $adjustAngularVelocity(b1, -b1.invI * (r1.x * impulse.y - r1.y * impulse.x));
    $adjustVelocity(b2, scale_1(impulse, b2.invMass, temp));
    $adjustAngularVelocity(b2, b2.invI * (r2.x * impulse.y - r2.y * impulse.x));
  }
}

function $concerns(this$static, body){
  var result;
  result = this$static.body1 == body || this$static.body2 == body;
  return result;
}

function $preStep(this$static){
  var c, i, impulse, kNormal, kTangent, penVel, r1, r2, relativeVelocity, rn1, rn2, rt1, rt2, tangent;
  for (i = 0; i < this$static.numContacts; ++i) {
    c = this$static.contacts[i];
    $normalise(c.normal);
    r1 = new Vector2f_2(c.position_0);
    $sub(r1, this$static.body1.position_0);
    r2 = new Vector2f_2(c.position_0);
    $sub(r2, this$static.body2.position_0);
    rn1 = $dot(r1, c.normal);
    rn2 = $dot(r2, c.normal);
    kNormal = this$static.body1.invMass + this$static.body2.invMass;
    kNormal += this$static.body1.invI * (r1.x * r1.x + r1.y * r1.y - rn1 * rn1) + this$static.body2.invI * (r2.x * r2.x + r2.y * r2.y - rn2 * rn2);
    c.massNormal = 1 / kNormal;
    tangent = cross_0(c.normal, 1);
    rt1 = r1.x * tangent.x + r1.y * tangent.y;
    rt2 = r2.x * tangent.x + r2.y * tangent.y;
    kTangent = this$static.body1.invMass + this$static.body2.invMass;
    kTangent += this$static.body1.invI * (r1.x * r1.x + r1.y * r1.y - rt1 * rt1) + this$static.body2.invI * (r2.x * r2.x + r2.y * r2.y - rt2 * rt2);
    c.massTangent = 1 / kTangent;
    relativeVelocity = new Vector2f_2(this$static.body2.velocity);
    $add_14(relativeVelocity, cross_0(r2, this$static.body2.angularVelocity));
    $sub(relativeVelocity, this$static.body1.velocity);
    $sub(relativeVelocity, cross_0(r1, this$static.body1.angularVelocity));
    $dot(c.normal, relativeVelocity);
    c.restitution = 0;
    c.restitution = max_0(c.restitution, 0);
    penVel = -c.separation / 0.01666666753590107;
    c.restitution >= penVel?(c.bias = 0):(c.bias = -47.999996185302734 * min(0, c.separation + 0.009999999776482582));
    c.accumulatedNormalImpulse *= 1;
    impulse = scale_0(c.normal, c.accumulatedNormalImpulse);
    $add_14(impulse, scale_0(tangent, c.accumulatedTangentImpulse));
    $adjustVelocity(this$static.body1, scale_0(impulse, -this$static.body1.invMass));
    $adjustAngularVelocity(this$static.body1, -this$static.body1.invI * (r1.x * impulse.y - r1.y * impulse.x));
    $adjustVelocity(this$static.body2, scale_0(impulse, this$static.body2.invMass));
    $adjustAngularVelocity(this$static.body2, this$static.body2.invI * (r2.x * impulse.y - r2.y * impulse.x));
    c.biasImpulse = 0;
  }
}

function $update_11(this$static, newContacts, numNewContacts){
  var c, cNew, cOld, i, j, k, mergedContacts;
  mergedContacts = initDim(_3Lnet_phys2d_raw_Contact_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Contact, 10, 0);
  for (i = 0; i < mergedContacts.length; ++i) {
    mergedContacts[i] = new Contact_0;
  }
  for (i = 0; i < numNewContacts; ++i) {
    cNew = newContacts[i];
    k = -1;
    for (j = 0; j < this$static.numContacts; ++j) {
      cOld = this$static.contacts[j];
      if ($equals_1(cNew.feature, cOld.feature)) {
        k = j;
        break;
      }
    }
    if (k > -1) {
      c = mergedContacts[i];
      cOld = this$static.contacts[k];
      $set_6(c, cNew);
      c.accumulatedNormalImpulse = cOld.accumulatedNormalImpulse;
      c.accumulatedTangentImpulse = cOld.accumulatedTangentImpulse;
    }
     else {
      $set_6(mergedContacts[i], newContacts[i]);
    }
  }
  for (i = 0; i < numNewContacts; ++i) {
    $set_6(this$static.contacts[i], mergedContacts[i]);
  }
  this$static.numContacts = numNewContacts;
}

function Arbiter_0(b1, b2){
  var i;
  this.contacts = initDim(_3Lnet_phys2d_raw_Contact_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Contact, 10, 0);
  for (i = 0; i < 10; ++i) {
    this.contacts[i] = new Contact_0;
  }
  if (!instanceOf(b2, Q$StaticBody) && b1.id_0 < b2.id_0) {
    this.body1 = b1;
    this.body2 = b2;
  }
   else {
    this.body1 = b2;
    this.body2 = b1;
  }
}

defineSeed(595, 1, {}, Arbiter_0);
_.equals$ = function equals_26(other){
  var o;
  if (getClass__devirtual$(other) == Lnet_phys2d_raw_Arbiter_2_classLit) {
    o = other;
    return $equals(o.body1, this.body1) && $equals(o.body2, this.body2);
  }
  return false;
}
;
_.hashCode$ = function hashCode_25(){
  return this.body1.id_0 + this.body2.id_0;
}
;
_.body1 = null;
_.body2 = null;
_.friction = 0;
_.numContacts = 0;
function $add_15(this$static, arbiter){
  $add_0(this$static.elements, arbiter);
}

function $contains_4(this$static, arb){
  return $indexOf_0(this$static.elements, arb, 0) != -1;
}

function $get_10(this$static, i){
  return $get(this$static.elements, i);
}

function $indexOf_4(this$static, arbiter){
  return $indexOf_0(this$static.elements, arbiter, 0);
}

function $remove_17(this$static, arbiter){
  if ($indexOf_0(this$static.elements, arbiter, 0) == -1) {
    return;
  }
  $set(this$static.elements, $indexOf_0(this$static.elements, arbiter, 0), $get(this$static.elements, this$static.elements.size - 1));
  $remove_0(this$static.elements, this$static.elements.size - 1);
}

function ArbiterList_0(){
  this.elements = new ArrayList_0;
}

defineSeed(596, 1, {}, ArbiterList_0);
function $applyImpulse_0(this$static){
  var delta2, dv, impulse;
  dv = new Vector2f_2(this$static.body2.velocity);
  $add_14(dv, cross(this$static.body2.angularVelocity, this$static.r2));
  $sub(dv, this$static.body1.velocity);
  $sub(dv, cross(this$static.body1.angularVelocity, this$static.r1));
  dv.x *= -1;
  dv.y *= -1;
  $add_14(dv, this$static.bias);
  if (dv.x * dv.x + dv.y * dv.y == 0) {
    return;
  }
  impulse = mul_0(this$static.M, dv);
  delta2 = new Vector2f_2(impulse);
  $scale_0(delta2, this$static.body2.invMass);
  $adjustVelocity(this$static.body2, delta2);
  $adjustAngularVelocity(this$static.body2, this$static.body2.invI * cross_1(this$static.r2, impulse));
  $add_14(this$static.accumulatedImpulse, impulse);
}

function BasicJoint_0(b1, b2, anchor){
  var rot1, rot2, rot1T, rot2T, a1, a2;
  this.M = new Matrix2f_0;
  this.localAnchor1 = new Vector2f_0;
  this.localAnchor2 = new Vector2f_0;
  this.r1 = new Vector2f_0;
  this.r2 = new Vector2f_0;
  this.bias = new Vector2f_0;
  this.accumulatedImpulse = new Vector2f_0;
  this.id_0 = NEXT_ID_0++;
  $set_4(this.accumulatedImpulse, 0, 0);
  this.relaxation = 1;
  this.body1 = b1;
  this.body2 = b2;
  rot1 = new Matrix2f_1(this.body1.rotation);
  rot2 = new Matrix2f_1(this.body2.rotation);
  rot1T = new Matrix2f_2(new Vector2f_1(rot1.col1.x, rot1.col2.x), new Vector2f_1(rot1.col1.y, rot1.col2.y));
  rot2T = new Matrix2f_2(new Vector2f_1(rot2.col1.x, rot2.col2.x), new Vector2f_1(rot2.col1.y, rot2.col2.y));
  a1 = new Vector2f_2(anchor);
  $sub(a1, this.body1.position_0);
  this.localAnchor1 = new Vector2f_1(rot1T.col1.x * a1.x + rot1T.col2.x * a1.y, rot1T.col1.y * a1.x + rot1T.col2.y * a1.y);
  a2 = new Vector2f_2(anchor);
  $sub(a2, this.body2.position_0);
  this.localAnchor2 = new Vector2f_1(rot2T.col1.x * a2.x + rot2T.col2.x * a2.y, rot2T.col1.y * a2.x + rot2T.col2.y * a2.y);
  $set_4(this.accumulatedImpulse, 0, 0);
  this.relaxation = 1;
}

defineSeed(597, 1, {}, BasicJoint_0);
_.equals$ = function equals_27(other){
  if (getClass__devirtual$(other) == Lnet_phys2d_raw_BasicJoint_2_classLit) {
    return other.id_0 == this.id_0;
  }
  return false;
}
;
_.hashCode$ = function hashCode_26(){
  return this.id_0;
}
;
_.body1 = null;
_.body2 = null;
_.id_0 = 0;
_.relaxation = 0;
var NEXT_ID_0 = 0;
function $add_16(this$static, body){
  $add_0(this$static.elements, body);
}

function $contains_5(this$static, body){
  return $indexOf_0(this$static.elements, body, 0) != -1;
}

function $get_11(this$static, i){
  return $get(this$static.elements, i);
}

function $remove_18(this$static, body){
  $remove_1(this$static.elements, body);
}

function BodyList_0(){
  this.elements = new ArrayList_0;
}

defineSeed(598, 1, {}, BodyList_0);
_.toString$ = function toString_38(){
  var i, str;
  str = '[BodyList ';
  for (i = 0; i < this.elements.size; ++i) {
    str += $get(this.elements, i) + ',';
  }
  str += ']';
  return str;
}
;
function collide(contacts, bodyA, bodyB){
  var $e0, collider, e;
  try {
    collider = $createCollider(bodyA, bodyB);
  }
   catch ($e0) {
    $e0 = caught_0($e0);
    if (instanceOf($e0, Q$ColliderUnavailableException)) {
      e = $e0;
      e.detailMessage + '\n Ignoring any possible collision between the bodies in question';
      return 0;
    }
     else 
      throw $e0;
  }
  return collider.collide(contacts, bodyA, bodyB);
}

function CollisionEvent_0(body1, body2, point, normal, depth){
  this.body1 = body1;
  this.body2 = body2;
  this.point = point;
  this.normal = normal;
  this.depth = depth;
}

defineSeed(600, 1, makeCastMap([Q$CollisionEvent]), CollisionEvent_0);
_.toString$ = function toString_39(){
  return '[Collision \r\n body A: ' + this.body1 + '\r\n body B: ' + this.body2 + '\r\n contact: ' + this.point + '\r\n normal: ' + this.normal + '\r\n penetration: ' + this.depth + '\r\n';
}
;
_.body1 = null;
_.body2 = null;
_.depth = 0;
_.normal = null;
_.point = null;
function $set_6(this$static, contact){
  $set_5(this$static.position_0, contact.position_0);
  $set_5(this$static.normal, contact.normal);
  this$static.separation = contact.separation;
  this$static.accumulatedNormalImpulse = contact.accumulatedNormalImpulse;
  this$static.accumulatedTangentImpulse = contact.accumulatedTangentImpulse;
  this$static.massNormal = contact.massNormal;
  this$static.massTangent = contact.massTangent;
  this$static.bias = contact.bias;
  this$static.restitution = contact.restitution;
  $set_7(this$static.feature, contact.feature);
}

function $setFeature(this$static, pair){
  this$static.feature = pair;
}

function $setNormal(this$static, normal){
  $set_5(this$static.normal, normal);
}

function $setPosition_1(this$static, position){
  $set_5(this$static.position_0, position);
}

function $setSeparation(this$static, separation){
  this$static.separation = separation;
}

function Contact_0(){
  this.position_0 = new Vector2f_0;
  this.normal = new Vector2f_0;
  this.feature = new FeaturePair_0;
  this.accumulatedNormalImpulse = 0;
  this.accumulatedTangentImpulse = 0;
}

defineSeed(601, 1, makeCastMap([Q$Contact]), Contact_0);
_.equals$ = function equals_28(other){
  if (getClass__devirtual$(other) == Lnet_phys2d_raw_Contact_2_classLit) {
    return $equals_1(other.feature, this.feature);
  }
  return false;
}
;
_.hashCode$ = function hashCode_27(){
  return $getKey(this.feature);
}
;
_.toString$ = function toString_40(){
  return '[Contact ' + this.position_0 + ' n: ' + this.normal + ' sep: ' + this.separation + ']';
}
;
_.accumulatedNormalImpulse = 0;
_.accumulatedTangentImpulse = 0;
_.bias = 0;
_.biasImpulse = 0;
_.massNormal = 0;
_.massTangent = 0;
_.restitution = 0;
_.separation = 0;
function $add_17(this$static, joint){
  $add_0(this$static.elements, joint);
}

function JointList_0(){
  this.elements = new ArrayList_0;
}

defineSeed(602, 1, {}, JointList_0);
function $clinit_BoxBoxCollider(){
  $clinit_BoxBoxCollider = nullMethod;
  hA = new Vector2f_0;
  hB = new Vector2f_0;
}

function $clipSegmentToLine(vOut, vIn, normal, offset, clipEdge){
  var distance0, distance1, interp, numOut;
  numOut = 0;
  distance0 = $dot(normal, vIn[0].v) - offset;
  distance1 = $dot(normal, vIn[1].v) - offset;
  distance0 <= 0 && (vOut[numOut++] = vIn[0]);
  distance1 <= 0 && (vOut[numOut++] = vIn[1]);
  if (distance0 * distance1 < 0) {
    interp = distance0 / (distance0 - distance1);
    vOut[numOut].v = scaleInSitu(sub_0(vIn[1].v, vIn[0].v), interp);
    $add_14(vOut[numOut].v, vIn[0].v);
    if (distance0 > 0) {
      vOut[numOut].fp = vIn[0].fp;
      vOut[numOut].fp.inEdge1 = clipEdge;
      vOut[numOut].fp.inEdge2 = 0;
    }
     else {
      vOut[numOut].fp = vIn[1].fp;
      vOut[numOut].fp.outEdge1 = clipEdge;
      vOut[numOut].fp.outEdge2 = 0;
    }
    ++numOut;
  }
  return numOut;
}

function $computeIncidentEdge(c, h_0, pos, rot, normal){
  var n, nAbs, rotT;
  rotT = new Matrix2f_2(new Vector2f_1(rot.col1.x, rot.col2.x), new Vector2f_1(rot.col1.y, rot.col2.y));
  n = scaleInSitu(new Vector2f_1(rotT.col1.x * normal.x + rotT.col2.x * normal.y, rotT.col1.y * normal.x + rotT.col2.y * normal.y), -1);
  nAbs = new Vector2f_1(abs(n.x), abs(n.y));
  if (nAbs.x > nAbs.y) {
    if ((n.x < 0?-1:1) > 0) {
      $set_4(c[0].v, h_0.x, -h_0.y);
      c[0].fp.inEdge2 = 3;
      c[0].fp.outEdge2 = 4;
      $set_4(c[1].v, h_0.x, h_0.y);
      c[1].fp.inEdge2 = 4;
      c[1].fp.outEdge2 = 1;
    }
     else {
      $set_4(c[0].v, -h_0.x, h_0.y);
      c[0].fp.inEdge2 = 1;
      c[0].fp.outEdge2 = 2;
      $set_4(c[1].v, -h_0.x, -h_0.y);
      c[1].fp.inEdge2 = 2;
      c[1].fp.outEdge2 = 3;
    }
  }
   else {
    if ((n.y < 0?-1:1) > 0) {
      $set_4(c[0].v, h_0.x, h_0.y);
      c[0].fp.inEdge2 = 4;
      c[0].fp.outEdge2 = 1;
      $set_4(c[1].v, -h_0.x, h_0.y);
      c[1].fp.inEdge2 = 1;
      c[1].fp.outEdge2 = 2;
    }
     else {
      $set_4(c[0].v, -h_0.x, -h_0.y);
      c[0].fp.inEdge2 = 2;
      c[0].fp.outEdge2 = 3;
      $set_4(c[1].v, h_0.x, -h_0.y);
      c[1].fp.inEdge2 = 3;
      c[1].fp.outEdge2 = 4;
    }
  }
  c[0].v = mul_0(rot, c[0].v);
  $add_14(c[0].v, pos);
  c[1].v = mul_0(rot, c[1].v);
  $add_14(c[1].v, pos);
}

function $flip_0(fp){
  var temp;
  temp = fp.inEdge1;
  fp.inEdge1 = fp.inEdge2;
  fp.inEdge2 = temp;
  temp = fp.outEdge1;
  fp.outEdge1 = fp.outEdge2;
  fp.outEdge2 = temp;
}

function BoxBoxCollider_0(){
  $clinit_BoxBoxCollider();
}

defineSeed(603, 1, {}, BoxBoxCollider_0);
--></script>
<script><!--
_.collide = function collide_0(contacts, bodyA, bodyB){
  var C, RotAT, RotBT, absC, absCT, axis, clipPoints1, clipPoints2, dA, dB, dp, faceA, faceB, front, frontNormal, i, incidentEdge, negEdge, negSide, normal, np, numContacts, posA, posB, posEdge, posSide, rotA, rotB, separation, separation2, side, sideNormal, touches, x1, x2, y1, y2;
  x1 = bodyA.position_0.x;
  y1 = bodyA.position_0.y;
  x2 = bodyB.position_0.x;
  y2 = bodyB.position_0.y;
  touches = $touches_0(bodyA.shape.getBounds(), x1, y1, bodyB.shape.getBounds(), x2, y2);
  if (!touches) {
    return 0;
  }
  $set_5(hA, bodyA.shape.size);
  $scale_0(hA, 0.5);
  $set_5(hB, bodyB.shape.size);
  $scale_0(hB, 0.5);
  posA = bodyA.position_0;
  posB = bodyB.position_0;
  rotA = new Matrix2f_1(bodyA.rotation);
  rotB = new Matrix2f_1(bodyB.rotation);
  RotAT = new Matrix2f_2(new Vector2f_1(rotA.col1.x, rotA.col2.x), new Vector2f_1(rotA.col1.y, rotA.col2.y));
  RotBT = new Matrix2f_2(new Vector2f_1(rotB.col1.x, rotB.col2.x), new Vector2f_1(rotB.col1.y, rotB.col2.y));
  dp = sub_0(posB, posA);
  dA = new Vector2f_1(RotAT.col1.x * dp.x + RotAT.col2.x * dp.y, RotAT.col1.y * dp.x + RotAT.col2.y * dp.y);
  dB = new Vector2f_1(RotBT.col1.x * dp.x + RotBT.col2.x * dp.y, RotBT.col1.y * dp.x + RotBT.col2.y * dp.y);
  C = new Matrix2f_2(mul_0(RotAT, rotB.col1), mul_0(RotAT, rotB.col2));
  absC = new Matrix2f_2(abs_0(C.col1), abs_0(C.col2));
  absCT = new Matrix2f_2(new Vector2f_1(absC.col1.x, absC.col2.x), new Vector2f_1(absC.col1.y, absC.col2.y));
  faceA = new Vector2f_1(abs(dA.x), abs(dA.y));
  $sub(faceA, hA);
  $sub(faceA, mul_0(absC, hB));
  if (faceA.x > 0 || faceA.y > 0) {
    return 0;
  }
  faceB = new Vector2f_1(abs(dB.x), abs(dB.y));
  $sub(faceB, mul_0(absCT, hA));
  $sub(faceB, hB);
  if (faceB.x > 0 || faceB.y > 0) {
    return 0;
  }
  axis = 1;
  separation = faceA.x;
  normal = dA.x > 0?rotA.col1:scale_0(rotA.col1, -1);
  if (faceA.y > 1.0499999523162842 * separation + 0.009999999776482582 * hA.y) {
    axis = 2;
    separation = faceA.y;
    normal = dA.y > 0?rotA.col2:scale_0(rotA.col2, -1);
  }
  if (faceB.x > 1.0499999523162842 * separation + 0.009999999776482582 * hB.x) {
    axis = 3;
    separation = faceB.x;
    normal = dB.x > 0?rotB.col1:scale_0(rotB.col1, -1);
  }
  if (faceB.y > 1.0499999523162842 * separation + 0.009999999776482582 * hB.y) {
    axis = 4;
    normal = dB.y > 0?rotB.col2:scale_0(rotB.col2, -1);
  }
  incidentEdge = initValues(_3Lnet_phys2d_raw_collide_BoxBoxCollider$ClipVertex_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$BoxBoxCollider$ClipVertex, [new BoxBoxCollider$ClipVertex_0, new BoxBoxCollider$ClipVertex_0]);
  switch (axis) {
    case 1:
      {
        frontNormal = normal;
        front = posA.x * normal.x + posA.y * normal.y + hA.x;
        sideNormal = rotA.col2;
        side = posA.x * sideNormal.x + posA.y * sideNormal.y;
        negSide = -side + hA.y;
        posSide = side + hA.y;
        negEdge = 3;
        posEdge = 1;
        $computeIncidentEdge(incidentEdge, hB, posB, rotB, normal);
      }

      break;
    case 2:
      {
        frontNormal = normal;
        front = posA.x * normal.x + posA.y * normal.y + hA.y;
        sideNormal = rotA.col1;
        side = posA.x * sideNormal.x + posA.y * sideNormal.y;
        negSide = -side + hA.x;
        posSide = side + hA.x;
        negEdge = 2;
        posEdge = 4;
        $computeIncidentEdge(incidentEdge, hB, posB, rotB, normal);
      }

      break;
    case 3:
      {
        frontNormal = scale_0(normal, -1);
        front = posB.x * frontNormal.x + posB.y * frontNormal.y + hB.x;
        sideNormal = rotB.col2;
        side = posB.x * sideNormal.x + posB.y * sideNormal.y;
        negSide = -side + hB.y;
        posSide = side + hB.y;
        negEdge = 3;
        posEdge = 1;
        $computeIncidentEdge(incidentEdge, hA, posA, rotA, frontNormal);
      }

      break;
    case 4:
      {
        frontNormal = scale_0(normal, -1);
        front = posB.x * frontNormal.x + posB.y * frontNormal.y + hB.y;
        sideNormal = rotB.col1;
        side = posB.x * sideNormal.x + posB.y * sideNormal.y;
        negSide = -side + hB.x;
        posSide = side + hB.x;
        negEdge = 2;
        posEdge = 4;
        $computeIncidentEdge(incidentEdge, hA, posA, rotA, frontNormal);
      }

      break;
    default:throw new RuntimeException_1('Unknown face!');
  }
  clipPoints1 = initValues(_3Lnet_phys2d_raw_collide_BoxBoxCollider$ClipVertex_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$BoxBoxCollider$ClipVertex, [new BoxBoxCollider$ClipVertex_0, new BoxBoxCollider$ClipVertex_0]);
  clipPoints2 = initValues(_3Lnet_phys2d_raw_collide_BoxBoxCollider$ClipVertex_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$BoxBoxCollider$ClipVertex, [new BoxBoxCollider$ClipVertex_0, new BoxBoxCollider$ClipVertex_0]);
  np = $clipSegmentToLine(clipPoints1, incidentEdge, (sideNormal.x *= -1 , sideNormal.y *= -1 , sideNormal), negSide, negEdge);
  sideNormal.x *= -1;
  sideNormal.y *= -1;
  if (np < 2)
    return 0;
  np = $clipSegmentToLine(clipPoints2, clipPoints1, sideNormal, posSide, posEdge);
  if (np < 2)
    return 0;
  numContacts = 0;
  for (i = 0; i < 2; ++i) {
    separation2 = $dot(frontNormal, clipPoints2[i].v) - front;
    if (separation2 <= 0) {
      contacts[numContacts].separation = separation2;
      $set_5(contacts[numContacts].normal, normal);
      $setPosition_1(contacts[numContacts], sub_0(clipPoints2[i].v, scale_0(frontNormal, separation2)));
      $setFeature(contacts[numContacts], clipPoints2[i].fp);
      (axis == 3 || axis == 4) && $flip_0(contacts[numContacts].feature);
      ++numContacts;
    }
  }
  return numContacts;
}
;
var hA, hB;
function BoxBoxCollider$ClipVertex_0(){
  this.v = new Vector2f_0;
  this.fp = new FeaturePair_0;
}

defineSeed(604, 1, makeCastMap([Q$BoxBoxCollider$ClipVertex]), BoxBoxCollider$ClipVertex_0);
function BoxCircleCollider_0(){
}

defineSeed(605, 1, {}, BoxCircleCollider_0);
_.collide = function collide_1(contacts, boxBody, circleBody){
  var box, circle, closest, closestDistance, contactPoint, dis, i, lines, normal, pts, r2, touches, x1, x2, y1, y2;
  x1 = boxBody.position_0.x;
  y1 = boxBody.position_0.y;
  x2 = circleBody.position_0.x;
  y2 = circleBody.position_0.y;
  touches = $touches_0(boxBody.shape.getBounds(), x1, y1, circleBody.shape.getBounds(), x2, y2);
  if (!touches) {
    return 0;
  }
  box = boxBody.shape;
  circle = circleBody.shape;
  pts = $getPoints(box, boxBody.position_0, boxBody.rotation);
  lines = initDim(_3Lnet_phys2d_raw_shapes_Line_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Line, 4, 0);
  lines[0] = new Line_1(pts[0], pts[1]);
  lines[1] = new Line_1(pts[1], pts[2]);
  lines[2] = new Line_1(pts[2], pts[3]);
  lines[3] = new Line_1(pts[3], pts[0]);
  r2 = circle.radius * circle.radius;
  closest = -1;
  closestDistance = 3.4028234663852886E38;
  for (i = 0; i < 4; ++i) {
    dis = $distanceSquared_0(lines[i], circleBody.position_0);
    if (dis < r2) {
      if (closestDistance > dis) {
        closestDistance = dis;
        closest = i;
      }
    }
  }
  if (closest > -1) {
    dis = Math.sqrt(closestDistance);
    $setSeparation(contacts[0], dis - circle.radius);
    contactPoint = new Vector2f_0;
    $getClosestPoint(lines[closest], circleBody.position_0, contactPoint);
    normal = sub_0(circleBody.position_0, contactPoint);
    $normalise(normal);
    $set_5(contacts[0].normal, normal);
    $set_5(contacts[0].position_0, contactPoint);
    $setFeature(contacts[0], new FeaturePair_0);
    return 1;
  }
  return 0;
}
;
function CircleCircleCollider_0(){
}

defineSeed(606, 1, {}, CircleCircleCollider_0);
_.collide = function collide_2(contacts, bodyA, bodyB){
  var circleA, circleB, fp, normal, pt, sep, touches, x1, x2, y1, y2;
  x1 = bodyA.position_0.x;
  y1 = bodyA.position_0.y;
  x2 = bodyB.position_0.x;
  y2 = bodyB.position_0.y;
  touches = $touches_0(bodyA.shape.getBounds(), x1, y1, bodyB.shape.getBounds(), x2, y2);
  if (!touches) {
    return 0;
  }
  circleA = bodyA.shape;
  circleB = bodyB.shape;
  touches = $touches_1(circleA, x1, y1, circleB, x2, y2);
  if (!touches) {
    return 0;
  }
  normal = sub_0(bodyB.position_0, bodyA.position_0);
  sep = circleA.radius + circleB.radius - sqrt(normal.x * normal.x + normal.y * normal.y);
  $normalise(normal);
  pt = scale_0(normal, circleA.radius);
  $add_14(pt, bodyA.position_0);
  contacts[0].separation = -sep;
  $set_5(contacts[0].position_0, pt);
  $set_5(contacts[0].normal, normal);
  fp = new FeaturePair_0;
  contacts[0].feature = fp;
  return 1;
}
;
function $createCollider(bodyA, bodyB){
  var shapeA, shapeB;
  shapeA = bodyA.shape;
  shapeB = bodyB.shape;
  if (instanceOf(shapeA, Q$Circle)) {
    return $createColliderFor_0(shapeA, shapeB);
  }
   else if (instanceOf(shapeA, Q$Box)) {
    return $createColliderFor(shapeA, shapeB);
  }
   else if (instanceOf(shapeA, Q$Line)) {
    return $createColliderFor_1(shapeA, shapeB);
  }
   else if (instanceOf(shapeA, Q$Polygon)) {
    return $createColliderFor_2(shapeA, shapeB);
  }
  throw new ColliderUnavailableException_0(shapeA, shapeB);
}

function $createColliderFor(shapeA, shapeB){
  if (instanceOf(shapeB, Q$Circle)) {
    return new BoxCircleCollider_0;
  }
   else if (instanceOf(shapeB, Q$Box)) {
    return new BoxBoxCollider_0;
  }
   else if (instanceOf(shapeB, Q$Line)) {
    return new SwapCollider_0(new LineBoxCollider_0);
  }
   else if (instanceOf(shapeB, Q$Polygon)) {
    return new SwapCollider_0(new PolygonBoxCollider_0);
  }
  throw new ColliderUnavailableException_0(shapeA, shapeB);
}

function $createColliderFor_0(shapeA, shapeB){
  if (instanceOf(shapeB, Q$Circle)) {
    return new CircleCircleCollider_0;
  }
   else if (instanceOf(shapeB, Q$Box)) {
    return new SwapCollider_0(new BoxCircleCollider_0);
  }
   else if (instanceOf(shapeB, Q$Line)) {
    return new SwapCollider_0(new LineCircleCollider_0);
  }
   else if (instanceOf(shapeB, Q$Polygon)) {
    return new SwapCollider_0(new PolygonCircleCollider_0);
  }
  throw new ColliderUnavailableException_0(shapeA, shapeB);
}

function $createColliderFor_1(shapeA, shapeB){
  if (instanceOf(shapeB, Q$Circle)) {
    return new LineCircleCollider_0;
  }
   else if (instanceOf(shapeB, Q$Box)) {
    return new LineBoxCollider_0;
  }
   else if (instanceOf(shapeB, Q$Line)) {
    return new LineLineCollider_0;
  }
   else if (instanceOf(shapeB, Q$Polygon)) {
    return new LinePolygonCollider_0;
  }
  throw new ColliderUnavailableException_0(shapeA, shapeB);
}

function $createColliderFor_2(shapeA, shapeB){
  if (instanceOf(shapeB, Q$Circle)) {
    return new PolygonCircleCollider_0;
  }
   else if (instanceOf(shapeB, Q$Box)) {
    return new PolygonBoxCollider_0;
  }
   else if (instanceOf(shapeB, Q$Line)) {
    return new SwapCollider_0(new LinePolygonCollider_0);
  }
   else if (instanceOf(shapeB, Q$Polygon)) {
    return new PolygonPolygonCollider_0;
  }
  throw new ColliderUnavailableException_0(shapeA, shapeB);
}

function ColliderUnavailableException_0(shapeA, shapeB){
  Exception_0.call(this, 'No collider available for shapes of type ' + shapeA.___clazz$.typeName + ' and ' + shapeB.___clazz$.typeName);
}

defineSeed(608, 51, makeCastMap([Q$Serializable, Q$Exception, Q$Throwable, Q$ColliderUnavailableException]), ColliderUnavailableException_0);
function $addVerticesToSweep(this$static, isA, verts){
  var dist, i, j;
  for (i = 0 , j = verts.length - 1; i < verts.length; j = i , ++i) {
    dist = $dot(this$static.sweepDir, verts[i]);
    !this$static.current || this$static.current.distance <= dist?$insertForwards(this$static, i, isA, dist):$insertBackwards(this$static, i, isA, dist);
    !this$static.current || this$static.current.distance <= dist?$insertForwards(this$static, j, isA, dist):$insertBackwards(this$static, j, isA, dist);
  }
}

function $getOverlappingEdges(this$static){
  var collidingEdges, edgeListA, edgeListB, edgesA, edgesB, i, lastDist;
  if (!this$static.current)
    return initDims([_3_3I_classLit, _3I_classLit], [makeCastMap([Q$Serializable, Q$Object_$1]), makeCastMap([Q$int_$1, Q$Serializable])], [Q$int_$1, -1], [0, 2], 2, 1);
  $goToStart(this$static);
  edgesA = new EdgeSweep$CurrentEdges_0;
  edgesB = new EdgeSweep$CurrentEdges_0;
  collidingEdges = new EdgeSweep$EdgePairs_0;
  lastDist = -3.4028234663852886E38;
  while (this$static.current) {
    if (this$static.current.distance > lastDist) {
      lastDist = this$static.current.distance;
      edgesA.scheduledForRemoval = null;
      edgesB.scheduledForRemoval = null;
    }
    if (this$static.current.isA) {
      if ($contains_6(edgesA, this$static.current.vertex)) {
        $scheduleRemoval(edgesA, this$static.current.vertex);
      }
       else {
        $addEdge(edgesA, this$static.current.vertex);
        edgeListB = $getEdges(edgesB);
        for (i = 0; i < edgeListB.length; ++i)
          $add_18(collidingEdges, this$static.current.vertex, edgeListB[i]);
      }
    }
     else {
      if ($contains_6(edgesB, this$static.current.vertex)) {
        $scheduleRemoval(edgesB, this$static.current.vertex);
      }
       else {
        $addEdge(edgesB, this$static.current.vertex);
        edgeListA = $getEdges(edgesA);
        for (i = 0; i < edgeListA.length; ++i)
          $add_18(collidingEdges, edgeListA[i], this$static.current.vertex);
      }
    }
    this$static.current = this$static.current.next;
  }
  return $toList(collidingEdges);
}

function $goToStart(this$static){
  while (this$static.current.previous)
    this$static.current = this$static.current.previous;
}

function $insert_1(this$static, distance){
  !this$static.current || this$static.current.distance <= distance?$insertForwards(this$static, 0, true, distance):$insertBackwards(this$static, 0, true, distance);
}

function $insertBackwards(this$static, vertex, isA, distance){
  var svl;
  svl = new EdgeSweep$ProjectedVertex_0(vertex, isA, distance);
  if (!this$static.current) {
    this$static.current = svl;
    return;
  }
  while (this$static.current.distance > svl.distance) {
    if (!this$static.current.previous) {
      this$static.current.previous = svl;
      svl.next = this$static.current;
      this$static.current = svl;
      return;
    }
    this$static.current = this$static.current.previous;
  }
  svl.next = this$static.current.next;
  svl.previous = this$static.current;
  this$static.current.next = svl;
  !!svl.next && (svl.next.previous = svl);
  this$static.current = svl;
}

function $insertForwards(this$static, vertex, isA, distance){
  var svl;
  svl = new EdgeSweep$ProjectedVertex_0(vertex, isA, distance);
  if (!this$static.current) {
    this$static.current = svl;
    return;
  }
  while (this$static.current.distance <= svl.distance) {
    if (!this$static.current.next) {
      this$static.current.next = svl;
      svl.previous = this$static.current;
      this$static.current = svl;
      return;
    }
    this$static.current = this$static.current.next;
  }
  svl.next = this$static.current;
  svl.previous = this$static.current.previous;
  this$static.current.previous = svl;
  !!svl.previous && (svl.previous.next = svl);
  this$static.current = svl;
}

function EdgeSweep_0(sweepDir){
  this.sweepDir = new Vector2f_2(sweepDir);
}

defineSeed(609, 1, {}, EdgeSweep_0);
_.current = null;
_.sweepDir = null;
function $addEdge(this$static, e){
  this$static.currentEdges = new EdgeSweep$CurrentEdges$LinkedEdgeList_0(e, this$static.currentEdges);
}

function $contains_6(this$static, e){
  var current;
  current = this$static.currentEdges;
  while (current) {
    if (current.edge == e)
      return true;
    current = current.next;
  }
  current = this$static.scheduledForRemoval;
  while (current) {
    if (current.edge == e)
      return true;
    current = current.next;
  }
  return false;
}

function $getEdges(this$static){
  var current, i, returnEdges;
  returnEdges = initDim(_3I_classLit, makeCastMap([Q$int_$1, Q$Serializable]), -1, $getNoEdges(this$static), 1);
  i = 0;
  current = this$static.currentEdges;
  while (current) {
    returnEdges[i] = current.edge;
    ++i;
    current = current.next;
  }
  current = this$static.scheduledForRemoval;
  while (current) {
    returnEdges[i] = current.edge;
    ++i;
    current = current.next;
  }
  return returnEdges;
}

function $getNoEdges(this$static){
  var count, current;
  count = 0;
  current = this$static.currentEdges;
  while (current) {
    ++count;
    current = current.next;
  }
  current = this$static.scheduledForRemoval;
  while (current) {
    ++count;
    current = current.next;
  }
  return count;
}

function $scheduleRemoval(this$static, e){
  var current, last;
  if (!this$static.currentEdges)
    return;
  if (this$static.currentEdges.edge == e) {
    this$static.currentEdges = this$static.currentEdges.next;
  }
   else {
    current = this$static.currentEdges.next;
    last = this$static.currentEdges;
    while (current) {
      if (current.edge == e) {
        last.next = current.next;
        this$static.scheduledForRemoval = new EdgeSweep$CurrentEdges$LinkedEdgeList_0(e, this$static.scheduledForRemoval);
        return;
      }
      last = current;
      current = current.next;
    }
  }
}

function EdgeSweep$CurrentEdges_0(){
}

defineSeed(610, 1, {}, EdgeSweep$CurrentEdges_0);
_.currentEdges = null;
_.scheduledForRemoval = null;
function EdgeSweep$CurrentEdges$LinkedEdgeList_0(edge, next){
  this.edge = edge;
  this.next = next;
}

defineSeed(611, 1, {}, EdgeSweep$CurrentEdges$LinkedEdgeList_0);
_.edge = 0;
_.next = null;
function $add_18(this$static, idA, idB){
  this$static.first = new EdgeSweep$EdgePairs$EdgePair_0(idA, idB, this$static.first);
  ++this$static.size;
}

function $toList(this$static){
  var current, i, list;
  list = initDims([_3_3I_classLit, _3I_classLit], [makeCastMap([Q$Serializable, Q$Object_$1]), makeCastMap([Q$int_$1, Q$Serializable])], [Q$int_$1, -1], [this$static.size, 2], 2, 1);
  current = this$static.first;
  for (i = 0; i < this$static.size; ++i) {
    list[i][0] = current.a_0;
    list[i][1] = current.b;
    current = current.next;
  }
  return list;
}

function EdgeSweep$EdgePairs_0(){
}

defineSeed(612, 1, {}, EdgeSweep$EdgePairs_0);
_.first = null;
_.size = 0;
function EdgeSweep$EdgePairs$EdgePair_0(a, b, next){
  this.a_0 = a;
  this.b = b;
  this.next = next;
}

defineSeed(613, 1, {}, EdgeSweep$EdgePairs$EdgePair_0);
_.a_0 = 0;
_.b = 0;
_.next = null;
function EdgeSweep$ProjectedVertex_0(vertex, isA, distance){
  this.vertex = vertex;
  this.isA = isA;
  this.distance = distance;
}

defineSeed(614, 1, {}, EdgeSweep$ProjectedVertex_0);
_.distance = 0;
_.isA = false;
_.next = null;
_.previous = null;
_.vertex = 0;
function $equals_1(this$static, other){
  if (instanceOf(other, Q$FeaturePair)) {
    return $getKey(other) == this$static.inEdge1 + (this$static.outEdge1 << 8) + (this$static.inEdge2 << 16) + (this$static.outEdge2 << 24);
  }
  return false;
}

function $getKey(this$static){
  return this$static.inEdge1 + (this$static.outEdge1 << 8) + (this$static.inEdge2 << 16) + (this$static.outEdge2 << 24);
}

function $set_7(this$static, other){
  this$static.inEdge1 = other.inEdge1;
  this$static.inEdge2 = other.inEdge2;
  this$static.outEdge1 = other.outEdge1;
  this$static.outEdge2 = other.outEdge2;
}

function FeaturePair_0(){
}

function FeaturePair_1(index){
  this.inEdge1 = index;
}

function FeaturePair_2(inEdge1, inEdge2, outEdge1, outEdge2){
  this.inEdge1 = inEdge1;
  this.inEdge2 = inEdge2;
  this.outEdge1 = outEdge1;
  this.outEdge2 = outEdge2;
}

defineSeed(615, 1, makeCastMap([Q$FeaturePair]), FeaturePair_0, FeaturePair_1, FeaturePair_2);
_.equals$ = function equals_29(other){
  return $equals_1(this, other);
}
;
_.hashCode$ = function hashCode_28(){
  return this.inEdge1 + (this.outEdge1 << 8) + (this.inEdge2 << 16) + (this.outEdge2 << 24);
}
;
_.toString$ = function toString_41(){
  return '((' + this.inEdge1 + ',' + this.inEdge2 + '),(' + this.outEdge1 + ',' + this.outEdge2 + '))';
}
;
_.inEdge1 = 0;
_.inEdge2 = 0;
_.outEdge1 = 0;
_.outEdge2 = 0;
defineSeed(616, 1, makeCastMap([Q$Intersection]));
_.edgeA = 0;
_.edgeB = 0;
_.isIngoing = false;
_.position_0 = null;
function $filterIntersections(this$static, referencePointer, pointers){
  var i, intersection, j, k, noRemoved, topOut;
  if (referencePointer >= this$static.noIntersections && referencePointer < 0)
    throw new RuntimeException_1('The reference vertex cannot be correct since B does not have that many vertices.');
  topOut = -2;
  for (i = referencePointer; i < this$static.noIntersections + referencePointer; ++i) {
    j = i % this$static.noIntersections;
    k = pointers[j].value_0;
    intersection = this$static.intersections[k];
    intersection.isIngoing?(topOut - 1 + this$static.noIntersections) % this$static.noIntersections == k?(topOut = -2):(this$static.intersections[k] = null):topOut < 0?(topOut = k):(this$static.intersections[k] = null);
  }
  noRemoved = 0;
  for (i = 0; i < this$static.noIntersections; ++i) {
    !this$static.intersections[i]?++noRemoved:(this$static.intersections[i - noRemoved] = this$static.intersections[i]);
  }
  this$static.noIntersections -= noRemoved;
}

function $getIntersectionPairs(this$static){
  var first, i, in_$, inArr, out, outIntersections, pair, pointers, referenceVertB;
  if (this$static.noIntersections < 2)
    return initDims([_3_3Lnet_phys2d_raw_collide_Intersection_2_classLit, _3Lnet_phys2d_raw_collide_Intersection_2_classLit], [makeCastMap([Q$Serializable, Q$Object_$1]), makeCastMap([Q$Serializable, Q$Object_$1, Q$Intersection_$1])], [Q$Intersection_$1, Q$Intersection], [0, 2], 2, 0);
  sort(this$static.intersections, this$static.noIntersections, new IntersectionGatherer$IntersectionComparator_0);
  pointers = initDim(_3Ljava_lang_Integer_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Integer, this$static.noIntersections, 0);
  for (i = 0; i < this$static.noIntersections; ++i)
    pointers[i] = new Integer_0(i);
  sort_0(pointers, new IntersectionGatherer$PointerTableComparator_0(this$static));
  referenceVertB = $getReferencePointer(this$static, pointers);
  $filterIntersections(this$static, referenceVertB, pointers);
  first = this$static.intersections[0].isIngoing?0:1;
  outIntersections = new LinkedList_0;
  for (i = first; i < this$static.noIntersections + first;) {
    in_$ = this$static.intersections[i % this$static.noIntersections];
    out = this$static.intersections[(i + 1) % this$static.noIntersections];
    if (!in_$) {
      i += 1;
      continue;
    }
    if (!!out && in_$.isIngoing && !out.isIngoing) {
      if (!$equalsDelta(in_$.position_0, out.position_0)) {
        pair = initValues(_3Lnet_phys2d_raw_collide_Intersection_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1, Q$Intersection_$1]), Q$Intersection, [in_$, out]);
        new LinkedList$Node_1(pair, outIntersections.header);
        ++outIntersections.size;
        i += 2;
        continue;
      }
    }
    inArr = initValues(_3Lnet_phys2d_raw_collide_Intersection_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1, Q$Intersection_$1]), Q$Intersection, [in_$]);
    new LinkedList$Node_1(inArr, outIntersections.header);
    ++outIntersections.size;
    i += 1;
  }
  return $toArray(outIntersections, initDim(_3_3Lnet_phys2d_raw_collide_Intersection_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Intersection_$1, outIntersections.size, 0));
}

function $getIntersections(this$static){
  var i, out;
  out = initDim(_3Lnet_phys2d_raw_collide_Intersection_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1, Q$Intersection_$1]), Q$Intersection, this$static.noIntersections, 0);
  for (i = 0; i < this$static.noIntersections; ++i)
    setCheck(out, i, this$static.intersections[i]);
  sort_0(out, new IntersectionGatherer$IntersectionComparator_0);
  return out;
}

function $getReferencePointer(this$static, pointers){
  var first, i, inOutDist, intersection, k, lastInEdgeB, maxInIndex, maxInOutDist;
  first = this$static.intersections[pointers[0].value_0].isIngoing?0:1;
  maxInOutDist = 0;
  maxInIndex = first + 1 % this$static.noIntersections;
  lastInEdgeB = -1;
  for (i = first; i < this$static.noIntersections + first; ++i) {
    k = pointers[i % this$static.noIntersections].value_0;
    intersection = this$static.intersections[k];
    if (intersection.isIngoing) {
      lastInEdgeB = intersection.edgeB;
    }
     else if (lastInEdgeB >= 0) {
      inOutDist = (intersection.edgeB - lastInEdgeB + this$static.vertsB.length) % this$static.vertsB.length;
      if (inOutDist > maxInOutDist) {
        maxInOutDist = inOutDist;
        maxInIndex = i % this$static.noIntersections;
      }
      lastInEdgeB = -1;
    }
  }
  return maxInIndex;
}

function $intersect(this$static, a, b){
  var d, dist, distFromVertA, distFromVertB, endA, endB, position, sA, startA, startB, uA, uB;
  if (this$static.noIntersections >= 50)
    return;
  startA = this$static.vertsA[a];
  endA = this$static.vertsA[(a + 1) % this$static.vertsA.length];
  startB = this$static.vertsB[b];
  endB = this$static.vertsB[(b + 1) % this$static.vertsB.length];
  d = (endB.y - startB.y) * (endA.x - startA.x) - (endB.x - startB.x) * (endA.y - startA.y);
  if (d == 0)
    return;
  uA = (endB.x - startB.x) * (startA.y - startB.y) - (endB.y - startB.y) * (startA.x - startB.x);
  uA /= d;
  uB = (endA.x - startA.x) * (startA.y - startB.y) - (endA.y - startA.y) * (startA.x - startB.x);
  uB /= d;
  if (uA < 0 || uA > 1 || uB < 0 || uB > 1)
    return;
  position = new Vector2f_1(startA.x + uA * (endA.x - startA.x), startA.y + uA * (endA.y - startA.y));
  dist = new Vector2f_2(position);
  dist.x -= startA.x;
  dist.y -= startA.y;
  distFromVertA = dist.x * dist.x + dist.y * dist.y;
  dist = new Vector2f_2(position);
  dist.x -= startB.x;
  dist.y -= startB.y;
  distFromVertB = dist.x * dist.x + dist.y * dist.y;
  sA = (startA.x - startB.x) * (endB.y - startB.y) - (endB.x - startB.x) * (startA.y - startB.y);
  sA > 0?(this$static.intersections[this$static.noIntersections] = new IntersectionGatherer$SortableIntersection_0(a, b, position, true, distFromVertA, distFromVertB)):(this$static.intersections[this$static.noIntersections] = new IntersectionGatherer$SortableIntersection_0(a, b, position, false, distFromVertA, distFromVertB));
  ++this$static.noIntersections;
}

function IntersectionGatherer_0(vertsA, vertsB){
  this.intersections = initDim(_3Lnet_phys2d_raw_collide_IntersectionGatherer$SortableIntersection_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1, Q$Intersection_$1]), Q$IntersectionGatherer$SortableIntersection, 50, 0);
  this.noIntersections = 0;
  this.vertsA = vertsA;
  this.vertsB = vertsB;
}

defineSeed(617, 1, {}, IntersectionGatherer_0);
_.intersections = null;
_.noIntersections = 0;
_.vertsA = null;
_.vertsB = null;
function IntersectionGatherer$IntersectionComparator_0(){
}

defineSeed(618, 1, {}, IntersectionGatherer$IntersectionComparator_0);
_.compare = function compare_8(first, second){
  var one, other;
  one = first;
  other = second;
  if (one.edgeA < other.edgeA) {
    return -1;
  }
   else if (one.edgeA == other.edgeA) {
    if (one.distFromVertA < other.distFromVertA)
      return -1;
    else if (one.distFromVertA == other.distFromVertA && one.isIngoing)
      return -1;
  }
  return 1;
}
;
function IntersectionGatherer$PointerTableComparator_0(this$0){
  this.this$0 = this$0;
}

defineSeed(619, 1, {}, IntersectionGatherer$PointerTableComparator_0);
_.compare = function compare_9(first, second){
  var one, other;
  one = this.this$0.intersections[first.value_0];
  other = this.this$0.intersections[second.value_0];
  if (one.edgeB < other.edgeB) {
    return -1;
  }
   else if (one.edgeB == other.edgeB) {
    if (one.distFromVertB < other.distFromVertB)
      return -1;
    else if (one.distFromVertB == other.distFromVertB && !one.isIngoing)
      return -1;
  }
  return 1;
}
;
_.this$0 = null;
function IntersectionGatherer$SortableIntersection_0(edgeA, edgeB, position, isIngoing, distFromVertA, distFromVertB){
  this.edgeA = edgeA;
  this.edgeB = edgeB;
  this.position_0 = position;
  this.isIngoing = isIngoing;
  this.distFromVertA = distFromVertA;
  this.distFromVertB = distFromVertB;
}

defineSeed(620, 616, makeCastMap([Q$Intersection, Q$IntersectionGatherer$SortableIntersection]), IntersectionGatherer$SortableIntersection_0);
_.distFromVertA = 0;
_.distFromVertB = 0;
function $getProp(src, den){
  if (den.x == 0 && den.y == 0) {
    return 0;
  }
  if (den.x != 0) {
    return src.x / den.x;
  }
  return src.y / den.y;
}

function $getPt(pts, index){
  index < 0 && (index += pts.length);
  index >= pts.length && (index -= pts.length);
  return pts[index];
}

function $resolveEndPointCollision(pos, bodyA, norm, leftLine, rightLine, contact, i){
  var dis, dis1, dis2, end, leftPoint, normLine, rightPoint, start;
  start = new Vector2f_2(pos);
  end = new Vector2f_2(start);
  end.x += norm.x;
  end.y += norm.y;
  $move(rightLine, bodyA.position_0);
  $move(leftLine, bodyA.position_0);
  normLine = new Line_1(start, end);
  rightPoint = $intersect_0(normLine, rightLine);
  leftPoint = $intersect_0(normLine, leftLine);
  dis1 = 3.4028234663852886E38;
  !!rightPoint && (dis1 = sqrt($distanceSquared(rightPoint, start)) - sqrt(norm.x * norm.x + norm.y * norm.y));
  dis2 = 3.4028234663852886E38;
  !!leftPoint && (dis2 = sqrt($distanceSquared(leftPoint, start)) - sqrt(norm.x * norm.x + norm.y * norm.y));
  $normalise(norm);
  dis = dis1 < dis2?dis1:dis2;
  contact.separation = -dis;
  $set_5(contact.position_0, pos);
  $set_5(contact.normal, norm);
  $setFeature(contact, new FeaturePair_1(i));
}

function LineBoxCollider_0(){
}

defineSeed(621, 1, {}, LineBoxCollider_0);
--></script>
<script><!--
_.collide = function collide_3(contacts, bodyA, bodyB){
  var axis, box, c, centre, i, left, leftLine, line, linePos, lineVec, normal, numContacts, onAxis, outOfRange, pos, proj, pts, res, right, rightLine, tangent;
  numContacts = 0;
  line = bodyA.shape;
  box = bodyB.shape;
  lineVec = new Vector2f_1(line.end.x - line.start.x, line.end.y - line.start.y);
  $normalise(lineVec);
  axis = new Vector2f_1(-(line.end.y - line.start.y), line.end.x - line.start.x);
  $normalise(axis);
  res = new Vector2f_0;
  $projectOntoUnit(line.start, axis, res);
  linePos = $getProp(res, axis);
  c = sub_0(bodyB.position_0, bodyA.position_0);
  $projectOntoUnit(c, axis, res);
  centre = $getProp(res, axis);
  pts = $getPoints(box, bodyB.position_0, bodyB.rotation);
  tangent = initDim(_3F_classLit, makeCastMap([Q$Serializable]), -1, 4, 1);
  proj = initDim(_3F_classLit, makeCastMap([Q$Serializable]), -1, 4, 1);
  outOfRange = 0;
  for (i = 0; i < 4; ++i) {
    $sub(pts[i], bodyA.position_0);
    $projectOntoUnit(pts[i], axis, res);
    tangent[i] = $getProp(res, axis);
    $projectOntoUnit(pts[i], lineVec, res);
    proj[i] = $getProp(res, new Vector2f_1(line.end.x - line.start.x, line.end.y - line.start.y));
    (proj[i] >= 1 || proj[i] <= 0) && ++outOfRange;
  }
  if (outOfRange == 4) {
    return 0;
  }
  normal = new Vector2f_2(axis);
  if (centre < linePos) {
    normal.x *= -1;
    normal.y *= -1;
    for (i = 0; i < 4; ++i) {
      if (tangent[i] > linePos) {
        if (proj[i] < 0) {
          onAxis = new Vector2f_0;
          leftLine = new Line_1($getPt(pts, i - 1), pts[i]);
          rightLine = new Line_1($getPt(pts, i + 1), pts[i]);
          $getClosestPoint(leftLine, line.start, res);
          $projectOntoUnit(res, axis, onAxis);
          left = $getProp(onAxis, axis);
          $getClosestPoint(rightLine, line.start, res);
          $projectOntoUnit(res, axis, onAxis);
          right = $getProp(onAxis, axis);
          if (left > 0 && right > 0) {
            pos = new Vector2f_2(bodyA.position_0);
            $add_14(pos, line.start);
            $resolveEndPointCollision(pos, bodyA, normal, leftLine, rightLine, contacts[numContacts], i);
            ++numContacts;
          }
        }
         else if (proj[i] > 1) {
          onAxis = new Vector2f_0;
          leftLine = new Line_1($getPt(pts, i - 1), pts[i]);
          rightLine = new Line_1($getPt(pts, i + 1), pts[i]);
          $getClosestPoint(leftLine, line.end, res);
          $projectOntoUnit(res, axis, onAxis);
          left = $getProp(onAxis, axis);
          $getClosestPoint(rightLine, line.end, res);
          $projectOntoUnit(res, axis, onAxis);
          right = $getProp(onAxis, axis);
          if (left > 0 && right > 0) {
            pos = new Vector2f_2(bodyA.position_0);
            $add_14(pos, line.end);
            $resolveEndPointCollision(pos, bodyA, normal, leftLine, rightLine, contacts[numContacts], i);
            ++numContacts;
          }
        }
         else {
          $projectOntoUnit(pts[i], lineVec, res);
          $add_14(res, bodyA.position_0);
          contacts[numContacts].separation = -(tangent[i] - linePos);
          $setPosition_1(contacts[numContacts], new Vector2f_2(res));
          $set_5(contacts[numContacts].normal, normal);
          $setFeature(contacts[numContacts], new FeaturePair_1(i));
          ++numContacts;
        }
      }
    }
  }
   else {
    for (i = 0; i < 4; ++i) {
      if (tangent[i] < linePos) {
        if (proj[i] < 0) {
          onAxis = new Vector2f_0;
          leftLine = new Line_1($getPt(pts, i - 1), pts[i]);
          rightLine = new Line_1($getPt(pts, i + 1), pts[i]);
          $getClosestPoint(leftLine, line.start, res);
          $projectOntoUnit(res, axis, onAxis);
          left = $getProp(onAxis, axis);
          $getClosestPoint(rightLine, line.start, res);
          $projectOntoUnit(res, axis, onAxis);
          right = $getProp(onAxis, axis);
          if (left < 0 && right < 0) {
            pos = new Vector2f_2(bodyA.position_0);
            $add_14(pos, line.start);
            $resolveEndPointCollision(pos, bodyA, normal, leftLine, rightLine, contacts[numContacts], i);
            ++numContacts;
          }
        }
         else if (proj[i] > 1) {
          onAxis = new Vector2f_0;
          leftLine = new Line_1($getPt(pts, i - 1), pts[i]);
          rightLine = new Line_1($getPt(pts, i + 1), pts[i]);
          $getClosestPoint(leftLine, line.end, res);
          $projectOntoUnit(res, axis, onAxis);
          left = $getProp(onAxis, axis);
          $getClosestPoint(rightLine, line.end, res);
          $projectOntoUnit(res, axis, onAxis);
          right = $getProp(onAxis, axis);
          if (left < 0 && right < 0) {
            pos = new Vector2f_2(bodyA.position_0);
            $add_14(pos, line.end);
            $resolveEndPointCollision(pos, bodyA, normal, leftLine, rightLine, contacts[numContacts], i);
            ++numContacts;
          }
        }
         else {
          $projectOntoUnit(pts[i], lineVec, res);
          $add_14(res, bodyA.position_0);
          contacts[numContacts].separation = -(linePos - tangent[i]);
          $setPosition_1(contacts[numContacts], new Vector2f_2(res));
          $set_5(contacts[numContacts].normal, normal);
          $setFeature(contacts[numContacts], new FeaturePair_0);
          ++numContacts;
        }
      }
    }
  }
  if (numContacts > 2) {
    throw new RuntimeException_1('LineBoxCollision: > 2 contacts');
  }
  return numContacts;
}
;
function LineCircleCollider_0(){
}

defineSeed(622, 1, {}, LineCircleCollider_0);
_.collide = function collide_4(contacts, bodyA, bodyB){
  var circle, d, distSquared, endA, endB, line, position, radiusSquared, separation, startA, startB, uA, vertsA;
  line = bodyA.shape;
  circle = bodyB.shape;
  vertsA = $getVertices_1(line, bodyA.position_0, bodyA.rotation);
  startA = vertsA[0];
  endA = vertsA[1];
  startB = bodyB.position_0;
  endB = new Vector2f_2(endA);
  endB.x -= startA.x;
  endB.y -= startA.y;
  $set_4(endB, endB.y, -endB.x);
  d = endB.y * (endA.x - startA.x);
  d -= endB.x * (endA.y - startA.y);
  uA = endB.x * (startA.y - startB.y);
  uA -= endB.y * (startA.x - startB.x);
  uA /= d;
  uA < 0?(position = startA):uA > 1?(position = endA):(position = new Vector2f_1(startA.x + uA * (endA.x - startA.x), startA.y + uA * (endA.y - startA.y)));
  $set_4(endB, startB.x, startB.y);
  endB.x -= position.x;
  endB.y -= position.y;
  distSquared = endB.x * endB.x + endB.y * endB.y;
  radiusSquared = circle.radius * circle.radius;
  if (distSquared < radiusSquared) {
    $set_5(contacts[0].position_0, position);
    $setFeature(contacts[0], new FeaturePair_0);
    $normalise(endB);
    $set_5(contacts[0].normal, endB);
    separation = Math.sqrt(distSquared) - circle.radius;
    contacts[0].separation = separation;
    return 1;
  }
  return 0;
}
;
function LineLineCollider_0(){
}

defineSeed(623, 1, {}, LineLineCollider_0);
_.collide = function collide_5(contacts, bodyA, bodyB){
  return 0;
}
;
function $getCollisionCandidates(sweep, vertsA, vertsB){
  $addVerticesToSweep(sweep, true, vertsA);
  $addVerticesToSweep(sweep, false, vertsB);
  return $getOverlappingEdges(sweep);
}

function $getIntersectionPairs_0(vertsA, vertsB, collEdgeCands){
  var fpl, i;
  if (collEdgeCands.length == 0)
    return initDims([_3_3Lnet_phys2d_raw_collide_Intersection_2_classLit, _3Lnet_phys2d_raw_collide_Intersection_2_classLit], [makeCastMap([Q$Serializable, Q$Object_$1]), makeCastMap([Q$Serializable, Q$Object_$1, Q$Intersection_$1])], [Q$Intersection_$1, Q$Intersection], [0, 2], 2, 0);
  fpl = new IntersectionGatherer_0(vertsA, vertsB);
  for (i = 0; i < collEdgeCands.length; ++i) {
    $intersect(fpl, collEdgeCands[i][0], collEdgeCands[i][1]);
  }
  return $getIntersectionPairs(fpl);
}

function $populateContacts(contacts, vertsA, vertsB, intersections){
  var i, noContacts;
  if (intersections.length == 0)
    return 0;
  noContacts = 0;
  for (i = 0; i < intersections.length; ++i) {
    if (noContacts >= contacts.length)
      return contacts.length;
    if (intersections[i].length == 2 && noContacts < contacts.length - 1) {
      $setContactPair(contacts[noContacts], contacts[noContacts + 1], intersections[i][0], intersections[i][1], vertsA, vertsB);
      noContacts += 2;
    }
     else if (intersections[i].length == 1) {
      $setContact(contacts[noContacts], intersections[i][0], vertsA, vertsB);
      noContacts += 1;
    }
  }
  return noContacts;
}

function $setContact(contact, intersection, vertsA, vertsB){
  var endA, endB, normal, startA, startB;
  startA = vertsA[intersection.edgeA];
  endA = vertsA[(intersection.edgeA + 1) % vertsA.length];
  startB = vertsB[intersection.edgeB];
  endB = vertsB[(intersection.edgeB + 1) % vertsB.length];
  normal = getNormal(startA, endA);
  $sub(normal, getNormal(startB, endB));
  $normalise(normal);
  $set_5(contact.normal, normal);
  contact.separation = 0;
  $setFeature(contact, new FeaturePair_2(intersection.edgeA, intersection.edgeB, 0, 0));
  $setPosition_1(contact, intersection.position_0);
}

function $setContactPair(contact1, contact2, in_$, out, vertsA, vertsB){
  var entryPoint, exitPoint, feature, normal, separation;
  entryPoint = in_$.position_0;
  exitPoint = out.position_0;
  normal = getNormal(entryPoint, exitPoint);
  feature = new FeaturePair_2(in_$.edgeA, in_$.edgeB, out.edgeA, out.edgeB);
  separation = -getPenetrationDepth(in_$, out, normal, vertsA, vertsB);
  separation /= 4;
  contact1.separation = separation;
  $set_5(contact1.normal, normal);
  $set_5(contact1.position_0, entryPoint);
  contact1.feature = feature;
  contact2.separation = separation;
  $set_5(contact2.normal, normal);
  $set_5(contact2.position_0, exitPoint);
  contact2.feature = feature;
}

function PolygonPolygonCollider_0(){
}

defineSeed(625, 1, {}, PolygonPolygonCollider_0);
_.collide = function collide_6(contacts, bodyA, bodyB){
  var centroidA, centroidB, collEdgeCands, intersections, polyA, polyB, vertsA, vertsB, sweepDir;
  polyA = bodyA.shape;
  polyB = bodyB.shape;
  vertsA = $getVertices_0(polyA, bodyA.position_0, bodyA.rotation);
  vertsB = $getVertices_0(polyB, bodyB.position_0, bodyB.rotation);
  centroidA = new Vector2f_2(polyA.centroid);
  $add_14(centroidA, bodyA.position_0);
  centroidB = new Vector2f_2(polyB.centroid);
  $add_14(centroidB, bodyB.position_0);
  collEdgeCands = (sweepDir = new Vector2f_2(centroidB) , sweepDir.x -= centroidA.x , sweepDir.y -= centroidA.y , $getCollisionCandidates(new EdgeSweep_0(sweepDir), vertsA, vertsB));
  intersections = $getIntersectionPairs_0(vertsA, vertsB, collEdgeCands);
  return $populateContacts(contacts, vertsA, vertsB, intersections);
}
;
function $populateContacts_0(contacts, vertsA, vertsB, intersections){
  var i, noContacts;
  if (intersections.length == 0)
    return 0;
  noContacts = 0;
  if (!intersections[0].isIngoing) {
    $setLineEndContact(contacts[0], intersections[intersections.length - 1], vertsA, vertsB);
    contacts[0].separation < -10 && undefined;
    ++noContacts;
  }
  i = noContacts;
  while (i < intersections.length - 1) {
    if (noContacts > contacts.length - 2)
      return noContacts;
    if (!intersections[i].isIngoing || intersections[i + 1].isIngoing) {
      $setContact(contacts[noContacts], intersections[i], vertsA, vertsB);
      ++i;
      ++noContacts;
      continue;
    }
    $setContactPair(contacts[noContacts], contacts[noContacts + 1], intersections[i], intersections[i + 1], vertsA, vertsB);
    contacts[noContacts].separation < -10 && undefined;
    noContacts += 2;
    i += 2;
  }
  if (i < intersections.length && intersections[intersections.length - 1].isIngoing && noContacts < contacts.length) {
    $setLineEndContact(contacts[noContacts], intersections[intersections.length - 1], vertsA, vertsB);
    contacts[noContacts].separation < -10 && undefined;
    ++noContacts;
  }
  return noContacts;
}

function $setLineEndContact(contact, intersection, vertsA, vertsB){
  var separation;
  separation = new Vector2f_2(intersection.position_0);
  intersection.isIngoing?$sub(separation, vertsA[1]):$sub(separation, vertsA[0]);
  contact.separation = -0.;
  $setNormal(contact, getNormal(vertsB[(intersection.edgeB + 1) % vertsB.length], vertsB[intersection.edgeB]));
  $setPosition_1(contact, intersection.position_0);
  $setFeature(contact, new FeaturePair_2(0, 0, intersection.edgeA, intersection.edgeB));
}

function LinePolygonCollider_0(){
}

defineSeed(624, 625, {}, LinePolygonCollider_0);
_.collide = function collide_7(contacts, bodyA, bodyB){
  var collEdgeCands, i, intGath, intersections, isLeftOf, line, normal, poly, pos, sweep, tmp, vertsA, vertsB;
  line = bodyA.shape;
  poly = bodyB.shape;
  vertsA = $getVertices_1(line, bodyA.position_0, bodyA.rotation);
  vertsB = $getVertices_0(poly, bodyB.position_0, bodyB.rotation);
  pos = $getCentroid(poly, bodyB.position_0, bodyB.rotation);
  isLeftOf = 0 > (pos.x - vertsA[0].x) * (vertsA[1].y - vertsA[0].y) - (vertsA[1].x - vertsA[0].x) * (pos.y - vertsA[0].y);
  if (isLeftOf) {
    tmp = vertsA[0];
    vertsA[0] = vertsA[1];
    vertsA[1] = tmp;
  }
  normal = new Vector2f_2(vertsA[1]);
  $sub(normal, vertsA[0]);
  $set_4(normal, normal.y, -normal.x);
  sweep = new EdgeSweep_0(normal);
  $insert_1(sweep, $dot(vertsA[0], normal));
  $insert_1(sweep, $dot(vertsA[1], normal));
  $addVerticesToSweep(sweep, false, vertsB);
  collEdgeCands = $getOverlappingEdges(sweep);
  intGath = new IntersectionGatherer_0(vertsA, vertsB);
  for (i = 0; i < collEdgeCands.length; ++i)
    $intersect(intGath, collEdgeCands[i][0], collEdgeCands[i][1]);
  intersections = $getIntersections(intGath);
  return $populateContacts_0(contacts, vertsA, vertsB, intersections);
}
;
function PenetrationSweep_0(normal, sweepDir, intersectionStart, intersectionEnd){
  this.normal = normal;
  this.sweepDir = sweepDir;
  this.startDist = intersectionStart.x * sweepDir.x + intersectionStart.y * sweepDir.y;
  this.endDist = intersectionEnd.x * sweepDir.x + intersectionEnd.y * sweepDir.y;
}

function getPenetrationDepth(in_$, out, normal, vertsA, vertsB){
  var lowerBound, penetration, ps, sweepdir, upperBound, walkerA, walkerB;
  sweepdir = new Vector2f_2(out.position_0);
  $sub(sweepdir, in_$.position_0);
  ps = new PenetrationSweep_0(normal, sweepdir, in_$.position_0, out.position_0);
  walkerA = new PenetrationSweep$ContourWalker_0(ps, vertsA, in_$.edgeA, out.edgeA, false);
  walkerB = new PenetrationSweep$ContourWalker_0(ps, vertsB, (out.edgeB + 1) % vertsB.length, (in_$.edgeB + 1) % vertsB.length, true);
  penetration = 0;
  lowerBound = $dot(in_$.position_0, normal);
  while ($hasNext_2(walkerA) || $hasNext_2(walkerB)) {
    if ($hasNext_2(walkerA) && ($getNextDistance(walkerA) < $getNextDistance(walkerB) || !$hasNext_2(walkerB))) {
      $next_8(walkerA);
      if (walkerA.distance < ps.startDist || walkerA.distance > ps.endDist)
        continue;
      upperBound = walkerA.penetration;
      lowerBound = $getPenetration(walkerB, walkerA.distance);
    }
     else {
      $next_8(walkerB);
      if (walkerB.distance < ps.startDist || walkerB.distance > ps.endDist)
        continue;
      upperBound = $getPenetration(walkerA, walkerB.distance);
      lowerBound = walkerB.penetration;
    }
    penetration = penetration > upperBound - lowerBound?penetration:upperBound - lowerBound;
  }
  return penetration;
}

defineSeed(626, 1, {}, PenetrationSweep_0);
_.endDist = 0;
_.normal = null;
_.startDist = 0;
_.sweepDir = null;
function $calculateNextValues(this$static){
  var nextVert;
  nextVert = this$static.isBackwards?this$static.currentVert - 1:this$static.currentVert + 1;
  nextVert = (nextVert + this$static.verts.length) % this$static.verts.length;
  this$static.nextDistance = $dot(this$static.verts[nextVert], this$static.this$0.sweepDir);
  this$static.penetrationDelta = $dot(this$static.verts[nextVert], this$static.this$0.normal) - this$static.penetration;
  if (this$static.nextDistance == this$static.distance) {
    this$static.penetration += this$static.penetrationDelta;
    this$static.penetrationDelta = 0;
  }
   else {
    this$static.penetrationDelta /= this$static.nextDistance - this$static.distance;
  }
}

function $getNextDistance(this$static){
  if (this$static.distance < this$static.this$0.startDist)
    return min(this$static.nextDistance, this$static.this$0.startDist);
  if (this$static.distance < this$static.this$0.endDist)
    return min(this$static.nextDistance, this$static.this$0.endDist);
  return this$static.nextDistance;
}

function $getPenetration(this$static, distance){
  return this$static.penetration + this$static.penetrationDelta * (distance - this$static.distance);
}

function $hasNext_2(this$static){
  var x;
  if (this$static.distance < this$static.this$0.startDist && this$static.nextDistance > this$static.this$0.startDist)
    return true;
  if (this$static.distance < this$static.this$0.endDist && this$static.nextDistance > this$static.this$0.endDist)
    return true;
  x = this$static.isBackwards?this$static.lastVert - this$static.currentVert:this$static.currentVert - this$static.firstVert;
  x = (x + this$static.verts.length) % this$static.verts.length;
  x = (this$static.lastVert - this$static.firstVert + this$static.verts.length) % this$static.verts.length - x;
  return x > 0;
}

function $next_8(this$static){
  if (!$hasNext_2(this$static))
    return;
  if (this$static.distance < this$static.this$0.startDist && this$static.nextDistance > this$static.this$0.startDist) {
    this$static.penetration = $getPenetration(this$static, this$static.this$0.startDist);
    this$static.distance = this$static.this$0.startDist;
    return;
  }
  if (this$static.distance < this$static.this$0.endDist && this$static.nextDistance > this$static.this$0.endDist) {
    this$static.penetration = $getPenetration(this$static, this$static.this$0.endDist);
    this$static.distance = this$static.this$0.endDist;
    return;
  }
  this$static.isBackwards?(this$static.currentVert = (this$static.currentVert - 1 + this$static.verts.length) % this$static.verts.length):(this$static.currentVert = (this$static.currentVert + 1) % this$static.verts.length);
  this$static.distance = $dot(this$static.verts[this$static.currentVert], this$static.this$0.sweepDir);
  this$static.penetration = $dot(this$static.verts[this$static.currentVert], this$static.this$0.normal);
  $calculateNextValues(this$static);
}

function PenetrationSweep$ContourWalker_0(this$0, verts, firstVert, lastVert, isBackwards){
  this.this$0 = this$0;
  if (firstVert < 0 || lastVert < 0)
    throw new IllegalArgumentException_1('Vertex numbers cannot be negative.');
  if (firstVert > verts.length || lastVert > verts.length)
    throw new IllegalArgumentException_1("The given vertex array doesn't include the first or the last vertex.");
  this.isBackwards = isBackwards;
  this.verts = verts;
  this.firstVert = firstVert;
  this.lastVert = lastVert;
  this.currentVert = isBackwards?lastVert:firstVert;
  this.distance = $dot(verts[this.currentVert], this$0.sweepDir);
  this.penetration = $dot(verts[this.currentVert], this$0.normal);
  $calculateNextValues(this);
}

defineSeed(627, 1, {}, PenetrationSweep$ContourWalker_0);
_.currentVert = 0;
_.distance = 0;
_.firstVert = 0;
_.isBackwards = false;
_.lastVert = 0;
_.nextDistance = 0;
_.penetration = 0;
_.penetrationDelta = 0;
_.this$0 = null;
_.verts = null;
function PolygonBoxCollider_0(){
}

defineSeed(628, 625, {}, PolygonBoxCollider_0);
_.collide = function collide_8(contacts, bodyA, bodyB){
  var box, collEdgeCands, intersections, poly, sweep, sweepline, vertsA, vertsB;
  poly = bodyA.shape;
  box = bodyB.shape;
  vertsA = $getVertices_0(poly, bodyA.position_0, bodyA.rotation);
  vertsB = $getPoints(box, bodyB.position_0, bodyB.rotation);
  sweepline = new Vector2f_2(vertsB[1]);
  $sub(sweepline, vertsB[2]);
  sweep = new EdgeSweep_0(sweepline);
  $addVerticesToSweep(sweep, true, vertsA);
  $addVerticesToSweep(sweep, false, vertsB);
  collEdgeCands = $getOverlappingEdges(sweep);
  intersections = $getIntersectionPairs_0(vertsA, vertsB, collEdgeCands);
  return $populateContacts(contacts, vertsA, vertsB, intersections);
}
;
function $getCollisionCandidates_0(vertsA, centroid, radius, circlePos){
  var circProj, sweep, sweepDir;
  sweepDir = new Vector2f_2(centroid);
  sweepDir.x -= circlePos.x;
  sweepDir.y -= circlePos.y;
  $normalise(sweepDir);
  sweep = new EdgeSweep_0(sweepDir);
  $addVerticesToSweep(sweep, true, vertsA);
  circProj = circlePos.x * sweepDir.x + circlePos.y * sweepDir.y;
  !sweep.current || sweep.current.distance <= -radius + circProj?$insertForwards(sweep, 0, false, -radius + circProj):$insertBackwards(sweep, 0, false, -radius + circProj);
  !sweep.current || sweep.current.distance <= radius + circProj?$insertForwards(sweep, 0, false, radius + circProj):$insertBackwards(sweep, 0, false, radius + circProj);
  return $getOverlappingEdges(sweep);
}

function PolygonCircleCollider_0(){
}

defineSeed(629, 625, {}, PolygonCircleCollider_0);
_.collide = function collide_9(contacts, bodyA, bodyB){
  var centroidA, circle, collPairs, dis2, i, line, lineEndA, lineStartA, noContacts, normal, polyA, pt, r2, sep, vertsA;
  polyA = bodyA.shape;
  circle = bodyB.shape;
  vertsA = $getVertices_0(polyA, bodyA.position_0, bodyA.rotation);
  centroidA = new Vector2f_2(polyA.centroid);
  $add_14(centroidA, bodyA.position_0);
  collPairs = $getCollisionCandidates_0(vertsA, centroidA, circle.radius, bodyB.position_0);
  noContacts = 0;
  for (i = 0; i < collPairs.length; ++i) {
    if (noContacts >= contacts.length)
      return contacts.length;
    lineStartA = vertsA[collPairs[i][0]];
    lineEndA = vertsA[(collPairs[i][0] + 1) % vertsA.length];
    line = new Line_1(lineStartA, lineEndA);
    dis2 = $distanceSquared_0(line, bodyB.position_0);
    r2 = circle.radius * circle.radius;
    if (dis2 < r2) {
      pt = new Vector2f_0;
      $getClosestPoint(line, bodyB.position_0, pt);
      normal = new Vector2f_2(bodyB.position_0);
      normal.x -= pt.x;
      normal.y -= pt.y;
      sep = circle.radius - sqrt(normal.x * normal.x + normal.y * normal.y);
      $normalise(normal);
      contacts[noContacts].separation = -sep;
      $set_5(contacts[noContacts].position_0, pt);
      $set_5(contacts[noContacts].normal, normal);
      $setFeature(contacts[noContacts], new FeaturePair_0);
      ++noContacts;
    }
  }
  return noContacts;
}
;
function SwapCollider_0(collider){
  this.collider = collider;
}

defineSeed(630, 1, {}, SwapCollider_0);
_.collide = function collide_10(contacts, bodyA, bodyB){
  var count, i;
  count = this.collider.collide(contacts, bodyB, bodyA);
  for (i = 0; i < count; ++i) {
    scaleInSitu(contacts[i].normal, -1);
  }
  return count;
}
;
_.collider = null;
function $touches_0(this$static, x, y, other, otherx, othery){
  var dx, dy, totalHeight, totalWidth;
  totalWidth = (other.width_0 + this$static.width_0) / 2;
  totalHeight = (other.height_0 + this$static.height_0) / 2;
  dx = abs(x + this$static.offsetx - (otherx + other.offsetx));
  dy = abs(y + this$static.offsety - (othery + other.offsety));
  return totalWidth > dx && totalHeight > dy;
}

function AABox_0(width, height){
  this.width_0 = width;
  this.height_0 = height;
}

function AABox_1(width, height){
  this.width_0 = width;
  this.height_0 = height;
  this.offsetx = 0;
  this.offsety = 0;
}

defineSeed(631, 1, {}, AABox_0, AABox_1);
_.toString$ = function toString_42(){
  return '[AABox ' + this.width_0 + 'x' + this.height_0 + ']';
}
;
_.height_0 = 0;
_.offsetx = 0;
_.offsety = 0;
_.width_0 = 0;
function AbstractShape_0(bounds){
  this.bounds = bounds;
}

defineSeed(632, 1, makeCastMap([Q$AbstractShape, Q$Shape]));
_.getBounds = function getBounds(){
  return this.bounds;
}
;
_.bounds = null;
function $getPoints(this$static, pos, rotation){
  var R, h_0, pts;
  R = new Matrix2f_1(rotation);
  pts = initDim(_3Lnet_phys2d_math_Vector2f_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Vector2f, 4, 0);
  h_0 = scale_0(this$static.size, 0.5);
  pts[0] = mul_0(R, new Vector2f_1(-h_0.x, -h_0.y));
  $add_14(pts[0], pos);
  pts[1] = mul_0(R, new Vector2f_1(h_0.x, -h_0.y));
  $add_14(pts[1], pos);
  pts[2] = mul_0(R, new Vector2f_1(h_0.x, h_0.y));
  $add_14(pts[2], pos);
  pts[3] = mul_0(R, new Vector2f_1(-h_0.x, h_0.y));
  $add_14(pts[3], pos);
  return pts;
}

function Box_0(width, height){
  this.size = new Vector2f_0;
  $set_4(this.size, width, height);
  this.bounds = new AABox_0($length(this.size), $length(this.size));
}

defineSeed(633, 632, makeCastMap([Q$AbstractShape, Q$Box, Q$DynamicShape, Q$Shape]), Box_0);
_.getSurfaceFactor = function getSurfaceFactor(){
  var x, y;
  x = this.size.x;
  y = this.size.y;
  return x * x + y * y;
}
;
function $touches_1(this$static, x, y, other, ox, oy){
  var dx, dy, totalRad2;
  totalRad2 = this$static.radius + other.radius;
  if (abs(ox - x) > totalRad2) {
    return false;
  }
  if (abs(oy - y) > totalRad2) {
    return false;
  }
  totalRad2 *= totalRad2;
  dx = abs(ox - x);
  dy = abs(oy - y);
  return totalRad2 >= dx * dx + dy * dy;
}

function Circle_0(radius){
  AbstractShape_0.call(this, new AABox_0(radius * 2, radius * 2));
  this.radius = radius;
}

defineSeed(634, 632, makeCastMap([Q$AbstractShape, Q$Circle, Q$DynamicShape, Q$Shape]), Circle_0);
_.getSurfaceFactor = function getSurfaceFactor_0(){
  var circ;
  circ = 6.283185307179586 * this.radius;
  circ /= 2;
  return circ * circ;
}
;
_.radius = 0;
function $computeArea(this$static){
  var i, v1, v2;
  this$static.area = 0;
  for (i = 0; i < this$static.vertices.length; ++i) {
    v1 = this$static.vertices[i];
    v2 = this$static.vertices[(i + 1) % this$static.vertices.length];
    this$static.area += v1.x * v2.y;
    this$static.area -= v2.x * v1.y;
  }
  return abs(this$static.area / 2);
}

function $computeBoundingCircleRadius(this$static){
  var i, l_0, r;
  r = 0;
  for (i = 0; i < this$static.vertices.length; ++i) {
    l_0 = this$static.vertices[i].x * this$static.vertices[i].x + this$static.vertices[i].y * this$static.vertices[i].y;
    r = l_0 > r?l_0:r;
  }
  return Math.sqrt(r);
}

function $computeCentroid(this$static){
  var i, v1, v2, x, y;
  x = 0;
  y = 0;
  for (i = 0; i < this$static.vertices.length; ++i) {
    v1 = this$static.vertices[i];
    v2 = this$static.vertices[(i + 1) % this$static.vertices.length];
    x += (v1.x + v2.x) * (v1.x * v2.y - v2.x * v1.y);
    y += (v1.y + v2.y) * (v1.x * v2.y - v2.x * v1.y);
  }
  return new Vector2f_1(x / (6 * this$static.area), y / (6 * this$static.area));
}

function $getCentroid(this$static, displacement, rotation){
  var cos, sin;
  cos = Math.cos(rotation);
  sin = Math.sin(rotation);
  return new Vector2f_1(this$static.centroid.x * cos - this$static.centroid.y * sin + displacement.x, this$static.centroid.y * cos + this$static.centroid.x * sin + displacement.y);
}

function $getVertices(this$static){
  var i, roVertices;
  roVertices = initDim(_3Lnet_phys2d_math_ROVector2f_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$ROVector2f, this$static.vertices.length, 0);
  for (i = 0; i < this$static.vertices.length; ++i)
    setCheck(roVertices, i, this$static.vertices[i]);
  return roVertices;
}

function $getVertices_0(this$static, displacement, rotation){
  var cos, i, retVertices, sin, x, y;
  retVertices = initDim(_3Lnet_phys2d_math_Vector2f_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Vector2f, this$static.vertices.length, 0);
  cos = Math.cos(rotation);
  sin = Math.sin(rotation);
  for (i = 0; i < this$static.vertices.length; ++i) {
    x = this$static.vertices[i].x * cos - this$static.vertices[i].y * sin;
    y = this$static.vertices[i].y * cos + this$static.vertices[i].x * sin;
    x += displacement.x;
    y += displacement.y;
    retVertices[i] = new Vector2f_1(x, y);
  }
  return retVertices;
}

function $isConvex(this$static){
  var i, l_0, x, y, z;
  l_0 = this$static.vertices.length;
  for (i = 0; i < this$static.vertices.length; ++i) {
    x = this$static.vertices[i];
    y = this$static.vertices[(i + 1) % l_0];
    z = this$static.vertices[(i + 2) % l_0];
    if ((z.x - x.x) * (y.y - x.y) - (y.x - x.x) * (z.y - x.y) >= 0)
      return false;
  }
  return true;
}

defineSeed(636, 632, makeCastMap([Q$AbstractShape, Q$DynamicShape, Q$Polygon, Q$Shape]));
_.getSurfaceFactor = function getSurfaceFactor_1(){
  return this.area;
}
;
_.area = 0;
_.centroid = null;
_.vertices = null;
function ConvexPolygon_0(vertices){
  var i, r;
  if (vertices.length < 3)
    throw new IllegalArgumentException_1('A polygon can not have fewer than 3 edges!');
  this.vertices = initDim(_3Lnet_phys2d_math_Vector2f_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Vector2f, vertices.length, 0);
  for (i = 0; i < vertices.length; ++i) {
    this.vertices[i] = new Vector2f_2(vertices[i]);
  }
  if (!$isConvex(this))
    throw new IllegalArgumentException_1('The supplied vertices do not represent a convex polygon!');
  r = $computeBoundingCircleRadius(this);
  this.bounds = new AABox_0(r * 2, r * 2);
  this.area = $computeArea(this);
  this.centroid = $computeCentroid(this);
}

defineSeed(635, 636, makeCastMap([Q$AbstractShape, Q$ConvexPolygon, Q$DynamicShape, Q$Polygon, Q$Shape]), ConvexPolygon_0);
_.getSurfaceFactor = function getSurfaceFactor_2(){
  return this.area;
}
;
function $distanceSquared_0(this$static, point){
  var result;
  $getClosestPoint(this$static, point, this$static.closest);
  $sub(this$static.closest, point);
  result = $lengthSquared(this$static.closest);
  return result;
}

--></script>
<script><!--
function $getClosestPoint(this$static, point, result){
  $set_5(this$static.loc, point);
  $sub(this$static.loc, this$static.start);
  $set_5(this$static.v, this$static.vec);
  $set_5(this$static.v2, this$static.vec);
  $scale_0(this$static.v2, -1);
  $normalise(this$static.v);
  $projectOntoUnit(this$static.loc, this$static.v, this$static.proj);
  if ($lengthSquared(this$static.proj) > $lengthSquared(this$static.vec)) {
    $set_5(result, this$static.end);
    return;
  }
  $add_14(this$static.proj, this$static.start);
  $set_5(this$static.other, this$static.proj);
  $sub(this$static.other, this$static.end);
  if ($lengthSquared(this$static.other) > $lengthSquared(this$static.vec)) {
    $set_5(result, this$static.start);
    return;
  }
  $set_5(result, this$static.proj);
  return;
}

function $getVertices_1(this$static, displacement, rotation){
  var cos, endPoints, sin;
  cos = Math.cos(rotation);
  sin = Math.sin(rotation);
  endPoints = initDim(_3Lnet_phys2d_math_Vector2f_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Vector2f, 2, 0);
  endPoints[0] = new Vector2f_1(this$static.start.x * cos - this$static.start.y * sin, this$static.start.y * cos + this$static.start.x * sin);
  $add_14(endPoints[0], displacement);
  endPoints[1] = new Vector2f_1(this$static.end.x * cos - this$static.end.y * sin, this$static.end.y * cos + this$static.end.x * sin);
  $add_14(endPoints[1], displacement);
  return endPoints;
}

function $intersect_0(this$static, other){
  var denom, dx1, dx2, dy1, dy2, ix, iy, ua, ub;
  dx1 = this$static.end.x - this$static.start.x;
  dx2 = other.end.x - other.start.x;
  dy1 = this$static.end.y - this$static.start.y;
  dy2 = other.end.y - other.start.y;
  denom = dy2 * dx1 - dx2 * dy1;
  if (denom == 0) {
    return null;
  }
  ua = dx2 * (this$static.start.y - other.start.y) - dy2 * (this$static.start.x - other.start.x);
  ua /= denom;
  ub = dx1 * (this$static.start.y - other.start.y) - dy1 * (this$static.start.x - other.start.x);
  ub /= denom;
  ix = this$static.start.x + ua * (this$static.end.x - this$static.start.x);
  iy = this$static.start.y + ua * (this$static.end.y - this$static.start.y);
  return new Vector2f_1(ix, iy);
}

function $move(this$static, v){
  var temp;
  temp = new Vector2f_2(this$static.start);
  temp.x += v.x;
  temp.y += v.y;
  this$static.start = temp;
  temp = new Vector2f_2(this$static.end);
  temp.x += v.x;
  temp.y += v.y;
  this$static.end = temp;
}

function Line_0(x1, y1, x2, y2){
  Line_1.call(this, new Vector2f_1(x1, y1), new Vector2f_1(x2, y2));
}

function Line_1(start, end){
  var radius;
  this.loc = new Vector2f_1(0, 0);
  this.v = new Vector2f_1(0, 0);
  this.v2 = new Vector2f_1(0, 0);
  this.proj = new Vector2f_1(0, 0);
  this.closest = new Vector2f_1(0, 0);
  this.other = new Vector2f_1(0, 0);
  radius = max_0(sqrt(start.x * start.x + start.y * start.y), sqrt(end.x * end.x + end.y * end.y));
  this.bounds = new AABox_1(radius * 2, radius * 2);
  this.start = start;
  this.end = end;
  this.vec = new Vector2f_2(end);
  $sub(this.vec, start);
  this.lenSquared = $length(this.vec);
  this.lenSquared *= this.lenSquared;
}

defineSeed(637, 632, makeCastMap([Q$AbstractShape, Q$DynamicShape, Q$Line, Q$Shape]), Line_0, Line_1);
_.getSurfaceFactor = function getSurfaceFactor_3(){
  return $lengthSquared(this.vec) / 2;
}
;
_.toString$ = function toString_43(){
  return '[Line ' + this.start + ',' + this.end + ']';
}
;
_.end = null;
_.lenSquared = 0;
_.start = null;
_.vec = null;
defineSeed(638, 1, {});
defineSeed(639, 1, {});
_.height_1 = function height_0(){
  return this.height_0;
}
;
_.width_1 = function width_0(){
  return this.width_0;
}
;
_.height_0 = 0;
_.width_0 = 0;
function $equals_2(this$static, other){
  var ofont;
  if (instanceOf(other, Q$AbstractFont)) {
    ofont = other;
    return $equals_0(this$static.name_0, ofont.name_0) && this$static.style_0 == ofont.style_0 && this$static.size == ofont.size;
  }
   else {
    return false;
  }
}

function $hashCode_0(this$static){
  return getHashCode_0(this$static.name_0) ^ getHashCode(this$static.style_0) ^ round_int(this$static.size);
}

function AbstractFont_0(name_0, style, size){
  this.name_0 = name_0;
  this.style_0 = style;
  this.size = size;
}

defineSeed(640, 1, makeCastMap([Q$AbstractFont]));
_.equals$ = function equals_30(other){
  return $equals_2(this, other);
}
;
_.hashCode$ = function hashCode_29(){
  return $hashCode_0(this);
}
;
_.toString$ = function toString_44(){
  return this.name_0 + ' ' + this.style_0 + ' ' + this.size + 'pt';
}
;
_.name_0 = null;
_.size = 0;
_.style_0 = null;
function $interact(){
  return;
}

function $isSet(this$static, flag){
  return (this$static.flags & flag.bitmask) != 0;
}

function $onAdd(this$static){
  if ($isSet(this$static, ($clinit_AbstractLayer$Flag() , DESTROYED)))
    throw new IllegalStateException_1('Illegal to use destroyed layer: ' + this$static);
}

function $setFlag(this$static, flag, active){
  active?(this$static.flags |= flag.bitmask):(this$static.flags &= ~flag.bitmask);
}

function $transform_0(this$static){
  var cosa, m10, sina, tx, ty;
  if ($isSet(this$static, ($clinit_AbstractLayer$Flag() , XFDIRTY))) {
    sina = Math.sin(0);
    cosa = Math.cos(0);
    m10 = -sina;
    tx = this$static.transform_0.tx_0();
    ty = this$static.transform_0.ty_0();
    this$static.transform_0.setTransform(cosa, sina, m10, cosa, tx, ty);
    $setFlag(this$static, XFDIRTY, false);
  }
  return this$static.transform_0;
}

function AbstractLayer_0(transform){
  this.transform_0 = transform;
  $setFlag(this, ($clinit_AbstractLayer$Flag() , VISIBLE_1), true);
}

defineSeed(641, 1, {});
_.hitTest = function hitTest(p){
  return this.hitTestDefault(p);
}
;
_.hitTestDefault = function hitTestDefault(p){
  return p.x >= 0 && p.y >= 0 && p.x < 0 && p.y < 0?this:null;
}
;
_.interactive = function interactive_0(){
  return $isSet(this, ($clinit_AbstractLayer$Flag() , INTERACTIVE));
}
;
_.onAdd = function onAdd(){
  $onAdd(this);
}
;
_.onRemove = function onRemove(){
}
;
_.originX_0 = function originX_0(){
  return this.originX;
}
;
_.originY_0 = function originY_0(){
  return this.originY;
}
;
_.parent_1 = function parent_1(){
  return this.parent_0;
}
;
_.setInteractive = function setInteractive(interactive){
  if ($isSet(this, ($clinit_AbstractLayer$Flag() , INTERACTIVE)) != interactive) {
    interactive && !!this.parent_0 && this.parent_0.setInteractive(true);
    $setFlag(this, INTERACTIVE, interactive);
  }
  return this;
}
;
_.toString$ = function toString_45(){
  var bldr, cname;
  cname = this.___clazz$.typeName;
  bldr = new StringBuilder_1($substring(cname, cname.lastIndexOf('.') + 1));
  $append_9((bldr.impl.string += ' [hashCode=' , bldr), getHashCode(this));
  $append_11((bldr.impl.string += ', tx=' , bldr), $transform_0(this));
  return bldr.impl.string;
}
;
_.transform_1 = function transform_0(){
  return $transform_0(this);
}
;
_.depth = 0;
_.flags = 0;
_.originX = 0;
_.originY = 0;
_.parent_0 = null;
_.transform_0 = null;
function $clinit_AbstractLayer$Flag(){
  $clinit_AbstractLayer$Flag = nullMethod;
  DESTROYED = new AbstractLayer$Flag_0('DESTROYED', 0, 1);
  VISIBLE_1 = new AbstractLayer$Flag_0('VISIBLE', 1, 2);
  INTERACTIVE = new AbstractLayer$Flag_0('INTERACTIVE', 2, 4);
  SHOWN = new AbstractLayer$Flag_0('SHOWN', 3, 8);
  XFDIRTY = new AbstractLayer$Flag_0('XFDIRTY', 4, 16);
  $VALUES_25 = initValues(_3Lplayn_core_AbstractLayer$Flag_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$AbstractLayer$Flag, [DESTROYED, VISIBLE_1, INTERACTIVE, SHOWN, XFDIRTY]);
}

function AbstractLayer$Flag_0(enum$name, enum$ordinal, bitmask){
  Enum_0.call(this, enum$name, enum$ordinal);
  this.bitmask = bitmask;
}

function values_26(){
  $clinit_AbstractLayer$Flag();
  return $VALUES_25;
}

defineSeed(642, 11, makeCastMap([Q$Serializable, Q$Comparable, Q$Enum, Q$AbstractLayer$Flag]), AbstractLayer$Flag_0);
_.bitmask = 0;
var $VALUES_25, DESTROYED, INTERACTIVE, SHOWN, VISIBLE_1, XFDIRTY;
function AbstractPlatform_0(log){
  this.log_0 = log;
  this.runQueue = new RunQueue_0;
}

defineSeed(643, 1, {});
_.log_0 = null;
_.runQueue = null;
function $onLoadError(){
}

function $onLoaded(this$static, impl){
  this$static.impl = impl;
  $setVolumeImpl(this$static, this$static.volume_0);
  $setLoopingImpl(this$static, this$static.looping);
  this$static.playing && this$static.impl.play_1();
}

function $play_0(this$static){
  this$static.playing = true;
  return !!this$static.impl && this$static.impl.play_1();
}

function $setLooping_0(this$static, looping){
  this$static.looping = looping;
  !!this$static.impl && this$static.impl.setLooping_0(looping);
}

function $setVolume_2(this$static, volume){
  this$static.volume_0 = volume < 0?0:volume > 1?1:volume;
  !!this$static.impl && $setVolumeImpl(this$static, this$static.volume_0);
}

function $stop_2(this$static){
  this$static.playing = false;
  !!this$static.impl && this$static.impl.stop_0();
}

defineSeed(644, 1, {});
_.impl = null;
_.looping = false;
_.playing = false;
_.volume_0 = 1;
function $height(this$static){
  return 0.699999988079071 * this$static.metrics.height_0 + $descent(this$static.metrics);
}

function $width(this$static){
  return max_0(this$static.bounds.x, 0) + this$static.bounds.width_0;
}

function AbstractTextLayout_0(text, format, bounds){
  this.text = text;
  this.format = format;
  this.bounds = bounds;
}

defineSeed(645, 1, {});
_.bounds = null;
_.format = null;
_.text = null;
function $getImage_0(this$static, path){
  var object;
  if ((object = this$static.cache.get_1(path)) == null) {
    object = $getImage_1(this$static.delegate, path, ($clinit_Scale() , ONE_0));
    this$static.cache.put(path, object);
  }
  return object;
}

function $getMusic(this$static, path){
  var object;
  if ((object = this$static.cache.get_1(path)) == null) {
    object = $getSound_1(this$static.delegate, path);
    this$static.cache.put(path, object);
  }
  return object;
}

function $getSound_0(this$static, path){
  var object;
  if ((object = this$static.cache.get_1(path)) == null) {
    object = $getSound_1(this$static.delegate, path);
    this$static.cache.put(path, object);
  }
  return object;
}

function $getText_0(this$static, path, callback){
  $getText_1(this$static.delegate, path, callback);
}

function CachingAssets_0(delegate){
  this.cache = new HashMap_0;
  this.delegate = delegate;
}

defineSeed(646, 1, {}, CachingAssets_0);
_.delegate = null;
function $dispatch(event_0, interaction){
  $dispatch_0(event_0.captureState.layer, event_0, interaction);
}

function tryInteract(layer, interaction, event_0){
  var $e0, t;
  try {
    $interact(layer);
  }
   catch ($e0) {
    $e0 = caught_0($e0);
    if (instanceOf($e0, Q$Throwable)) {
      t = $e0;
      $warn_0(platform_1.log_0, 'Interaction failure [layer=' + layer + ', iact=' + interaction + ', event=' + event_0 + ']', t);
    }
     else 
      throw $e0;
  }
}

function $dispatch_0(layer, event_0, interaction){
  tryInteract(layer, interaction, event_0.localize(layer));
}

function Dispatcher$CaptureState_0(){
}

defineSeed(649, 1, {}, Dispatcher$CaptureState_0);
_.layer = null;
function $clinit_Events(){
  $clinit_Events = nullMethod;
  scratchPoint = new Point_0;
}

var scratchPoint;
function $setPreventDefault(this$static, preventDefault){
  this$static.preventDefault_0 = preventDefault;
}

function Events$Flags$Impl_0(){
}

defineSeed(651, 1, {}, Events$Flags$Impl_0);
_.toString$ = function toString_46(){
  return this.preventDefault_0?'preventDefault':'normal';
}
;
_.preventDefault_0 = false;
function Events$Input$Impl_0(flags, time){
  this.flags = flags;
  this.time = time;
}

defineSeed(652, 1, makeCastMap([Q$Events$Input, Q$Events$Input$Impl]));
_.addFields = function addFields(builder){
  $append_11($append_12($append_7((builder.impl.string += 'time=' , builder), this.time), ', flags='), this.flags);
}
;
_.name_1 = function name_1(){
  return 'Events.Input';
}
;
_.toString$ = function toString_47(){
  var builder;
  builder = $append_6(new StringBuilder_1(this.name_1()), 91);
  this.addFields(builder);
  return (builder.impl.string += ']' , builder).impl.string;
}
;
_.captureState = null;
_.flags = null;
_.time = 0;
function Events$Position$Impl_0(hit, flags, time, x, y){
  Events$Input$Impl_0.call(this, flags, time);
  this.hit = hit;
  this.x = x;
  this.y = y;
  if (!hit)
  ;
  else {
    screenToLayer(hit, $set_9(($clinit_Events() , scratchPoint), x, y), scratchPoint);
  }
}

defineSeed(653, 652, makeCastMap([Q$Events$Input, Q$Events$Input$Impl, Q$Events$Position, Q$Events$Position$Impl]));
_.addFields = function addFields_0(builder){
  $append_11($append_12($append_7((builder.impl.string += 'time=' , builder), this.time), ', flags='), this.flags);
  $append_11($append_12($append_8($append_12($append_8((builder.impl.string += ', x=' , builder), this.x), ', y='), this.y), ', hit='), this.hit);
}
;
_.name_1 = function name_2(){
  return 'Events.Position';
}
;
_.hit = null;
_.x = 0;
_.y = 0;
function $clinit_Font$Style(){
  $clinit_Font$Style = nullMethod;
  PLAIN = new Font$Style_0('PLAIN', 0);
  BOLD_0 = new Font$Style_0('BOLD', 1);
  ITALIC_0 = new Font$Style_0('ITALIC', 2);
  BOLD_ITALIC = new Font$Style_0('BOLD_ITALIC', 3);
  $VALUES_26 = initValues(_3Lplayn_core_Font$Style_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Font$Style, [PLAIN, BOLD_0, ITALIC_0, BOLD_ITALIC]);
}

function Font$Style_0(enum$name, enum$ordinal){
  Enum_0.call(this, enum$name, enum$ordinal);
}

function values_27(){
  $clinit_Font$Style();
  return $VALUES_26;
}

defineSeed(654, 11, makeCastMap([Q$Serializable, Q$Comparable, Q$Enum, Q$Font$Style]), Font$Style_0);
var $VALUES_26, BOLD_0, BOLD_ITALIC, ITALIC_0, PLAIN;
function $add_19(this$static, self_0, child){
  var count, index, parent_0;
  parent_0 = child.parent_0;
  if (parent_0 == self_0) {
    return $findChild_0(this$static, child, child.depth);
  }
  count = this$static.children.size;
  count == 0 || $get(this$static.children, count - 1).depth <= child.depth?(index = count):(index = $findInsertion(this$static, child.depth));
  !!parent_0 && child.parent_0.remove_4(child);
  $add(this$static.children, index, child);
  child.parent_0 = self_0;
  child.onAdd();
  $isSet(child, ($clinit_AbstractLayer$Flag() , INTERACTIVE)) && self_0.setInteractive(true);
  return index;
}

function $findChild_0(this$static, child, depth){
  var c, ii, ll, startIdx;
  startIdx = $findInsertion(this$static, depth);
  for (ii = startIdx - 1; ii >= 0; --ii) {
    c = $get(this$static.children, ii);
    if (c == child) {
      return ii;
    }
    if (c.depth != depth) {
      break;
    }
  }
  for (ii = startIdx , ll = this$static.children.size; ii < ll; ++ii) {
    c = $get(this$static.children, ii);
    if (c == child) {
      return ii;
    }
    if (c.depth != depth) {
      break;
    }
  }
  return -1;
}

function $findInsertion(this$static, depth){
  var high, low, mid, midDepth;
  low = 0;
  high = this$static.children.size - 1;
  while (low <= high) {
    mid = ~~(low + high) >>> 1;
    midDepth = $get(this$static.children, mid).depth;
    if (depth > midDepth) {
      low = mid + 1;
    }
     else if (depth < midDepth) {
      high = mid - 1;
    }
     else {
      return mid;
    }
  }
  return low;
}

function $hitTest(this$static, self_0, point){
  var $e0, child, ii, l_0, sawInteractiveChild, x, y;
  x = point.x;
  y = point.y;
  sawInteractiveChild = false;
  for (ii = this$static.children.size - 1; ii >= 0; --ii) {
    child = $get(this$static.children, ii);
    if (!$isSet(child, ($clinit_AbstractLayer$Flag() , INTERACTIVE)))
      continue;
    sawInteractiveChild = true;
    if (!$isSet(child, VISIBLE_1))
      continue;
    try {
      $transform_0(child).inverseTransform($set_9(point, x, y), point);
      point.x += child.originX;
      point.y += child.originY;
      l_0 = child.hitTestDefault(point);
      if (l_0)
        return l_0;
    }
     catch ($e0) {
      $e0 = caught_0($e0);
      if (instanceOf($e0, Q$NoninvertibleTransformException)) {
        continue;
      }
       else 
        throw $e0;
    }
  }
  !sawInteractiveChild && self_0.setInteractive(false);
  return null;
}

function $onAdd_0(this$static){
  var ii, ll;
  for (ii = 0 , ll = this$static.children.size; ii < ll; ++ii) {
    $get(this$static.children, ii).onAdd();
  }
}

function $onRemove(this$static){
  var ii, ll;
  for (ii = 0 , ll = this$static.children.size; ii < ll; ++ii) {
    $get(this$static.children, ii).onRemove();
  }
}

function $remove_19(this$static, child){
  var index, child_0;
  index = $findChild_0(this$static, child, child.depth);
  if (index < 0) {
    throw new UnsupportedOperationException_1('Could not remove Layer because it is not a child of the GroupLayer');
  }
  child_0 = $remove_0(this$static.children, index);
  child_0.onRemove();
  child_0.parent_0 = null;
}

function GroupLayerImpl_0(){
  this.children = new ArrayList_0;
}

defineSeed(655, 1, {}, GroupLayerImpl_0);
function $clinit_Key(){
  $clinit_Key = nullMethod;
  A_0 = new Key_2('A', 0);
  B_0 = new Key_2('B', 1);
  C_0 = new Key_2('C', 2);
  D = new Key_2('D', 3);
  E = new Key_2('E', 4);
  F = new Key_2('F', 5);
  G = new Key_2('G', 6);
  H = new Key_2('H', 7);
  I = new Key_2('I', 8);
  J = new Key_2('J', 9);
  K_0 = new Key_2('K', 10);
  L = new Key_2('L', 11);
  M = new Key_2('M', 12);
  N = new Key_2('N', 13);
  O = new Key_2('O', 14);
  P = new Key_2('P', 15);
  Q = new Key_2('Q', 16);
  R_0 = new Key_2('R', 17);
  S = new Key_2('S', 18);
  T = new Key_2('T', 19);
  U = new Key_2('U', 20);
  V = new Key_2('V', 21);
  W = new Key_2('W', 22);
  X = new Key_2('X', 23);
  Y = new Key_2('Y', 24);
  Z = new Key_2('Z', 25);
  K0 = new Key_2('K0', 26);
  K1_0 = new Key_2('K1', 27);
  K2_0 = new Key_2('K2', 28);
  K3_0 = new Key_2('K3', 29);
  K4 = new Key_2('K4', 30);
  K5 = new Key_2('K5', 31);
  K6 = new Key_2('K6', 32);
  K7 = new Key_2('K7', 33);
  K8 = new Key_2('K8', 34);
  K9 = new Key_2('K9', 35);
  NP0 = new Key_2('NP0', 36);
  NP1 = new Key_2('NP1', 37);
  NP2 = new Key_2('NP2', 38);
  NP3 = new Key_2('NP3', 39);
  NP4 = new Key_2('NP4', 40);
  NP5 = new Key_2('NP5', 41);
  NP6 = new Key_2('NP6', 42);
  NP7 = new Key_2('NP7', 43);
  NP8 = new Key_2('NP8', 44);
  NP9 = new Key_2('NP9', 45);
  NP_ADD = new Key_2('NP_ADD', 46);
  NP_DECIMAL = new Key_2('NP_DECIMAL', 47);
  NP_DELETE = new Key_2('NP_DELETE', 48);
  NP_DIVIDE = new Key_2('NP_DIVIDE', 49);
  NP_MULTIPLY = new Key_2('NP_MULTIPLY', 50);
  NP_NUM_LOCK = new Key_2('NP_NUM_LOCK', 51);
  NP_SUBTRACT = new Key_2('NP_SUBTRACT', 52);
  NP_DOWN = new Key_2('NP_DOWN', 53);
  NP_LEFT = new Key_2('NP_LEFT', 54);
  NP_RIGHT = new Key_2('NP_RIGHT', 55);
  NP_UP = new Key_2('NP_UP', 56);
  F1 = new Key_2('F1', 57);
  F2 = new Key_2('F2', 58);
  F3 = new Key_2('F3', 59);
  F4 = new Key_2('F4', 60);
  F5 = new Key_2('F5', 61);
  F6 = new Key_2('F6', 62);
  F7 = new Key_2('F7', 63);
  F8 = new Key_2('F8', 64);
  F9 = new Key_2('F9', 65);
  F10 = new Key_2('F10', 66);
  F11 = new Key_2('F11', 67);
  F12 = new Key_2('F12', 68);
  AMPERSAND = new Key_2('AMPERSAND', 69);
  ASTERISK = new Key_2('ASTERISK', 70);
  AT = new Key_2('AT', 71);
  BACKQUOTE = new Key_2('BACKQUOTE', 72);
  BACKSLASH = new Key_2('BACKSLASH', 73);
  BANG = new Key_2('BANG', 74);
  CIRCUMFLEX = new Key_2('CIRCUMFLEX', 75);
  COLON = new Key_2('COLON', 76);
  COMMA = new Key_2('COMMA', 77);
  DOLLAR = new Key_2('DOLLAR', 78);
  DOUBLE_QUOTE = new Key_2('DOUBLE_QUOTE', 79);
  EQUALS = new Key_2('EQUALS', 80);
  GREATER = new Key_2('GREATER', 81);
  HASH = new Key_2('HASH', 82);
  LEFT_BRACE = new Key_2('LEFT_BRACE', 83);
  LEFT_BRACKET = new Key_2('LEFT_BRACKET', 84);
  LEFT_PAREN = new Key_2('LEFT_PAREN', 85);
  LESS = new Key_2('LESS', 86);
  MINUS = new Key_2('MINUS', 87);
  MULTIPLY = new Key_2('MULTIPLY', 88);
  PERCENT = new Key_2('PERCENT', 89);
  PERIOD = new Key_2('PERIOD', 90);
  PLUS = new Key_2('PLUS', 91);
  QUOTE = new Key_2('QUOTE', 92);
  RIGHT_BRACE = new Key_2('RIGHT_BRACE', 93);
  RIGHT_BRACKET = new Key_2('RIGHT_BRACKET', 94);
  RIGHT_PAREN = new Key_2('RIGHT_PAREN', 95);
  SEMICOLON = new Key_2('SEMICOLON', 96);
  SLASH = new Key_2('SLASH', 97);
  SPACE = new Key_2('SPACE', 98);
  TILDE = new Key_2('TILDE', 99);
  QUESTION_MARK = new Key_2('QUESTION_MARK', 100);
  UNDERSCORE = new Key_2('UNDERSCORE', 101);
  VERTICAL_BAR = new Key_2('VERTICAL_BAR', 102);
  ALT = new Key_2('ALT', 103);
  CONTROL = new Key_2('CONTROL', 104);
  CAPS_LOCK = new Key_2('CAPS_LOCK', 105);
  SHIFT = new Key_2('SHIFT', 106);
  META = new Key_2('META', 107);
  DOWN_1 = new Key_2('DOWN', 108);
  END = new Key_2('END', 109);
  HOME = new Key_2('HOME', 110);
  LEFT_2 = new Key_2('LEFT', 111);
  PAGE_UP = new Key_2('PAGE_UP', 112);
  PAGE_DOWN = new Key_2('PAGE_DOWN', 113);
  RIGHT_2 = new Key_2('RIGHT', 114);
  UP_1 = new Key_2('UP', 115);
  BACKSPACE = new Key_2('BACKSPACE', 116);
  DELETE = new Key_2('DELETE', 117);
  ENTER = new Key_2('ENTER', 118);
  INSERT = new Key_2('INSERT', 119);
  TAB = new Key_2('TAB', 120);
  ESCAPE = new Key_2('ESCAPE', 121);
  PAUSE = new Key_2('PAUSE', 122);
  PRINT_SCREEN = new Key_2('PRINT_SCREEN', 123);
  SCROLL_LOCK = new Key_2('SCROLL_LOCK', 124);
  WINDOWS = new Key_2('WINDOWS', 125);
  MEDIA_CLOSE = new Key_2('MEDIA_CLOSE', 126);
  MEDIA_EJECT = new Key_2('MEDIA_EJECT', 127);
  MEDIA_FAST_FORWARD = new Key_2('MEDIA_FAST_FORWARD', 128);
  MEDIA_NEXT = new Key_2('MEDIA_NEXT', 129);
  MEDIA_PAUSE = new Key_2('MEDIA_PAUSE', 130);
  MEDIA_PLAY = new Key_2('MEDIA_PLAY', 131);
  MEDIA_PLAY_PAUSE = new Key_2('MEDIA_PLAY_PAUSE', 132);
  MEDIA_PREVIOUS = new Key_2('MEDIA_PREVIOUS', 133);
  MEDIA_RECORD = new Key_2('MEDIA_RECORD', 134);
  MEDIA_REWIND = new Key_2('MEDIA_REWIND', 135);
  MEDIA_STOP = new Key_2('MEDIA_STOP', 136);
  BLUE = new Key_2('BLUE', 137);
  GREEN = new Key_2('GREEN', 138);
  RED = new Key_2('RED', 139);
  YELLOW_0 = new Key_2('YELLOW', 140);
  APP_SWITCH = new Key_2('APP_SWITCH', 141);
  AVR_INPUT = new Key_2('AVR_INPUT', 142);
  AVR_POWER = new Key_2('AVR_POWER', 143);
  BACK = new Key_2('BACK', 144);
  BOOKMARK = new Key_2('BOOKMARK', 145);
  BREAK = new Key_2('BREAK', 146);
  BUTTON_1 = new Key_2('BUTTON_1', 147);
  BUTTON_2 = new Key_2('BUTTON_2', 148);
  BUTTON_3 = new Key_2('BUTTON_3', 149);
  BUTTON_4 = new Key_2('BUTTON_4', 150);
  BUTTON_5 = new Key_2('BUTTON_5', 151);
  BUTTON_6 = new Key_2('BUTTON_6', 152);
  BUTTON_7 = new Key_2('BUTTON_7', 153);
  BUTTON_8 = new Key_2('BUTTON_8', 154);
  BUTTON_9 = new Key_2('BUTTON_9', 155);
  BUTTON_10 = new Key_2('BUTTON_10', 156);
  BUTTON_11 = new Key_2('BUTTON_11', 157);
  BUTTON_12 = new Key_2('BUTTON_12', 158);
  BUTTON_13 = new Key_2('BUTTON_13', 159);
  BUTTON_14 = new Key_2('BUTTON_14', 160);
  BUTTON_15 = new Key_2('BUTTON_15', 161);
  BUTTON_16 = new Key_2('BUTTON_16', 162);
  BUTTON_A = new Key_2('BUTTON_A', 163);
  BUTTON_B = new Key_2('BUTTON_B', 164);
  BUTTON_C = new Key_2('BUTTON_C', 165);
  BUTTON_L1 = new Key_2('BUTTON_L1', 166);
  BUTTON_L2 = new Key_2('BUTTON_L2', 167);
  BUTTON_MODE = new Key_2('BUTTON_MODE', 168);
  BUTTON_R1 = new Key_2('BUTTON_R1', 169);
  BUTTON_R2 = new Key_2('BUTTON_R2', 170);
  BUTTON_SELECT = new Key_2('BUTTON_SELECT', 171);
  BUTTON_START = new Key_2('BUTTON_START', 172);
  BUTTON_THUMBL = new Key_2('BUTTON_THUMBL', 173);
  BUTTON_THUMBR = new Key_2('BUTTON_THUMBR', 174);
  BUTTON_X = new Key_2('BUTTON_X', 175);
  BUTTON_Y = new Key_2('BUTTON_Y', 176);
  BUTTON_Z = new Key_2('BUTTON_Z', 177);
  CALL = new Key_2('CALL', 178);
  CAMERA = new Key_2('CAMERA', 179);
  CAPTIONS = new Key_2('CAPTIONS', 180);
  CHANNEL_DOWN = new Key_2('CHANNEL_DOWN', 181);
  CHANNEL_UP = new Key_2('CHANNEL_UP', 182);
  CLEAR = new Key_2('CLEAR', 183);
  DPAD_CENTER = new Key_2('DPAD_CENTER', 184);
  DPAD_DOWN = new Key_2('DPAD_DOWN', 185);
  DPAD_LEFT = new Key_2('DPAD_LEFT', 186);
  DPAD_RIGHT = new Key_2('DPAD_RIGHT', 187);
  DPAD_UP = new Key_2('DPAD_UP', 188);
  DVR = new Key_2('DVR', 189);
  ENDCALL = new Key_2('ENDCALL', 190);
  ENVELOPE = new Key_2('ENVELOPE', 191);
  EXPLORER = new Key_2('EXPLORER', 192);
  FOCUS = new Key_2('FOCUS', 193);
  FORWARD = new Key_2('FORWARD', 194);
  FORWARD_DEL = new Key_2('FORWARD_DEL', 195);
  FUNCTION = new Key_2('FUNCTION', 196);
  GUIDE = new Key_2('GUIDE', 197);
  HEADSETHOOK = new Key_2('HEADSETHOOK', 198);
  INFO = new Key_2('INFO', 199);
  MENU = new Key_2('MENU', 200);
  MUTE = new Key_2('MUTE', 201);
  NOTIFICATION = new Key_2('NOTIFICATION', 202);
  NUM = new Key_2('NUM', 203);
  PICTSYMBOLS = new Key_2('PICTSYMBOLS', 204);
  POWER = new Key_2('POWER', 205);
  SEARCH = new Key_2('SEARCH', 206);
  SETTINGS = new Key_2('SETTINGS', 207);
  SOFT_LEFT = new Key_2('SOFT_LEFT', 208);
  SOFT_RIGHT = new Key_2('SOFT_RIGHT', 209);
  STAR = new Key_2('STAR', 210);
  STB_INPUT = new Key_2('STB_INPUT', 211);
  STB_POWER = new Key_2('STB_POWER', 212);
  SWITCH_CHARSET = new Key_2('SWITCH_CHARSET', 213);
  SYM = new Key_2('SYM', 214);
  SYSRQ = new Key_2('SYSRQ', 215);
  TV = new Key_2('TV', 216);
  TV_INPUT = new Key_2('TV_INPUT', 217);
  TV_POWER = new Key_2('TV_POWER', 218);
  VOLUME_DOWN = new Key_2('VOLUME_DOWN', 219);
  VOLUME_MUTE = new Key_2('VOLUME_MUTE', 220);
  VOLUME_UP = new Key_2('VOLUME_UP', 221);
  WINDOW = new Key_2('WINDOW', 222);
  ZOOM_IN = new Key_2('ZOOM_IN', 223);
  ZOOM_OUT = new Key_2('ZOOM_OUT', 224);
  UNKNOWN = new Key_2('UNKNOWN', 225);
  $VALUES_27 = initValues(_3Lplayn_core_Key_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Key_0, [A_0, B_0, C_0, D, E, F, G, H, I, J, K_0, L, M, N, O, P, Q, R_0, S, T, U, V, W, X, Y, Z, K0, K1_0, K2_0, K3_0, K4, K5, K6, K7, K8, K9, NP0, NP1, NP2, NP3, NP4, NP5, NP6, NP7, NP8, NP9, NP_ADD, NP_DECIMAL, NP_DELETE, NP_DIVIDE, NP_MULTIPLY, NP_NUM_LOCK, NP_SUBTRACT, NP_DOWN, NP_LEFT, NP_RIGHT, NP_UP, F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11, F12, AMPERSAND, ASTERISK, AT, BACKQUOTE, BACKSLASH, BANG, CIRCUMFLEX, COLON, COMMA, DOLLAR, DOUBLE_QUOTE, EQUALS, GREATER, HASH, LEFT_BRACE, LEFT_BRACKET, LEFT_PAREN, LESS, MINUS, MULTIPLY, PERCENT, PERIOD, PLUS, QUOTE, RIGHT_BRACE, RIGHT_BRACKET, RIGHT_PAREN, SEMICOLON, SLASH, SPACE, TILDE, QUESTION_MARK, UNDERSCORE, VERTICAL_BAR, ALT, CONTROL, CAPS_LOCK, SHIFT, META, DOWN_1, END, HOME, LEFT_2, PAGE_UP, PAGE_DOWN, RIGHT_2, UP_1, BACKSPACE, DELETE, ENTER, INSERT, TAB, ESCAPE, PAUSE, PRINT_SCREEN, SCROLL_LOCK, WINDOWS, MEDIA_CLOSE, MEDIA_EJECT, MEDIA_FAST_FORWARD, MEDIA_NEXT, MEDIA_PAUSE, MEDIA_PLAY, MEDIA_PLAY_PAUSE, MEDIA_PREVIOUS, MEDIA_RECORD, MEDIA_REWIND, MEDIA_STOP, BLUE, GREEN, RED, YELLOW_0, APP_SWITCH, AVR_INPUT, AVR_POWER, BACK, BOOKMARK, BREAK, BUTTON_1, BUTTON_2, BUTTON_3, BUTTON_4, BUTTON_5, BUTTON_6, BUTTON_7, BUTTON_8, BUTTON_9, BUTTON_10, BUTTON_11, BUTTON_12, BUTTON_13, BUTTON_14, BUTTON_15, BUTTON_16, BUTTON_A, BUTTON_B, BUTTON_C, BUTTON_L1, BUTTON_L2, BUTTON_MODE, BUTTON_R1, BUTTON_R2, BUTTON_SELECT, BUTTON_START, BUTTON_THUMBL, BUTTON_THUMBR, BUTTON_X, BUTTON_Y, BUTTON_Z, CALL, CAMERA, CAPTIONS, CHANNEL_DOWN, CHANNEL_UP, CLEAR, DPAD_CENTER, DPAD_DOWN, DPAD_LEFT, DPAD_RIGHT, DPAD_UP, DVR, ENDCALL, ENVELOPE, EXPLORER, FOCUS, FORWARD, FORWARD_DEL, FUNCTION, GUIDE, HEADSETHOOK, INFO, MENU, MUTE, NOTIFICATION, NUM, PICTSYMBOLS, POWER, SEARCH, SETTINGS, SOFT_LEFT, SOFT_RIGHT, STAR, STB_INPUT, STB_POWER, SWITCH_CHARSET, SYM, SYSRQ, TV, TV_INPUT, TV_POWER, VOLUME_DOWN, VOLUME_MUTE, VOLUME_UP, WINDOW, ZOOM_IN, ZOOM_OUT, UNKNOWN]);
}

function Key_2(enum$name, enum$ordinal){
  Enum_0.call(this, enum$name, enum$ordinal);
}

function values_28(){
  $clinit_Key();
  return $VALUES_27;
}

defineSeed(656, 11, makeCastMap([Q$Serializable, Q$Comparable, Q$Enum, Q$Key_0]), Key_2);
var $VALUES_27, A_0, ALT, AMPERSAND, APP_SWITCH, ASTERISK, AT, AVR_INPUT, AVR_POWER, B_0, BACK, BACKQUOTE, BACKSLASH, BACKSPACE, BANG, BLUE, BOOKMARK, BREAK, BUTTON_1, BUTTON_10, BUTTON_11, BUTTON_12, BUTTON_13, BUTTON_14, BUTTON_15, BUTTON_16, BUTTON_2, BUTTON_3, BUTTON_4, BUTTON_5, BUTTON_6, BUTTON_7, BUTTON_8, BUTTON_9, BUTTON_A, BUTTON_B, BUTTON_C, BUTTON_L1, BUTTON_L2, BUTTON_MODE, BUTTON_R1, BUTTON_R2, BUTTON_SELECT, BUTTON_START, BUTTON_THUMBL, BUTTON_THUMBR, BUTTON_X, BUTTON_Y, BUTTON_Z, C_0, CALL, CAMERA, CAPS_LOCK, CAPTIONS, CHANNEL_DOWN, CHANNEL_UP, CIRCUMFLEX, CLEAR, COLON, COMMA, CONTROL, D, DELETE, DOLLAR, DOUBLE_QUOTE, DOWN_1, DPAD_CENTER, DPAD_DOWN, DPAD_LEFT, DPAD_RIGHT, DPAD_UP, DVR, E, END, ENDCALL, ENTER, ENVELOPE, EQUALS, ESCAPE, EXPLORER, F, F1, F10, F11, F12, F2, F3, F4, F5, F6, F7, F8, F9, FOCUS, FORWARD, FORWARD_DEL, FUNCTION, G, GREATER, GREEN, GUIDE, H, HASH, HEADSETHOOK, HOME, I, INFO, INSERT, J, K_0, K0, K1_0, K2_0, K3_0, K4, K5, K6, K7, K8, K9, L, LEFT_2, LEFT_BRACE, LEFT_BRACKET, LEFT_PAREN, LESS, M, MEDIA_CLOSE, MEDIA_EJECT, MEDIA_FAST_FORWARD, MEDIA_NEXT, MEDIA_PAUSE, MEDIA_PLAY, MEDIA_PLAY_PAUSE, MEDIA_PREVIOUS, MEDIA_RECORD, MEDIA_REWIND, MEDIA_STOP, MENU, META, MINUS, MULTIPLY, MUTE, N, NOTIFICATION, NP0, NP1, NP2, NP3, NP4, NP5, NP6, NP7, NP8, NP9, NP_ADD, NP_DECIMAL, NP_DELETE, NP_DIVIDE, NP_DOWN, NP_LEFT, NP_MULTIPLY, NP_NUM_LOCK, NP_RIGHT, NP_SUBTRACT, NP_UP, NUM, O, P, PAGE_DOWN, PAGE_UP, PAUSE, PERCENT, PERIOD, PICTSYMBOLS, PLUS, POWER, PRINT_SCREEN, Q, QUESTION_MARK, QUOTE, R_0, RED, RIGHT_2, RIGHT_BRACE, RIGHT_BRACKET, RIGHT_PAREN, S, SCROLL_LOCK, SEARCH, SEMICOLON, SETTINGS, SHIFT, SLASH, SOFT_LEFT, SOFT_RIGHT, SPACE, STAR, STB_INPUT, STB_POWER, SWITCH_CHARSET, SYM, SYSRQ, T, TAB, TILDE, TV, TV_INPUT, TV_POWER, U, UNDERSCORE, UNKNOWN, UP_1, V, VERTICAL_BAR, VOLUME_DOWN, VOLUME_MUTE, VOLUME_UP, W, WINDOW, WINDOWS, X, Y, YELLOW_0, Z, ZOOM_IN, ZOOM_OUT;
function Keyboard$Event$Impl_0(flags, time, key){
  Events$Input$Impl_0.call(this, flags, time);
  this.key_0 = key;
}

defineSeed(657, 652, makeCastMap([Q$Events$Input, Q$Events$Input$Impl]), Keyboard$Event$Impl_0);
--></script>
<script><!--
_.addFields = function addFields_1(builder){
  $append_11($append_12($append_7((builder.impl.string += 'time=' , builder), this.time), ', flags='), this.flags);
  $append_11((builder.impl.string += ', key=' , builder), this.key_0);
}
;
_.name_1 = function name_3(){
  return 'Keyboard.Event';
}
;
_.key_0 = null;
function Keyboard$TypedEvent$Impl_0(flags, time, typedChar){
  Events$Input$Impl_0.call(this, flags, time);
  this.typedChar = typedChar;
}

defineSeed(658, 652, makeCastMap([Q$Events$Input, Q$Events$Input$Impl]), Keyboard$TypedEvent$Impl_0);
_.addFields = function addFields_2(builder){
  $append_11($append_12($append_7((builder.impl.string += 'time=' , builder), this.time), ', flags='), this.flags);
  $append_6((builder.impl.string += ', typedChar=' , builder), this.typedChar);
}
;
_.name_1 = function name_4(){
  return 'Keyboard.TypedEvent';
}
;
_.typedChar = 0;
function screenToLayer(layer, point, into){
  var cur, parent_0;
  parent_0 = layer.parent_1();
  cur = !parent_0?point:screenToLayer(parent_0, point, into);
  return layer.transform_1().inverseTransform(cur, into) , into.x += layer.originX_0() , into.y += layer.originY_0() , into;
}

function $clinit_Log$Level(){
  $clinit_Log$Level = nullMethod;
  DEBUG = new Log$Level_0('DEBUG', 0);
  INFO_0 = new Log$Level_0('INFO', 1);
  WARN = new Log$Level_0('WARN', 2);
  ERROR = new Log$Level_0('ERROR', 3);
  $VALUES_28 = initValues(_3Lplayn_core_Log$Level_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Log$Level, [DEBUG, INFO_0, WARN, ERROR]);
}

function Log$Level_0(enum$name, enum$ordinal){
  Enum_0.call(this, enum$name, enum$ordinal);
}

function values_29(){
  $clinit_Log$Level();
  return $VALUES_28;
}

defineSeed(660, 11, makeCastMap([Q$Serializable, Q$Comparable, Q$Enum, Q$Log$Level]), Log$Level_0);
var $VALUES_28, DEBUG, ERROR, INFO_0, WARN;
function $debug(this$static, msg){
  $log(this$static, ($clinit_Log$Level() , DEBUG), msg, null);
}

function $error(this$static, msg){
  $log(this$static, ($clinit_Log$Level() , ERROR), msg, null);
}

function $error_0(this$static, msg, e){
  $log(this$static, ($clinit_Log$Level() , ERROR), msg, e);
}

function $info(this$static, msg){
  $log(this$static, ($clinit_Log$Level() , INFO_0), msg, null);
}

function $log(this$static, level, msg, e){
  var lmsg;
  level.ordinal >= this$static.minLevel.ordinal && (lmsg = level + ': ' + msg , !!e && $printStackTrace(e) , $wnd.console && $wnd.console.info && (e != null?$wnd.console.info(lmsg, e):$wnd.console.info(lmsg)) , undefined);
}

function $warn(this$static, msg){
  $log(this$static, ($clinit_Log$Level() , WARN), msg, null);
}

function $warn_0(this$static, msg, e){
  $log(this$static, ($clinit_Log$Level() , WARN), msg, e);
}

defineSeed(661, 1, {});
function Mouse$ButtonEvent$Impl_0(flags, time, x, y, button){
  Events$Position$Impl_0.call(this, null, flags, time, x, y);
  this.button_0 = button;
}

function Mouse$ButtonEvent$Impl_1(hit, flags, time, x, y, button){
  Events$Position$Impl_0.call(this, hit, flags, time, x, y);
  this.button_0 = button;
}

defineSeed(662, 653, makeCastMap([Q$Events$Input, Q$Events$Input$Impl, Q$Events$Position, Q$Events$Position$Impl]), Mouse$ButtonEvent$Impl_0, Mouse$ButtonEvent$Impl_1);
_.addFields = function addFields_3(builder){
  $append_11($append_12($append_7((builder.impl.string += 'time=' , builder), this.time), ', flags='), this.flags);
  $append_11($append_12($append_8($append_12($append_8((builder.impl.string += ', x=' , builder), this.x), ', y='), this.y), ', hit='), this.hit);
  $append_9((builder.impl.string += ', button=' , builder), this.button_0);
}
;
_.localize = function localize(hit){
  return new Mouse$ButtonEvent$Impl_1(hit, this.flags, this.time, this.x, this.y, this.button_0);
}
;
_.name_1 = function name_5(){
  return 'ButtonEvent';
}
;
_.button_0 = 0;
function Mouse$MotionEvent$Impl_0(flags, time, x, y, dx, dy){
  Events$Position$Impl_0.call(this, null, flags, time, x, y);
  this.dx = dx;
  this.dy = dy;
}

function Mouse$MotionEvent$Impl_1(hit, flags, time, x, y, dx, dy){
  Events$Position$Impl_0.call(this, hit, flags, time, x, y);
  this.dx = dx;
  this.dy = dy;
}

defineSeed(663, 653, makeCastMap([Q$Events$Input, Q$Events$Input$Impl, Q$Events$Position, Q$Events$Position$Impl]), Mouse$MotionEvent$Impl_0, Mouse$MotionEvent$Impl_1);
_.localize = function localize_0(hit){
  return new Mouse$MotionEvent$Impl_1(hit, this.flags, this.time, this.x, this.y, this.dx, this.dy);
}
;
_.name_1 = function name_6(){
  return 'MotionEvent';
}
;
_.dx = 0;
_.dy = 0;
function Mouse$WheelEvent$Impl_0(flags, time, x, y, velocity){
  Events$Position$Impl_0.call(this, null, flags, time, x, y);
  this.velocity = velocity;
}

function Mouse$WheelEvent$Impl_1(hit, flags, time, x, y, velocity){
  Events$Position$Impl_0.call(this, hit, flags, time, x, y);
  this.velocity = velocity;
}

defineSeed(664, 653, makeCastMap([Q$Events$Input, Q$Events$Input$Impl, Q$Events$Position, Q$Events$Position$Impl]), Mouse$WheelEvent$Impl_0, Mouse$WheelEvent$Impl_1);
_.addFields = function addFields_4(builder){
  $append_11($append_12($append_7((builder.impl.string += 'time=' , builder), this.time), ', flags='), this.flags);
  $append_11($append_12($append_8($append_12($append_8((builder.impl.string += ', x=' , builder), this.x), ', y='), this.y), ', hit='), this.hit);
  $append_8((builder.impl.string += ', velocity=' , builder), this.velocity);
}
;
_.localize = function localize_1(hit){
  return new Mouse$WheelEvent$Impl_1(hit, this.flags, this.time, this.x, this.y, this.velocity);
}
;
_.name_1 = function name_7(){
  return 'WheelEvent';
}
;
_.velocity = 0;
function $onMouseDown_0(this$static, event_0){
  var p, root;
  event_0.flags.preventDefault_0 = false;
  !!this$static.listener && $onMouseDown(this$static.listener, event_0);
  root = platform_1.graphics.rootLayer_0();
  if (root.interactive()) {
    p = new Point_1(event_0.x, event_0.y);
    root.transform_1().inverseTransform(p, p);
    p.x += root.originX_0();
    p.y += root.originY_0();
    this$static.activeLayer = root.hitTest(p);
    !!this$static.activeLayer && $dispatch_0(this$static.activeLayer, event_0, this$static.DOWN);
  }
  return event_0.flags.preventDefault_0;
}

function $onMouseMove_1(this$static, event_0){
  var lastHoverLayer, p, root;
  event_0.flags.preventDefault_0 = false;
  !!this$static.listener && $onMouseMove(this$static.listener, event_0);
  root = platform_1.graphics.rootLayer_0();
  if (root.interactive()) {
    p = new Point_1(event_0.x, event_0.y);
    root.transform_1().inverseTransform(p, p);
    p.x += root.originX_0();
    p.y += root.originY_0();
    lastHoverLayer = this$static.hoverLayer;
    this$static.hoverLayer = root.hitTest(p);
    this$static.activeLayer?$dispatch_0(this$static.activeLayer, event_0, this$static.DRAG):!!this$static.hoverLayer && $dispatch_0(this$static.hoverLayer, event_0, this$static.MOVE);
    lastHoverLayer != this$static.hoverLayer && !!lastHoverLayer && $dispatch_0(lastHoverLayer, event_0, this$static.OUT);
    this$static.hoverLayer != lastHoverLayer && !!this$static.hoverLayer && $dispatch_0(this$static.hoverLayer, event_0, this$static.OVER);
  }
  return event_0.flags.preventDefault_0;
}

function $onMouseUp_0(this$static, event_0){
  event_0.flags.preventDefault_0 = false;
  !!this$static.listener && $onMouseUp(this$static.listener, event_0);
  if (this$static.activeLayer) {
    $dispatch_0(this$static.activeLayer, event_0, this$static.UP);
    this$static.activeLayer = null;
  }
  return event_0.flags.preventDefault_0;
}

function $onMouseWheelScroll(this$static, event_0){
  var target;
  target = this$static.activeLayer?this$static.activeLayer:this$static.hoverLayer;
  !!target && $dispatch_0(target, event_0, this$static.WHEEL_SCROLL);
  return event_0.flags.preventDefault_0;
}

function $setListener(this$static, listener){
  this$static.listener = listener;
}

defineSeed(665, 1, {});
_.activeLayer = null;
_.hoverLayer = null;
_.listener = null;
function MouseImpl$1_0(){
}

defineSeed(666, 1, {}, MouseImpl$1_0);
function MouseImpl$2_0(){
}

defineSeed(667, 1, {}, MouseImpl$2_0);
function MouseImpl$3_0(){
}

defineSeed(668, 1, {}, MouseImpl$3_0);
function MouseImpl$4_0(){
}

defineSeed(669, 1, {}, MouseImpl$4_0);
function MouseImpl$5_0(){
}

defineSeed(670, 1, {}, MouseImpl$5_0);
function MouseImpl$6_0(){
}

defineSeed(671, 1, {}, MouseImpl$6_0);
function MouseImpl$7_0(){
}

defineSeed(672, 1, {}, MouseImpl$7_0);
function run_1(game){
  $run(platform_1, game);
}

var platform_1 = null;
function Pointer$Event$Impl_0(flags, time, x, y, isTouch){
  Pointer$Event$Impl_1.call(this, null, flags, time, x, y, isTouch);
}

function Pointer$Event$Impl_1(hit, flags, time, x, y, isTouch){
  Events$Position$Impl_0.call(this, hit, flags, time, x, y);
  this.isTouch = isTouch;
}

defineSeed(674, 653, makeCastMap([Q$Events$Input, Q$Events$Input$Impl, Q$Events$Position, Q$Events$Position$Impl]), Pointer$Event$Impl_0, Pointer$Event$Impl_1);
_.localize = function localize_2(hit){
  var impl;
  return impl = new Pointer$Event$Impl_1(hit, this.flags, this.time, this.x, this.y, this.isTouch) , impl.captureState = this.captureState , impl;
}
;
_.name_1 = function name_8(){
  return 'Pointer.Event';
}
;
_.isTouch = false;
function $onPointerDrag_0(this$static, event_0, preventDefault){
  $setPreventDefault(event_0.flags, preventDefault);
  !!this$static.listener && $onPointerDrag(this$static.listener, event_0);
  if (this$static.active.layer) {
    event_0.captureState = this$static.active;
    $dispatch(event_0, this$static.DRAG);
  }
  return event_0.flags.preventDefault_0;
}

function $onPointerEnd_0(this$static, event_0, preventDefault){
  $setPreventDefault(event_0.flags, preventDefault);
  !!this$static.listener && $onPointerEnd(this$static.listener, event_0);
  if (this$static.active.layer) {
    event_0.captureState = this$static.active;
    $dispatch(event_0, this$static.END);
    this$static.active.layer = null;
  }
  return event_0.flags.preventDefault_0;
}

function $onPointerStart_0(this$static, event_0){
  var p, root;
  event_0.flags.preventDefault_0 = true;
  !!this$static.listener && $onPointerStart(this$static.listener, event_0);
  root = platform_1.graphics.rootLayer_0();
  if (root.interactive()) {
    p = new Point_1(event_0.x, event_0.y);
    root.transform_1().inverseTransform(p, p);
    p.x += root.originX_0();
    p.y += root.originY_0();
    this$static.active.layer = root.hitTest(p);
    if (this$static.active.layer) {
      event_0.captureState = this$static.active;
      $dispatch(event_0, this$static.START);
    }
  }
  return event_0.flags.preventDefault_0;
}

function $setListener_0(this$static, listener){
  this$static.listener = listener;
}

defineSeed(675, 1, {});
_.listener = null;
function PointerImpl$1_0(){
}

defineSeed(676, 1, {}, PointerImpl$1_0);
function PointerImpl$2_0(){
}

defineSeed(677, 1, {}, PointerImpl$2_0);
function PointerImpl$3_0(){
}

defineSeed(678, 1, {}, PointerImpl$3_0);
function $scale_1(this$static, scaleX, scaleY){
  this$static.scaleX(scaleX);
  this$static.scaleY(scaleY);
  return this$static;
}

defineSeed(681, 1, {});
_.scale_2 = function scale_2(scaleX, scaleY){
  return $scale_1(this, scaleX, scaleY);
}
;
_.scaleX = function scaleX_0(scaleX){
  throw new UnsupportedOperationException_0;
}
;
_.scaleY = function scaleY_0(scaleY){
  throw new UnsupportedOperationException_0;
}
;
_.setTransform = function setTransform(m00, m01, m10, m11, tx, ty){
  throw new UnsupportedOperationException_0;
}
;
_.translate_1 = function translate(tx, ty){
  this.translateX(tx);
  this.translateY(ty);
  return this;
}
;
_.translateX = function translateX(tx){
  throw new UnsupportedOperationException_0;
}
;
_.translateY = function translateY(ty){
  throw new UnsupportedOperationException_0;
}
;
_.uniformScale = function uniformScale(scale){
  throw new UnsupportedOperationException_0;
}
;
function $setTransform(this$static, m00, m01, m10, m11, tx, ty){
  this$static.m00 = m00;
  this$static.m01 = m01;
  this$static.m10 = m10;
  this$static.m11 = m11;
  this$static.tx = tx;
  this$static.ty = ty;
  return this$static;
}

defineSeed(680, 681, {});
_.inverseTransform = function inverseTransform(p, into){
  var det, rdet, x, y;
  x = p.x - this.tx;
  y = p.y - this.ty;
  det = this.m00 * this.m11 - this.m01 * this.m10;
  if (abs(det) == 0) {
    throw new NoninvertibleTransformException_0('affine [' + toString_61(this.m00) + ' ' + toString_61(this.m01) + ' ' + toString_61(this.m10) + ' ' + toString_61(this.m11) + ' ' + new Vector_0(this.tx, this.ty) + ']');
  }
  rdet = 1 / det;
  return $set_9(into, (x * this.m11 - y * this.m10) * rdet, (y * this.m00 - x * this.m01) * rdet);
}
;
_.scale_2 = function scale_3(scaleX, scaleY){
  return multiply_1(this.m00, this.m01, this.m10, this.m11, this.tx, this.ty, scaleX, 0, 0, scaleY, 0, 0, this);
}
;
_.scaleX = function scaleX_1(scaleX){
  return multiply_1(this.m00, this.m01, this.m10, this.m11, this.tx, this.ty, scaleX, 0, 0, 1, 0, 0, this);
}
;
_.scaleY = function scaleY_1(scaleY){
  return multiply_1(this.m00, this.m01, this.m10, this.m11, this.tx, this.ty, 1, 0, 0, scaleY, 0, 0, this);
}
;
_.setTransform = function setTransform_0(m00, m01, m10, m11, tx, ty){
  return $setTransform(this, m00, m01, m10, m11, tx, ty);
}
;
_.toString$ = function toString_48(){
  return 'affine [' + toString_61(this.m00) + ' ' + toString_61(this.m01) + ' ' + toString_61(this.m10) + ' ' + toString_61(this.m11) + ' ' + new Vector_0(this.tx, this.ty) + ']';
}
;
_.translate_1 = function translate_0(tx, ty){
  return multiply_1(this.m00, this.m01, this.m10, this.m11, this.tx, this.ty, 1, 0, 0, 1, tx, ty, this);
}
;
_.translateX = function translateX_0(tx){
  return multiply_1(this.m00, this.m01, this.m10, this.m11, this.tx, this.ty, 1, 0, 0, 1, tx, 0, this);
}
;
_.translateY = function translateY_0(ty){
  return multiply_1(this.m00, this.m01, this.m10, this.m11, this.tx, this.ty, 1, 0, 0, 1, 0, ty, this);
}
;
_.tx_0 = function tx_0(){
  return this.tx;
}
;
_.ty_0 = function ty_0(){
  return this.ty;
}
;
_.uniformScale = function uniformScale_0(scale){
  return multiply_1(this.m00, this.m01, this.m10, this.m11, this.tx, this.ty, scale, 0, 0, scale, 0, 0, this);
}
;
_.m00 = 0;
_.m01 = 0;
_.m10 = 0;
_.m11 = 0;
_.tx = 0;
_.ty = 0;
function $clinit_StockInternalTransform(){
  $clinit_StockInternalTransform = nullMethod;
  new StockInternalTransform_0;
}

function StockInternalTransform_0(){
  $clinit_StockInternalTransform();
  this.m00 = 1;
  this.m01 = 0;
  this.m10 = 0;
  this.m11 = 1;
  this.tx = 0;
  this.ty = 0;
}

defineSeed(679, 680, {}, StockInternalTransform_0);
_.concatenate = function concatenate(m00, m01, m10, m11, tx, ty, originX, originY){
  return multiply_1(this.m00, this.m01, this.m10, this.m11, this.tx, this.ty, m00, m01, m10, m11, tx, ty, this) , (originX != 0 || originY != 0) && multiply_1(this.m00, this.m01, this.m10, this.m11, this.tx, this.ty, 1, 0, 0, 1, -originX, -originY, this) , this;
}
;
_.m00_0 = function m00_0(){
  return this.m00;
}
;
_.m01_0 = function m01_0(){
  return this.m01;
}
;
_.m10_0 = function m10_0(){
  return this.m10;
}
;
_.m11_0 = function m11_0(){
  return this.m11;
}
;
_.set_1 = function set_0(other){
  $setTransform(this, null.nullField, null.nullField, null.nullField, null.nullField, null.nullField, null.nullField);
  return this;
}
;
function TextFormat_0(font){
  this.font_0 = font;
  this.wrapWidth = 3.4028234663852886E38;
  this.align = ($clinit_TextFormat$Alignment() , LEFT_3);
  this.antialias_0 = true;
}

defineSeed(682, 1, makeCastMap([Q$TextFormat]), TextFormat_0);
_.equals$ = function equals_31(other){
  var ofmt;
  if (instanceOf(other, Q$TextFormat)) {
    ofmt = other;
    return (this.font_0 == ofmt.font_0 || !!this.font_0 && $equals_2(this.font_0, ofmt.font_0)) && this.wrapWidth == ofmt.wrapWidth && this.align == ofmt.align && this.antialias_0 == ofmt.antialias_0;
  }
   else {
    return false;
  }
}
;
_.hashCode$ = function hashCode_30(){
  var hash;
  hash = getHashCode(this.align) ^ round_int(this.wrapWidth) ^ (this.antialias_0?1:0);
  !!this.font_0 && (hash ^= $hashCode_0(this.font_0));
  return hash;
}
;
_.toString$ = function toString_49(){
  return '[font=' + this.font_0 + ', antialias=' + this.antialias_0 + ']';
}
;
_.align = null;
_.antialias_0 = false;
_.font_0 = null;
_.wrapWidth = 0;
function $clinit_TextFormat$Alignment(){
  $clinit_TextFormat$Alignment = nullMethod;
  LEFT_3 = new TextFormat$Alignment$1_0;
  CENTER = new TextFormat$Alignment$2_0;
  RIGHT_3 = new TextFormat$Alignment$3_0;
  $VALUES_29 = initValues(_3Lplayn_core_TextFormat$Alignment_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$TextFormat$Alignment, [LEFT_3, CENTER, RIGHT_3]);
}

function values_30(){
  $clinit_TextFormat$Alignment();
  return $VALUES_29;
}

defineSeed(683, 11, makeCastMap([Q$Serializable, Q$Comparable, Q$Enum, Q$TextFormat$Alignment]));
var $VALUES_29, CENTER, LEFT_3, RIGHT_3;
function TextFormat$Alignment$1_0(){
  Enum_0.call(this, 'LEFT', 0);
}

defineSeed(684, 683, makeCastMap([Q$Serializable, Q$Comparable, Q$Enum, Q$TextFormat$Alignment]), TextFormat$Alignment$1_0);
function TextFormat$Alignment$2_0(){
  Enum_0.call(this, 'CENTER', 1);
}

defineSeed(685, 683, makeCastMap([Q$Serializable, Q$Comparable, Q$Enum, Q$TextFormat$Alignment]), TextFormat$Alignment$2_0);
function TextFormat$Alignment$3_0(){
  Enum_0.call(this, 'RIGHT', 2);
}

defineSeed(686, 683, makeCastMap([Q$Serializable, Q$Comparable, Q$Enum, Q$TextFormat$Alignment]), TextFormat$Alignment$3_0);
function combine(curTint, tint){
  var newA, newB, newG, newR;
  newA = ((~~curTint >> 24 & 255) * ((~~tint >> 24 & 255) + 1) & 65280) << 16;
  if ((tint & 16777215) == 16777215) {
    return newA | curTint & 16777215;
  }
  newR = ((~~curTint >> 16 & 255) * ((~~tint >> 16 & 255) + 1) & 65280) << 8;
  newG = (~~curTint >> 8 & 255) * ((~~tint >> 8 & 255) + 1) & 65280;
  newB = ~~((curTint & 255) * ((tint & 255) + 1)) >> 8 & 255;
  return newA | newR | newG | newB;
}

function Touch$Event$Impl_0(flags, time, x, y, id){
  Touch$Event$Impl_1.call(this, null, flags, time, x, y, id, -1, -1);
}

function Touch$Event$Impl_1(hit, flags, time, x, y, id, pressure, size){
  Events$Position$Impl_0.call(this, hit, flags, time, x, y);
  this.id_0 = id;
  this.pressure = pressure;
  this.size = size;
}

defineSeed(688, 653, makeCastMap([Q$Events$Input, Q$Events$Input$Impl, Q$Events$Position, Q$Events$Position$Impl, Q$Touch$Event, Q$Touch$Event$Impl]), Touch$Event$Impl_0, Touch$Event$Impl_1);
_.addFields = function addFields_5(builder){
  $append_11($append_12($append_7((builder.impl.string += 'time=' , builder), this.time), ', flags='), this.flags);
  $append_11($append_12($append_8($append_12($append_8((builder.impl.string += ', x=' , builder), this.x), ', y='), this.y), ', hit='), this.hit);
  $append_8($append_12($append_8($append_12($append_9((builder.impl.string += ', id=' , builder), this.id_0), ', pressure='), this.pressure), ', size='), this.size);
}
;
_.localize = function localize_3(hit){
  return new Touch$Event$Impl_1(hit, this.flags, this.time, this.x, this.y, this.id_0, this.pressure, this.size);
}
;
_.name_1 = function name_9(){
  return 'Touch.Event';
}
;
_.id_0 = 0;
_.pressure = 0;
_.size = 0;
function $clinit_TouchImpl(){
  $clinit_TouchImpl = nullMethod;
  START = new TouchImpl$1_0;
  MOVE = new TouchImpl$2_0;
  END_0 = new TouchImpl$3_0;
}

function $onTouchEnd(this$static, touches){
  var activeLayer, event_0, event$index, event$max;
  for (event$index = 0 , event$max = touches.length; event$index < event$max; ++event$index) {
    event_0 = touches[event$index];
    activeLayer = this$static.activeLayers.get_1(valueOf_3(event_0.id_0));
    if (activeLayer) {
      $dispatch_0(activeLayer, event_0, END_0);
      this$static.activeLayers.remove_1(valueOf_3(event_0.id_0));
    }
  }
}

function $onTouchMove(this$static, touches){
  var activeLayer, event_0, event$index, event$max;
  for (event$index = 0 , event$max = touches.length; event$index < event$max; ++event$index) {
    event_0 = touches[event$index];
    activeLayer = this$static.activeLayers.get_1(valueOf_3(event_0.id_0));
    !!activeLayer && $dispatch_0(activeLayer, event_0, MOVE);
  }
}

function $onTouchStart(this$static, touches){
  var event_0, event$index, event$max, hitLayer, p, root;
  root = platform_1.graphics.rootLayer_0();
  if (root.interactive()) {
    for (event$index = 0 , event$max = touches.length; event$index < event$max; ++event$index) {
      event_0 = touches[event$index];
      p = new Point_1(event_0.x, event_0.y);
      root.transform_1().inverseTransform(p, p);
      p.x += root.originX_0();
      p.y += root.originY_0();
      hitLayer = root.hitTest(p);
      if (hitLayer) {
        this$static.activeLayers.put(valueOf_3(event_0.id_0), hitLayer);
        $dispatch_0(hitLayer, event_0, START);
      }
    }
  }
}

defineSeed(689, 1, {});
var END_0, MOVE, START;
function TouchImpl$1_0(){
}

defineSeed(690, 1, {}, TouchImpl$1_0);
function TouchImpl$2_0(){
}

defineSeed(691, 1, {}, TouchImpl$2_0);
function TouchImpl$3_0(){
}

defineSeed(692, 1, {}, TouchImpl$3_0);
function $fillTriangles(this$static, xys, indices){
  var a, b, c, ii, path;
  path = this$static.canvas.createPath();
  for (ii = 0; ii < indices.length; ii += 3) {
    a = 2 * indices[ii];
    b = 2 * indices[ii + 1];
    c = 2 * indices[ii + 2];
    $push_1(path.list, 0);
    $push_1(path.list, xys[a]);
    $push_1(path.list, xys[a + 1]);
    $lineTo_0(path, xys[b], xys[b + 1]);
    $lineTo_0(path, xys[c], xys[c + 1]);
    $push_1(path.list, 4);
  }
  this$static.canvas.fillPath(path);
  return this$static;
}

function CanvasSurface_0(){
  this.canvas = null;
}

defineSeed(693, 1, {}, CanvasSurface_0);
_.clear_2 = function clear_1(){
  this.canvas.clear_1();
  return this;
}
;
_.drawImage_3 = function drawImage(image, dx, dy){
  this.canvas.drawImage_0(image, dx, dy);
  return this;
}
;
_.drawImage_4 = function drawImage_0(image, dx, dy, dw, dh){
  this.canvas.drawImage_1(image, dx, dy, dw, dh);
  return this;
}
;
_.drawImage_5 = function drawImage_1(image, dx, dy, dw, dh, sx, sy, sw, sh){
  this.canvas.drawImage_2(image, dx, dy, dw, dh, sx, sy, sw, sh);
  return this;
}
;
_.drawLine_0 = function drawLine(x0, y0, x1, y1, width){
  this.canvas.save_0();
  this.canvas.setStrokeWidth(width);
  this.canvas.drawLine(x0, y0, x1, y1);
  this.canvas.restore_0();
  return this;
}
;
_.fillRect_1 = function fillRect(x, y, width, height){
  this.canvas.fillRect_0(x, y, width, height);
  return this;
}
;
_.fillTriangles = function fillTriangles(xys, sxys, indices){
  return $fillTriangles(this, xys, indices);
}
;
_.height_1 = function height_1(){
  return this.canvas.height_1();
}
;
_.restore_1 = function restore_0(){
  this.canvas.restore_0();
  return this;
}
;
_.rotate_1 = function rotate(radians){
  this.canvas.rotate_0(radians);
  return this;
}
;
_.save_1 = function save_0(){
  this.canvas.save_0();
  return this;
}
;
_.scale_3 = function scale_4(sx, sy){
  this.canvas.scale_1(sx, sy);
  return this;
}
;
_.setAlpha_0 = function setAlpha(alpha){
  this.canvas.setAlpha(alpha);
  return this;
}
;
_.setFillColor_0 = function setFillColor(color){
  this.canvas.setFillColor(color);
  this.canvas.setStrokeColor(color);
  return this;
}
;
_.setFillPattern_0 = function setFillPattern(pattern){
  this.canvas.setFillPattern(pattern);
  return this;
}
;
_.setTint = function setTint(tint){
  return this;
}
;
_.translate_2 = function translate_1(x, y){
  this.canvas.translate_0(x, y);
  return this;
}
;
_.width_1 = function width_1(){
  return this.canvas.width_1();
}
;
_.canvas = null;
function $transform_1(this$static, canvas){
  var transform;
  canvas.translate_0(this$static.originX, this$static.originY);
  transform = $transform_0(this$static);
  canvas.transform_2(transform.m00_0(), transform.m01_0(), transform.m10_0(), transform.m11_0(), transform.tx_0() - this$static.originX, transform.ty_0() - this$static.originY);
  canvas.translate_0(-this$static.originX, -this$static.originY);
}

function LayerCanvas_0(xform){
  AbstractLayer_0.call(this, xform);
}

defineSeed(695, 641, {});
function $paint(this$static, canvas, parentAlpha){
  if (!$isSet(this$static, ($clinit_AbstractLayer$Flag() , VISIBLE_1)))
    return;
  canvas.save_0();
  $transform_1(this$static, canvas);
  $paintChildren(this$static, canvas, parentAlpha);
  canvas.restore_0();
}

function $paintChildren(this$static, canvas, alpha){
  var child, child$iterator;
  for (child$iterator = new AbstractList$IteratorImpl_0(this$static.impl.children); child$iterator.i < child$iterator.this$0_0.size_0();) {
    child = $next_2(child$iterator);
    child.paint(canvas, alpha);
  }
}

function GroupLayerCanvas_0(xform){
  LayerCanvas_0.call(this, xform);
  this.impl = new GroupLayerImpl_0;
}

defineSeed(694, 695, {}, GroupLayerCanvas_0);
_.add_1 = function add_11(layer){
  $add_19(this.impl, this, layer);
}
;
_.hitTestDefault = function hitTestDefault_0(p){
  return $hitTest(this.impl, this, p);
}
;
_.onAdd = function onAdd_0(){
  $onAdd(this);
  $onAdd_0(this.impl);
}
;
_.onRemove = function onRemove_0(){
  $onRemove(this.impl);
}
;
_.paint = function paint(canvas, parentAlpha){
  $paint(this, canvas, parentAlpha);
}
;
_.remove_4 = function remove_32(layer){
  $remove_19(this.impl, layer);
}
;
function ImmediateLayerCanvas_0(xform, renderer){
  LayerCanvas_0.call(this, xform);
  this.surf = new CanvasSurface_0;
  this.renderer = renderer;
}

defineSeed(696, 695, {}, ImmediateLayerCanvas_0);
_.paint = function paint_0(canvas, parentAlpha){
  if (!$isSet(this, ($clinit_AbstractLayer$Flag() , VISIBLE_1)))
    return;
  canvas.save_0();
  $transform_1(this, canvas);
  canvas.setAlpha(parentAlpha);
  this.surf.canvas = canvas;
  $render_0(this.renderer, this.surf);
  this.surf.canvas = null;
  canvas.restore_0();
}
;
_.renderer = null;
function $drawImage_1(this$static, img, x, y, w, h_0){
  var d;
  d = img;
  d.draw_0(this$static.gc(), x, y, w, h_0);
  this$static.isDirty = true;
  return this$static;
}

defineSeed(697, 639, {});
_.drawImage_0 = function drawImage_2(img, x, y){
  return $drawImage_1(this, img, x, y, !img.img?0:$invScaled(img.scale_0, img.img.width), !img.img?0:$invScaled(img.scale_0, img.img.height));
}
;
_.drawImage_1 = function drawImage_3(img, x, y, w, h_0){
  return $drawImage_1(this, img, x, y, w, h_0);
}
;
_.drawImage_2 = function drawImage_4(img, dx, dy, dw, dh, sx, sy, sw, sh){
  var d;
  d = img;
  d.draw_1(this.gc(), dx, dy, dw, dh, sx, sy, sw, sh);
  this.isDirty = true;
  return this;
}
;
_.isDirty = false;
function $draw_2(this$static, shader, xform, tint, dx, dy, dw, dh){
  $draw_3(this$static, shader, xform, tint, dx, dy, dw, dh, 0, 0, this$static.repeatX?dw:this$static.width_1(), this$static.repeatY?dh:this$static.height_1());
}

function $draw_3(this$static, shader, xform, tint, dx, dy, dw, dh, sx, sy, sw, sh){
  var texHeight, texWidth;
  texWidth = this$static.width_1();
  texHeight = this$static.height_1();
  $drawImpl(this$static, shader, xform, this$static.ensureTexture(), tint, dx, dy, dw, dh, sx / texWidth, sy / texHeight, (sx + sw) / texWidth, (sy + sh) / texHeight);
}

function $drawImpl(this$static, shader, xform, tex, tint, dx, dy, dw, dh, sl, st, sr, sb){
  tex > 0 && $addQuad($prepareTexture($quadShader(this$static.ctx, shader), tex, tint), xform, dx, dy, dx + dw, dy + dh, sl, st, sr, sb);
}

function $setRepeat(this$static){
  if (!this$static.repeatX || !this$static.repeatY) {
    this$static.repeatX = true;
    this$static.repeatY = true;
    this$static.clearTexture();
  }
}

defineSeed(698, 1, {});
_.toPattern = function toPattern(){
  return new AbstractImageGL$1_0(this);
}
;
_.ctx = null;
_.mipmapped = false;
_.repeatX = false;
_.repeatY = false;
function AbstractImageGL$1_0(this$0){
  this.this$0 = this$0;
}

defineSeed(699, 1, {}, AbstractImageGL$1_0);
_.image_0 = function image_0(){
  return this.this$0;
}
;
_.this$0 = null;
function $drawImage_2(this$static, image, x, y, dw, dh){
  $draw_2(image, this$static.shader, $get(this$static.transformStack, this$static.transformStack.size - 1), this$static.tint, x, y, dw, dh);
  return this$static;
}

function $setShader(this$static, shader){
  this$static.shader = shader;
  return this$static;
}

function $setTint(this$static, tint){
  this$static.tint = tint;
  return this$static;
}

function $topTransform(this$static){
  return $get(this$static.transformStack, this$static.transformStack.size - 1);
}

defineSeed(700, 1, {});
_.clear_2 = function clear_2(){
  $clear_4(this.ctx);
  return this;
}
;
_.drawImage_3 = function drawImage_5(image, x, y){
  return $drawImage_2(this, image, x, y, !image.img?0:$invScaled(image.scale_0, image.img.width), !image.img?0:$invScaled(image.scale_0, image.img.height));
}
;
_.drawImage_4 = function drawImage_6(image, x, y, dw, dh){
  return $drawImage_2(this, image, x, y, dw, dh);
}
;
_.drawImage_5 = function drawImage_7(image, dx, dy, dw, dh, sx, sy, sw, sh){
  $draw_3(image, this.shader, $get(this.transformStack, this.transformStack.size - 1), this.tint, dx, dy, dw, dh, sx, sy, sw, sh);
  return this;
}
;
--></script>
<script><!--
_.drawLine_0 = function drawLine_0(x0, y0, x1, y1, width){
  var dx, dy, l_0, length_0, shader, temp, tex, wx, wy;
  if (x1 < x0) {
    temp = x0;
    x0 = x1;
    x1 = temp;
    temp = y0;
    y0 = y1;
    y1 = temp;
  }
  dx = x1 - x0;
  dy = y1 - y0;
  length_0 = Math.sqrt(dx * dx + dy * dy);
  wx = dx * (width / 2) / length_0;
  wy = dy * (width / 2) / length_0;
  l_0 = new HtmlInternalTransform_0;
  $setRotation(l_0, Math.atan2(dy, dx));
  l_0.matrix[4] = x0 + wy;
  l_0.matrix[5] = y0 - wx;
  $preConcatenate(l_0, $get(this.transformStack, this.transformStack.size - 1));
  shader = $quadShader(this.ctx, this.shader);
  if (this.fillPattern) {
    tex = this.fillPattern.ensureTexture();
    if (tex > 0) {
      $prepareTexture(shader, tex, this.tint);
      $addQuad(shader, l_0, 0, 0, length_0, width, 0, 0, length_0 / this.fillPattern.width_1(), width / this.fillPattern.height_1());
    }
  }
   else {
    tex = $ensureTexture($fillImage(this.ctx));
    $prepareTexture(shader, tex, combine(this.fillColor, this.tint));
    shader.texCore.addQuad(l_0.matrix[0], l_0.matrix[1], l_0.matrix[2], l_0.matrix[3], l_0.matrix[4], l_0.matrix[5], 0, 0, 0, 0, length_0, 0, 1, 0, 0, width, 0, 1, length_0, width, 1, 1);
    ++shader.ctx.stats.quadsRendered;
  }
  return this;
}
;
_.fillRect_1 = function fillRect_0(x, y, width, height){
  var b, r, shader, tex, th, tw;
  shader = $quadShader(this.ctx, this.shader);
  if (this.fillPattern) {
    tex = this.fillPattern.ensureTexture();
    if (tex > 0) {
      $prepareTexture(shader, tex, this.tint);
      tw = this.fillPattern.width_1();
      th = this.fillPattern.height_1();
      r = x + width;
      b = y + height;
      $addQuad(shader, $get(this.transformStack, this.transformStack.size - 1), x, y, x + width, y + height, x / tw, y / th, r / tw, b / th);
    }
  }
   else {
    tex = $ensureTexture($fillImage(this.ctx));
    $prepareTexture(shader, tex, combine(this.fillColor, this.tint));
    $addQuad(shader, $get(this.transformStack, this.transformStack.size - 1), x, y, x + width, y + height, 0, 0, 1, 1);
  }
  return this;
}
;
_.fillTriangles = function fillTriangles_0(xys, sxys, indices){
  var shader, tex;
  if (!this.fillPattern)
    throw new IllegalStateException_1('No fill pattern currently set');
  tex = this.fillPattern.ensureTexture();
  if (tex > 0) {
    shader = $prepareTexture($trisShader(this.ctx, this.shader), tex, this.tint);
    $addTriangles(shader, $get(this.transformStack, this.transformStack.size - 1), xys, sxys, indices);
  }
  return this;
}
;
_.restore_1 = function restore_1(){
  $remove_0(this.transformStack, this.transformStack.size - 1);
  return this;
}
;
_.rotate_1 = function rotate_0(angle){
  var cr, sr;
  sr = Math.sin(angle);
  cr = Math.cos(angle);
  $get(this.transformStack, this.transformStack.size - 1).concatenate(cr, sr, -sr, cr, 0, 0, 0, 0);
  return this;
}
;
_.save_1 = function save_1(){
  $add_0(this.transformStack, $set_8(new HtmlInternalTransform_0, $get(this.transformStack, this.transformStack.size - 1)));
  return this;
}
;
_.scale_3 = function scale_5(sx, sy){
  $get(this.transformStack, this.transformStack.size - 1).scale_2(sx, sy);
  return this;
}
;
_.setAlpha_0 = function setAlpha_0(alpha){
  var ialpha;
  ialpha = ~~Math.max(Math.min(255 * (alpha < 0?0:alpha > 1?1:alpha), 2147483647), -2147483648);
  this.tint = ialpha << 24 | this.tint & 16777215;
  return this;
}
;
_.setFillColor_0 = function setFillColor_0(color){
  this.fillColor = color;
  this.fillPattern = null;
  return this;
}
;
_.setFillPattern_0 = function setFillPattern_0(pattern){
  this.fillPattern = pattern.image_0();
  $setRepeat(this.fillPattern);
  return this;
}
;
_.setTint = function setTint_0(tint){
  return this.tint = tint , this;
}
;
_.translate_2 = function translate_2(x, y){
  $get(this.transformStack, this.transformStack.size - 1).translate_1(x, y);
  return this;
}
;
_.ctx = null;
_.fillColor = 0;
_.fillPattern = null;
_.shader = null;
_.tint = -1;
function $bind(this$static, target){
  $glBindBuffer(this$static.gl, target, this$static.bufferId);
}

function $destroy(this$static){
  $deleteObjects(this$static.gl, initValues(_3I_classLit, makeCastMap([Q$int_$1, Q$Serializable]), -1, [this$static.bufferId]), ($clinit_HtmlGL20$WebGLObjectType() , BUFFER));
}

function $send(this$static, target, usage){
  var buffer, byteSize, count;
  count = this$static.position_1();
  byteSize = this$static.position_1() * this$static.bytesPerElement();
  this$static.flush();
  buffer = this$static.buffer_1();
  $position(buffer);
  $glBufferData(this$static.gl, target, byteSize, buffer, usage);
  return count;
}

function GL20Buffer_0(gl){
  var ids;
  this.gl = gl;
  this.bufferId = (ids = initDim(_3I_classLit, makeCastMap([Q$int_$1, Q$Serializable]), -1, 1, 1) , $genObjects(gl, ids, ($clinit_HtmlGL20$WebGLObjectType() , BUFFER)) , ids[0]);
}

defineSeed(701, 1, {});
_.bufferId = 0;
_.gl = null;
function $expand_0(this$static, capacity){
  var raw;
  raw = $order(allocateDirect(capacity * 4), ($clinit_ByteOrder() , $clinit_ByteOrder() , NATIVE_ORDER));
  this$static.buffer_0 = new FloatBuffer_0($slice(raw));
  this$static.staging = initDim(_3F_classLit, makeCastMap([Q$Serializable]), -1, capacity, 1);
}

function $flush(this$static){
  $position(this$static.buffer_0);
  $put_2(this$static.buffer_0, this$static.staging, this$static.stagingPos);
  this$static.stagingPos = 0;
}

function $skip(this$static, count){
  this$static.stagingPos += count;
}

function GL20Buffer$FloatImpl_0(gl, capacity){
  GL20Buffer_0.call(this, gl);
  $expand_0(this, capacity);
}

defineSeed(702, 701, {}, GL20Buffer$FloatImpl_0);
_.buffer_1 = function buffer_0(){
  return this.buffer_0;
}
;
_.bytesPerElement = function bytesPerElement(){
  return 4;
}
;
_.flush = function flush(){
  $flush(this);
}
;
_.position_1 = function position_0(){
  return this.stagingPos;
}
;
_.toString$ = function toString_50(){
  return 'floatbuf:' + this.bufferId;
}
;
_.buffer_0 = null;
_.staging = null;
_.stagingPos = 0;
function $add_20(this$static, value){
  this$static.staging[this$static.stagingPos++] = ~~(value << 16) >> 16;
  return this$static;
}

function $add_21(this$static, x, y){
  this$static.staging[this$static.stagingPos++] = ~~(x << 16) >> 16;
  this$static.staging[this$static.stagingPos++] = ~~(y << 16) >> 16;
  return this$static;
}

function $drawElements_0(this$static, count){
  $glDrawElements(this$static.gl, count);
}

function $expand_1(this$static, capacity){
  this$static.buffer_0 = $asShortBuffer($order(allocateDirect(capacity * 2), ($clinit_ByteOrder() , $clinit_ByteOrder() , NATIVE_ORDER)));
  this$static.staging = initDim(_3S_classLit, makeCastMap([Q$Serializable]), -1, capacity, 1);
}

function $skip_0(this$static, count){
  this$static.stagingPos += count;
}

function GL20Buffer$ShortImpl_0(gl, capacity){
  GL20Buffer_0.call(this, gl);
  this.buffer_0 = $asShortBuffer($order(allocateDirect(capacity * 2), ($clinit_ByteOrder() , $clinit_ByteOrder() , NATIVE_ORDER)));
  this.staging = initDim(_3S_classLit, makeCastMap([Q$Serializable]), -1, capacity, 1);
}

defineSeed(703, 701, {}, GL20Buffer$ShortImpl_0);
_.buffer_1 = function buffer_1(){
  return this.buffer_0;
}
;
_.bytesPerElement = function bytesPerElement_0(){
  return 2;
}
;
_.flush = function flush_0(){
  $position(this.buffer_0);
  $put_3(this.buffer_0, this.staging, this.stagingPos);
  this.stagingPos = 0;
}
;
_.position_1 = function position_1(){
  return this.stagingPos;
}
;
_.toString$ = function toString_51(){
  return 'shortbuf:' + this.bufferId;
}
;
_.buffer_0 = null;
_.staging = null;
_.stagingPos = 0;
function $bindFramebuffer_0(this$static, fbuf, width, height){
  if (fbuf != this$static.lastFramebuffer) {
    $flush_0(this$static, true);
    $checkGLError(this$static, 'bindFramebuffer');
    $bindFramebufferImpl(this$static, this$static.lastFramebuffer = fbuf, this$static.curFbufWidth = width, this$static.curFbufHeight = height);
  }
}

function $createQuadShader(this$static){
  var $e0, quadShader, t, maxVecs;
  if (maxVecs = this$static.gl.gl.getParameter(36347) - 3 , maxVecs >= 48) {
    try {
      quadShader = new QuadShader_0(this$static);
      quadShader.texEpoch = quadShader.ctx.epoch;
      quadShader.texCore = new QuadShader$QuadCore_0(quadShader, $replace_0($replace_0('uniform vec2 u_ScreenSize;\nuniform vec4 u_Data[_VEC4S_PER_QUAD_*_MAX_QUADS_];\nattribute vec3 a_Vertex;\nvarying vec2 v_TexCoord;\nvarying vec4 v_Color;\nvoid main(void) {\nint index = _VEC4S_PER_QUAD_*int(a_Vertex.z);\nvec4 mat = u_Data[index+0];\nvec4 txc = u_Data[index+1];\nvec4 tcs = u_Data[index+2];\nmat3 transform = mat3(\n  mat.x, mat.y, 0,\n  mat.z, mat.w, 0,\n  txc.x, txc.y, 1);\ngl_Position = vec4(transform * vec3(a_Vertex.xy, 1.0), 1.0);\ngl_Position.xy /= u_ScreenSize.xy;\ngl_Position.x -= 1.0;\ngl_Position.y = 1.0 - gl_Position.y;\nv_TexCoord = a_Vertex.xy * tcs.xy + txc.zw;\nfloat red = mod(tcs.z, 256.0);\nfloat alpha = (tcs.z - red) / 256.0;\nfloat blue = mod(tcs.w, 256.0);\nfloat green = (tcs.w - blue) / 256.0;\nv_Color = vec4(red / 255.0, green / 255.0, blue / 255.0, alpha / 255.0);\n}', '_MAX_QUADS_', '' + quadShader.maxQuads), '_VEC4S_PER_QUAD_', '3'), $textureFragmentShader());
      return quadShader;
    }
     catch ($e0) {
      $e0 = caught_0($e0);
      if (instanceOf($e0, Q$Throwable)) {
        t = $e0;
        $warn(this$static.platform.log_0, 'Failed to create QuadShader: ' + t);
      }
       else 
        throw $e0;
    }
  }
  return new IndexedTrisShader_0(this$static);
}

function $fillImage(this$static){
  var image;
  if (!this$static.fillImage) {
    image = $createImage(this$static.platform.graphics, 4, 4);
    $fillRect_0($setFillColor(image.canvas, -1), 0, 0, 4, 4);
    this$static.fillImage = image;
  }
  return this$static.fillImage;
}

function $flush_0(this$static, deactivate){
  if (this$static.curShader) {
    $checkGLError(this$static, 'flush()');
    $flush_1(this$static.curShader);
    if (deactivate) {
      this$static.curShader.texCore.deactivate();
      this$static.curShader = null;
    }
  }
}

function $quadShader(this$static, custom){
  return !custom?this$static.quadShader:custom;
}

function $setSize(this$static, width, height){
  this$static.viewWidth = width;
  this$static.viewHeight = height;
  this$static.curFbufWidth = this$static.defaultFbufWidth = $scaledCeil(this$static.scale_0, width);
  this$static.curFbufHeight = this$static.defaultFbufHeight = $scaledCeil(this$static.scale_0, height);
  $bindFramebufferImpl(this$static, 0, this$static.defaultFbufWidth, this$static.defaultFbufHeight);
}

function $trisShader(this$static, custom){
  return !custom?this$static.trisShader:custom;
}

function $useShader(this$static, shader){
  if (this$static.curShader == shader)
    return false;
  $checkGLError(this$static, 'useShader');
  $flush_0(this$static, true);
  this$static.curShader = shader;
  return true;
}

defineSeed(705, 1, {});
_.createTransform = function createTransform(){
  return new StockInternalTransform_0;
}
;
_.curFbufHeight = 0;
_.curFbufWidth = 0;
_.curShader = null;
_.defaultFbufHeight = 0;
_.defaultFbufWidth = 0;
_.epoch = 0;
_.fillImage = null;
_.lastFramebuffer = 0;
_.platform = null;
_.pushedFramebuffer = -1;
_.pushedHeight = 0;
_.pushedWidth = 0;
_.scale_0 = null;
_.viewHeight = 0;
_.viewWidth = 0;
function $bindFramebufferImpl(this$static, fbuf, width, height){
  $glBindFramebuffer(this$static.gl, fbuf);
  $glViewport(this$static.gl, width, height);
  ++this$static.stats.frameBufferBinds;
}

function $bindTexture_0(this$static, tex){
  $glBindTexture(this$static.gl, tex);
  ++this$static.stats.texBinds;
}

function $checkGLError(this$static, op){
  var error;
  if (this$static.checkErrors) {
    while ((error = this$static.gl.gl.getError()) != 0) {
      $error(platform_1.log_0, Lplayn_html_HtmlGLContext_2_classLit.typeName + ' -- ' + op + ': glError ' + error);
    }
  }
}

function $clear_4(this$static){
  $glClearColor(this$static.gl, 0, 0, 0, 0);
  $glClear(this$static.gl, 16384);
}

function $createFloatBuffer(this$static, capacity){
  return new GL20Buffer$FloatImpl_0(this$static.gl, capacity);
}

function $createProgram(this$static, vertShader, fragShader){
  ++this$static.stats.shaderCreates;
  return new GL20Program_0(this$static, this$static.gl, vertShader, fragShader);
}

function $createShortBuffer(this$static, capacity){
  return new GL20Buffer$ShortImpl_0(this$static.gl, capacity);
}

function $createTexture(this$static, width, height, repeatX, repeatY, mm){
  var tex;
  tex = $createTexture_0(this$static, repeatX, repeatY, mm);
  $glTexImage2D(this$static.gl, width, height);
  return tex;
}

function $createTexture_0(this$static, repeatX, repeatY, mipmaps){
  var tex;
  tex = initDim(_3I_classLit, makeCastMap([Q$int_$1, Q$Serializable]), -1, 1, 1);
  $genObjects(this$static.gl, tex, ($clinit_HtmlGL20$WebGLObjectType() , TEXTURE));
  $glBindTexture(this$static.gl, tex[0]);
  $glTexParameteri(this$static.gl, 10240, 9729);
  $glTexParameteri(this$static.gl, 10241, mipmapify(mipmaps));
  $glTexParameteri(this$static.gl, 10242, repeatX?10497:33071);
  $glTexParameteri(this$static.gl, 10243, repeatY?10497:33071);
  ++this$static.stats.texCreates;
  return tex[0];
}

function $destroyTexture(this$static, tex){
  $flush_0(this$static, false);
  $deleteObjects(this$static.gl, initValues(_3I_classLit, makeCastMap([Q$int_$1, Q$Serializable]), -1, [tex]), ($clinit_HtmlGL20$WebGLObjectType() , TEXTURE));
}

function $generateMipmap(this$static, tex){
  $glBindTexture(this$static.gl, tex);
  this$static.gl.gl.generateMipmap(3553);
}

function $paint_0(this$static, rootLayer){
  if (rootLayer.impl.children.size > 0) {
    $checkGLError(this$static, 'paint');
    $bindFramebuffer_0(this$static, 0, this$static.defaultFbufWidth, this$static.defaultFbufHeight);
    $glClear(this$static.gl, 16640);
    $paint_1(rootLayer, this$static.rootXform, -1, null);
    $useShader(this$static, null);
  }
  ++this$static.stats.frames_0;
}

function GL20Context_0(platform, gl, checkErrors){
  this.stats = new GLContext$Stats_0;
  new ArrayList_0;
  this.scale_0 = new Scale_0(1);
  this.platform = platform;
  this.gl = gl;
  this.checkErrors = checkErrors;
  this.rootXform = this.createTransform();
  this.rootXform.uniformScale(1);
}

function mipmapify(mipmaps){
  if (!mipmaps)
    return 9729;
  switch (9729) {
    case 9728:
    case 9729:
      return 9985;
  }
}

defineSeed(704, 705, {});
_.checkErrors = false;
_.gl = null;
_.quadShader = null;
_.rootXform = null;
_.trisShader = null;
function $bind_0(this$static){
  $glUseProgram(this$static.gl, this$static.program);
}

function $compileShader_0(this$static, type, shaderSource){
  var compiled, log, shader;
  shader = $glCreateShader(this$static.gl, type);
  if (shader == 0)
    throw new RuntimeException_1('Failed to create shader (' + type + '): ' + this$static.gl.gl.getError());
  $glShaderSource(this$static.gl, shader, shaderSource);
  $glCompileShader(this$static.gl, shader);
  compiled = initDim(_3I_classLit, makeCastMap([Q$int_$1, Q$Serializable]), -1, 1, 1);
  $glGetShaderiv(this$static.gl, shader, compiled);
  if (compiled[0] == 0) {
    log = $glGetShaderInfoLog(this$static.gl, shader);
    $deleteObject(this$static.gl, shader, ($clinit_HtmlGL20$WebGLObjectType() , SHADER));
    throw new RuntimeException_1('Failed to compile shader (' + type + '): ' + log);
  }
  return shader;
}

function $destroy_0(this$static){
  $deleteObject(this$static.gl, this$static.vertexShader, ($clinit_HtmlGL20$WebGLObjectType() , SHADER));
  $deleteObject(this$static.gl, this$static.fragmentShader, SHADER);
  $deleteObject(this$static.gl, this$static.program, PROGRAM);
}

function $getAttrib(this$static, name_0, size, type){
  var loc;
  loc = $glGetAttribLocation(this$static.gl, this$static.program, name_0);
  return loc < 0?null:new GL20Program$10_0(this$static, loc, size, type);
}

function $getUniform1i(this$static){
  var loc;
  loc = $glGetUniformLocation(this$static.gl, this$static.program, 'u_Texture');
  return loc < 0?null:new GL20Program$5_0(this$static, loc);
}

function $getUniform2f(this$static){
  var loc;
  loc = $glGetUniformLocation(this$static.gl, this$static.program, 'u_ScreenSize');
  return loc < 0?null:new GL20Program$2_0(this$static, loc);
}

function $getUniform4fv(this$static){
  var loc;
  loc = $glGetUniformLocation(this$static.gl, this$static.program, 'u_Data');
  return loc < 0?null:new GL20Program$8_0(this$static, loc);
}

function GL20Program_0(ctx, gl, vertexSource, fragmentSource){
  var fragmentShader, linkStatus, log, program, vertexShader;
  this.gl = gl;
  program = 0;
  vertexShader = 0;
  fragmentShader = 0;
  try {
    program = $createObject(gl, gl.gl.createProgram(), ($clinit_HtmlGL20$WebGLObjectType() , PROGRAM));
    if (program == 0) {
      throw new RuntimeException_1('Failed to create program: ' + gl.gl.getError());
    }
    vertexShader = $compileShader_0(this, 35633, vertexSource);
    $attachShader(gl.gl, gl.webGLObjects[program], gl.webGLObjects[vertexShader]);
    $checkGLError(ctx, 'Attached vertex shader');
    fragmentShader = $compileShader_0(this, 35632, fragmentSource);
    $attachShader(gl.gl, gl.webGLObjects[program], gl.webGLObjects[fragmentShader]);
    $checkGLError(ctx, 'Attached fragment shader');
    $linkProgram(gl.gl, gl.webGLObjects[program]);
    linkStatus = initDim(_3I_classLit, makeCastMap([Q$int_$1, Q$Serializable]), -1, 1, 1);
    linkStatus[0] = $getProgramParameterb(gl.gl, gl.webGLObjects[program], 35714)?1:0;
    if (linkStatus[0] == 0) {
      log = $getProgramInfoLog(gl.gl, gl.webGLObjects[program]);
      $deleteObject(gl, program, PROGRAM);
      throw new RuntimeException_1('Failed to link program: ' + log);
    }
    this.program = program;
    this.vertexShader = vertexShader;
    this.fragmentShader = fragmentShader;
    program = vertexShader = fragmentShader = 0;
  }
   finally {
    program != 0 && $deleteObject(gl, program, ($clinit_HtmlGL20$WebGLObjectType() , PROGRAM));
    vertexShader != 0 && $deleteObject(gl, vertexShader, ($clinit_HtmlGL20$WebGLObjectType() , SHADER));
    fragmentShader != 0 && $deleteObject(gl, fragmentShader, ($clinit_HtmlGL20$WebGLObjectType() , SHADER));
  }
}

defineSeed(706, 1, {}, GL20Program_0);
_.fragmentShader = 0;
_.gl = null;
_.program = 0;
_.vertexShader = 0;
function $bind_1(this$static, stride, offset){
  $glEnableVertexAttribArray(this$static.this$0.gl, this$static.val$loc);
  $glVertexAttribPointer(this$static.this$0.gl, this$static.val$loc, this$static.val$size, this$static.val$type, stride, offset);
}

function $unbind(this$static){
  $glDisableVertexAttribArray(this$static.this$0.gl, this$static.val$loc);
}

function GL20Program$10_0(this$0, val$loc, val$size, val$type){
  this.this$0 = this$0;
  this.val$loc = val$loc;
  this.val$size = val$size;
  this.val$type = val$type;
}

defineSeed(707, 1, {}, GL20Program$10_0);
_.this$0 = null;
_.val$loc = 0;
_.val$size = 0;
_.val$type = 0;
function $bind_2(this$static, a, b){
  $glUniform2f(this$static.this$0.gl, this$static.val$loc, a, b);
}

function GL20Program$2_0(this$0, val$loc){
  this.this$0 = this$0;
  this.val$loc = val$loc;
}

defineSeed(708, 1, {}, GL20Program$2_0);
_.this$0 = null;
_.val$loc = 0;
function $bind_3(this$static){
  $glUniform1i(this$static.this$0.gl, this$static.val$loc);
}

function GL20Program$5_0(this$0, val$loc){
  this.this$0 = this$0;
  this.val$loc = val$loc;
}

defineSeed(709, 1, {}, GL20Program$5_0);
_.this$0 = null;
_.val$loc = 0;
function $bind_4(this$static, data, count){
  var buffer;
  $flush(data);
  buffer = data.buffer_0;
  $position(buffer);
  $glUniform4fv(this$static.this$0.gl, this$static.val$loc, count, buffer);
}

function GL20Program$8_0(this$0, val$loc){
  this.this$0 = this$0;
  this.val$loc = val$loc;
}

defineSeed(710, 1, {}, GL20Program$8_0);
_.this$0 = null;
_.val$loc = 0;
function GLContext$Stats_0(){
}

defineSeed(711, 1, {}, GLContext$Stats_0);
_.frameBufferBinds = 0;
_.frameBufferCreates = 0;
_.frames_0 = 0;
_.quadsRendered = 0;
_.shaderBinds = 0;
_.shaderCreates = 0;
_.shaderFlushes = 0;
_.texBinds = 0;
_.texCreates = 0;
_.trisRendered = 0;
function $addQuad(this$static, local, left, top_0, right, bottom, sl, st, sr, sb){
  this$static.texCore.addQuad(local.m00_0(), local.m01_0(), local.m10_0(), local.m11_0(), local.tx_0(), local.ty_0(), left, top_0, sl, st, right, top_0, sr, st, left, bottom, sl, sb, right, bottom, sr, sb);
  ++this$static.ctx.stats.quadsRendered;
}

function $addTriangles(this$static, local, xys, sxys, indices){
  this$static.texCore.addTriangles(local.m00_0(), local.m01_0(), local.m10_0(), local.m11_0(), local.tx_0(), local.ty_0(), xys, sxys, indices);
  this$static.ctx.stats.trisRendered += ~~(indices.length / 3);
}

function $clearProgram(this$static){
  if (this$static.texCore) {
    this$static.texCore.destroy();
    this$static.texCore = null;
  }
}

function $flush_1(this$static){
  this$static.texCore.flush();
  ++this$static.ctx.stats.shaderFlushes;
}

function $prepareTexture(this$static, tex, tint){
  var justActivated;
  this$static.texEpoch != this$static.ctx.epoch && (this$static.texCore = null);
  !this$static.texCore && (this$static.texEpoch = this$static.ctx.epoch , this$static.texCore = this$static.createTextureCore());
  justActivated = $useShader(this$static.ctx, this$static);
  if (justActivated) {
    this$static.texCore.activate_0(this$static.ctx.curFbufWidth, this$static.ctx.curFbufHeight);
    ++this$static.ctx.stats.shaderBinds;
  }
  this$static.texCore.prepare(tex, tint, justActivated);
  return this$static;
}

function $textureFragmentShader(){
  var str;
  str = new StringBuilder_1('#ifdef GL_ES\nprecision lowp float;\n#else\n#define lowp\n#define mediump\n#define highp\n#endif\n');
  str.impl.string += 'uniform lowp sampler2D u_Texture;\n';
  str.impl.string += 'varying mediump vec2 v_TexCoord;\nvarying lowp vec4 v_Color;\n';
  str.impl.string += 'void main(void) {\n';
  str.impl.string += '  vec4 textureColor = texture2D(u_Texture, v_TexCoord);\n';
  str.impl.string += '  textureColor.rgb *= v_Color.rgb;\n';
  str.impl.string += '  textureColor *= v_Color.a;\n';
  str.impl.string += '  gl_FragColor = textureColor;\n}';
  return str.impl.string;
}

defineSeed(712, 1, {});
_.ctx = null;
_.texCore = null;
_.texEpoch = 0;
function $prepare(this$static, tex, justActivated){
  var stateChanged;
  $checkGLError(this$static.this$0_0.ctx, 'textureShader.prepare start');
  stateChanged = tex != this$static.lastTex;
  if (!justActivated && stateChanged) {
    $flush_1(this$static.this$0_0);
    $checkGLError(this$static.this$0_0.ctx, 'textureShader.prepare flush');
  }
  if (stateChanged) {
    this$static.lastTex = tex;
    $checkGLError(this$static.this$0_0.ctx, 'textureShader.prepare end');
  }
  if (justActivated) {
    this$static.this$0_0.ctx.gl.gl.activeTexture(33984);
    $bind_3(this$static.uTexture);
  }
}

function GLShader$Core_0(this$0, vertShader, fragShader){
  this.this$0_0 = this$0;
  this.prog = $createProgram(this$0.ctx, vertShader, fragShader);
  this.uTexture = $getUniform1i(this.prog);
}

defineSeed(713, 1, {});
_.addTriangles = function addTriangles(m00, m01, m10, m11, tx, ty, xys, sxys, indices){
  throw new UnsupportedOperationException_1('Triangles not supported by this shader');
}
;
_.destroy = function destroy(){
  $destroy_0(this.prog);
}
;
_.flush = function flush_1(){
  $bindTexture_0(this.this$0_0.ctx, this.lastTex);
}
;
_.prepare = function prepare(tex, tint, justActivated){
  $prepare(this, tex, justActivated);
}
;
_.lastTex = 0;
_.prog = null;
_.this$0_0 = null;
_.uTexture = null;
function nextPowerOfTwo(x){
  var bit, count, highest, i;
  bit = 32768;
  highest = -1;
  count = 0;
  for (i = 15; i >= 0; --i , bit >>= 1) {
    if ((x & bit) != 0) {
      ++count;
      highest == -1 && (highest = i);
    }
  }
  if (count <= 1) {
    return 0;
  }
  return 1 << highest + 1;
}

function LayerGL_0(){
  AbstractLayer_0.call(this, new HtmlInternalTransform_0);
  this.savedLocal = new HtmlInternalTransform_0;
}

defineSeed(716, 641, {});
_.savedLocal = null;
function $paint_1(this$static, curTransform, curTint, curShader){
  if (!$isSet(this$static, ($clinit_AbstractLayer$Flag() , VISIBLE_1)))
    return;
  $render_1(this$static, ($set_8(this$static.savedLocal, curTransform) , $concatenate_0(this$static.savedLocal, $transform_0(this$static), this$static.originX, this$static.originY)), curTint, curShader);
}

function $render_1(this$static, xform, curTint, shader){
  var children, ii, ll;
  children = this$static.impl.children;
  for (ii = 0 , ll = children.size; ii < ll; ++ii) {
    (checkIndex(ii, children.size) , children.array[ii]).paint_0(xform, curTint, shader);
  }
}

function GroupLayerGL_0(){
  LayerGL_0.call(this);
  this.impl = new GroupLayerImpl_0;
}

defineSeed(715, 716, {}, GroupLayerGL_0);
_.add_1 = function add_12(layer){
  $add_19(this.impl, this, layer);
}
;
_.hitTestDefault = function hitTestDefault_1(p){
  return $hitTest(this.impl, this, p);
}
;
_.onAdd = function onAdd_1(){
  $onAdd(this);
  $onAdd_0(this.impl);
}
;
_.onRemove = function onRemove_1(){
  $onRemove(this.impl);
}
;
_.paint_0 = function paint_1(curTransform, curTint, curShader){
  $paint_1(this, curTransform, curTint, curShader);
}
;
_.remove_4 = function remove_33(layer){
  $remove_19(this.impl, layer);
}
;
function $clearTexture(this$static){
  if (this$static.tex > 0) {
    $destroyTexture(this$static.ctx, this$static.tex);
    this$static.tex = 0;
  }
}

function $createMainTex(this$static){
  var tex;
  tex = $createTexture_0(this$static.ctx, false, false, false);
  this$static.updateTexture(tex);
  return tex;
}

function $createPow2RepTex(this$static, width, height, repeatX, repeatY, mipmapped){
  var powtex;
  powtex = $createTexture(this$static.ctx, width, height, repeatX, repeatY, mipmapped);
  this$static.updateTexture(powtex);
  return powtex;
}

function $scaleTexture(this$static){
  var height, reptex, scaledHeight, scaledWidth, tex, width;
  scaledWidth = $scaledCeil(this$static.scale_0, this$static.width_1());
  scaledHeight = $scaledCeil(this$static.scale_0, this$static.height_1());
  width = nextPowerOfTwo(scaledWidth);
  height = nextPowerOfTwo(scaledHeight);
  if (width == 0 && height == 0) {
    reptex = $createPow2RepTex(this$static, scaledWidth, scaledHeight, this$static.repeatX, this$static.repeatY, this$static.mipmapped);
    this$static.mipmapped && $generateMipmap(this$static.ctx, reptex);
    return reptex;
  }
  tex = $createMainTex(this$static);
  width == 0 && (width = scaledWidth);
  height == 0 && (height = scaledHeight);
  try {
    return convertToRepTex(this$static.ctx, tex, width, height, this$static.repeatX, this$static.repeatY, this$static.mipmapped);
  }
   finally {
    $destroyTexture(this$static.ctx, tex);
  }
}

function ImageGL_0(ctx, scale){
  this.ctx = ctx;
  this.scale_0 = scale;
}

function convertToRepTex(ctx, tex, width, height, repeatX, repeatY, mipmapped){
  var fbuf, reptex, shader, fbuf_0;
  reptex = $createTexture(ctx, width, height, repeatX, repeatY, mipmapped);
  fbuf = ($flush_0(ctx, true) , fbuf_0 = initDim(_3I_classLit, makeCastMap([Q$int_$1, Q$Serializable]), -1, 1, 1) , $genObjects(ctx.gl, fbuf_0, ($clinit_HtmlGL20$WebGLObjectType() , FRAME_BUFFER)) , $glBindFramebuffer(ctx.gl, fbuf_0[0]) , $glFramebufferTexture2D(ctx.gl, reptex) , ++ctx.stats.frameBufferCreates , fbuf_0[0]);
  ctx.pushedFramebuffer = ctx.lastFramebuffer;
  ctx.pushedWidth = ctx.curFbufWidth;
  ctx.pushedHeight = ctx.curFbufHeight;
  $bindFramebuffer_0(ctx, fbuf, width, height);
  try {
    $glClearColor(ctx.gl, 0, 0, 0, 0);
    $glClear(ctx.gl, 16384);
    shader = $prepareTexture(ctx.quadShader, tex, -1);
    $addQuad(shader, new HtmlInternalTransform_0, 0, height, width, 0, 0, 0, 1, 1);
    shader.texCore.flush();
    ++shader.ctx.stats.shaderFlushes;
    mipmapped && ($glBindTexture(ctx.gl, reptex) , ctx.gl.gl.generateMipmap(3553) , undefined);
    return reptex;
  }
   finally {
    $bindFramebuffer_0(ctx, ctx.pushedFramebuffer, ctx.pushedWidth, ctx.pushedHeight);
    ctx.pushedFramebuffer = -1;
    $deleteObjects(ctx.gl, initValues(_3I_classLit, makeCastMap([Q$int_$1, Q$Serializable]), -1, [fbuf]), FRAME_BUFFER);
  }
}

defineSeed(717, 698, {});
_.clearTexture = function clearTexture(){
  $clearTexture(this);
}
;
_.ensureTexture = function ensureTexture(){
  return this.tex > 0?this.tex:this.isReady()?this.repeatX || this.repeatY || this.mipmapped?(this.tex = $scaleTexture(this)):(this.tex = $createMainTex(this)):0;
}
;
_.scale_0 = null;
_.tex = 0;
function ImmediateLayerGL_0(ctx, renderer){
  ImmediateLayerGL_1.call(this, renderer, new ImmediateLayerGL$1_0(ctx));
}

function ImmediateLayerGL_1(renderer, surface){
  LayerGL_0.call(this);
  this.surface = surface;
  this.renderer = renderer;
}

defineSeed(718, 716, {}, ImmediateLayerGL_0);
_.paint_0 = function paint_2(curTransform, curTint, curShader){
  var xform;
  if (!$isSet(this, ($clinit_AbstractLayer$Flag() , VISIBLE_1)))
    return;
  xform = ($set_8(this.savedLocal, curTransform) , $concatenate_0(this.savedLocal, $transform_0(this), this.originX, this.originY));
  $topTransform(this.surface).set_1(xform);
  $setTint(this.surface, curTint);
  $setShader(this.surface, curShader);
  $render_0(this.renderer, this.surface);
  $setShader(this.surface, null);
}
;
_.renderer = null;
_.surface = null;
defineSeed(720, 700, {});
function ImmediateLayerGL$1_0($anonymous0){
  this.transformStack = new ArrayList_0;
  this.ctx = $anonymous0;
  $add_0(this.transformStack, new HtmlInternalTransform_0);
}

defineSeed(719, 720, {}, ImmediateLayerGL$1_0);
_.height_1 = function height_2(){
  return platform_1.graphics.height_2();
}
;
_.width_1 = function width_2(){
  return platform_1.graphics.width_2();
}
;
--></script>
<script><!--
function $clinit_IndexedTrisShader(){
  $clinit_IndexedTrisShader = nullMethod;
  QUAD_INDICES = initValues(_3I_classLit, makeCastMap([Q$int_$1, Q$Serializable]), -1, [0, 1, 2, 1, 3, 2]);
}

function IndexedTrisShader_0(ctx){
  $clinit_IndexedTrisShader();
  this.ctx = ctx;
  this.delayedBinding = false;
}

function addVert(data, offset, prefix, x, y, sx, sy){
  $clinit_IndexedTrisShader();
  arraycopy(prefix, 0, data, offset, prefix.length);
  offset += prefix.length;
  data[offset++] = x;
  data[offset++] = y;
  data[offset++] = sx;
  data[offset++] = sy;
  return offset;
}

defineSeed(721, 712, {}, IndexedTrisShader_0);
_.createTextureCore = function createTextureCore(){
  return new IndexedTrisShader$ITCore_0(this, $textureFragmentShader());
}
;
_.toString$ = function toString_52(){
  return 'itris/' + this.texCore;
}
;
_.delayedBinding = false;
var QUAD_INDICES;
function $addElems(this$static, vertIdx, indices){
  var data, ii, ll, offset;
  data = this$static.elements.staging;
  offset = this$static.elements.stagingPos;
  for (ii = 0 , ll = indices.length; ii < ll; ++ii) {
    data[offset++] = ~~(vertIdx + indices[ii] << 16) >> 16;
  }
  $skip_0(this$static.elements, offset - this$static.elements.stagingPos);
}

function $addExtraStableAttrs(this$static, buf, sidx){
  buf[sidx++] = this$static.arTint;
  buf[sidx++] = this$static.gbTint;
  return sidx;
}

function $beginPrimitive(this$static, vertexCount, elemCount){
  var availElems, availVerts, elems, vertIdx, verts;
  vertIdx = ~~(this$static.vertices.stagingPos / 12);
  verts = vertIdx + vertexCount;
  elems = this$static.elements.stagingPos + elemCount;
  availVerts = ~~(this$static.vertices.staging.length / 12);
  availElems = this$static.elements.staging.length;
  if (verts > availVerts || elems > availElems) {
    $flush_1(this$static.this$0);
    verts > availVerts && $expandVerts(this$static, verts);
    elems > availElems && $expandElems(this$static, elems);
    return 0;
  }
  return vertIdx;
}

function $bindAttribsBufs(this$static){
  $bind(this$static.vertices, 34962);
  $bind_1(this$static.aMatrix, 48, 0);
  $bind_1(this$static.aTranslation, 48, 16);
  $bind_1(this$static.aColor, 48, 24);
  $bind_1(this$static.aPosition, 48, 32);
  !!this$static.aTexCoord && $bind_1(this$static.aTexCoord, 48, 40);
  $bind(this$static.elements, 34963);
}

function $expandElems(this$static, elemCount){
  var newElems;
  newElems = this$static.elements.staging.length;
  while (newElems < elemCount)
    newElems += 96;
  $expand_1(this$static.elements, newElems);
}

function $expandVerts(this$static, vertCount){
  var newVerts;
  newVerts = ~~(this$static.vertices.staging.length / 12);
  while (newVerts < vertCount)
    newVerts += 64;
  $expand_0(this$static.vertices, newVerts * 12);
}

function IndexedTrisShader$ITCore_0(this$0, fragShader){
  this.this$0 = this$0;
  GLShader$Core_0.call(this, this$0, 'uniform vec2 u_ScreenSize;\nattribute vec4 a_Matrix;\nattribute vec2 a_Translation;\nattribute vec2 a_Color;\nattribute vec2 a_Position;\nattribute vec2 a_TexCoord;\nvarying vec2 v_TexCoord;\nvarying vec4 v_Color;\nvoid main(void) {\nmat3 transform = mat3(\n  a_Matrix[0], a_Matrix[1], 0,\n  a_Matrix[2], a_Matrix[3], 0,\n  a_Translation[0], a_Translation[1], 1);\ngl_Position = vec4(transform * vec3(a_Position, 1.0), 1);\ngl_Position.xy /= (u_ScreenSize.xy / 2.0);\ngl_Position.x -= 1.0;\ngl_Position.y = 1.0 - gl_Position.y;\nv_TexCoord = a_TexCoord;\nfloat red = mod(a_Color.x, 256.0);\nfloat alpha = (a_Color.x - red) / 256.0;\nfloat blue = mod(a_Color.y, 256.0);\nfloat green = (a_Color.y - blue) / 256.0;\nv_Color = vec4(red / 255.0, green / 255.0, blue / 255.0, alpha / 255.0);\n}', fragShader);
  this.uScreenSize = $getUniform2f(this.prog);
  this.aMatrix = $getAttrib(this.prog, 'a_Matrix', 4, 5126);
  this.aTranslation = $getAttrib(this.prog, 'a_Translation', 2, 5126);
  this.aColor = $getAttrib(this.prog, 'a_Color', 2, 5126);
  this.aPosition = $getAttrib(this.prog, 'a_Position', 2, 5126);
  this.aTexCoord = $getAttrib(this.prog, 'a_TexCoord', 2, 5126);
  this.stableAttrs = initDim(_3F_classLit, makeCastMap([Q$Serializable]), -1, 8, 1);
  this.vertices = $createFloatBuffer(this$0.ctx, 768);
  this.elements = $createShortBuffer(this$0.ctx, 96);
}

defineSeed(722, 713, {}, IndexedTrisShader$ITCore_0);
_.activate_0 = function activate_12(fbufWidth, fbufHeight){
  $bind_0(this.prog);
  $bind_2(this.uScreenSize, fbufWidth, fbufHeight);
  this.this$0.delayedBinding || $bindAttribsBufs(this);
  $checkGLError(this.this$0.ctx, 'Shader.activate bind');
}
;
_.addQuad = function addQuad(m00, m01, m10, m11, tx, ty, x1, y1, sx1, sy1, x2, y2, sx2, sy2, x3, y3, sx3, sy3, x4, y4, sx4, sy4){
  var offset, vertData, vertIdx;
  this.stableAttrs[0] = m00;
  this.stableAttrs[1] = m01;
  this.stableAttrs[2] = m10;
  this.stableAttrs[3] = m11;
  this.stableAttrs[4] = tx;
  this.stableAttrs[5] = ty;
  $addExtraStableAttrs(this, this.stableAttrs, 6);
  vertIdx = $beginPrimitive(this, 4, 6);
  offset = this.vertices.stagingPos;
  vertData = this.vertices.staging;
  offset = addVert(vertData, offset, this.stableAttrs, x1, y1, sx1, sy1);
  offset = addVert(vertData, offset, this.stableAttrs, x2, y2, sx2, sy2);
  offset = addVert(vertData, offset, this.stableAttrs, x3, y3, sx3, sy3);
  offset = addVert(vertData, offset, this.stableAttrs, x4, y4, sx4, sy4);
  $skip(this.vertices, offset - this.vertices.stagingPos);
  $addElems(this, vertIdx, ($clinit_IndexedTrisShader() , QUAD_INDICES));
}
;
_.addTriangles = function addTriangles_0(m00, m01, m10, m11, tx, ty, xys, sxys, indices){
  var ii, ll, offset, vertData, vertIdx;
  this.stableAttrs[0] = m00;
  this.stableAttrs[1] = m01;
  this.stableAttrs[2] = m10;
  this.stableAttrs[3] = m11;
  this.stableAttrs[4] = tx;
  this.stableAttrs[5] = ty;
  $addExtraStableAttrs(this, this.stableAttrs, 6);
  vertIdx = $beginPrimitive(this, ~~(xys.length / 2), indices.length);
  offset = this.vertices.stagingPos;
  vertData = this.vertices.staging;
  for (ii = 0 , ll = xys.length; ii < ll; ii += 2) {
    offset = addVert(vertData, offset, this.stableAttrs, xys[ii], xys[ii + 1], sxys[ii], sxys[ii + 1]);
  }
  $skip(this.vertices, offset - this.vertices.stagingPos);
  $addElems(this, vertIdx, indices);
}
;
_.deactivate = function deactivate_0(){
  $unbind(this.aMatrix);
  $unbind(this.aTranslation);
  $unbind(this.aColor);
  $unbind(this.aPosition);
  !!this.aTexCoord && $unbind(this.aTexCoord);
}
;
_.destroy = function destroy_0(){
  $destroy_0(this.prog);
  $destroy(this.vertices);
  $destroy(this.elements);
}
;
_.flush = function flush_2(){
  var elems;
  $bindTexture_0(this.this$0_0.ctx, this.lastTex);
  if (this.vertices.stagingPos == 0)
    return;
  $checkGLError(this.this$0.ctx, 'Shader.flush');
  if (this.this$0.delayedBinding) {
    $bindAttribsBufs(this);
    $checkGLError(this.this$0.ctx, 'Shader.flush bind');
  }
  $send(this.vertices, 34962, 35040);
  elems = $send(this.elements, 34963, 35040);
  $checkGLError(this.this$0.ctx, 'Shader.flush BufferData');
  $drawElements_0(this.elements, elems);
  $checkGLError(this.this$0.ctx, 'Shader.flush DrawElements');
}
;
_.prepare = function prepare_0(tex, tint, justActivated){
  $prepare(this, tex, justActivated);
  this.arTint = ~~tint >> 16 & 65535;
  this.gbTint = tint & 65535;
}
;
_.toString$ = function toString_53(){
  return 'cq=' + ~~(this.elements.staging.length / 6);
}
;
_.aColor = null;
_.aMatrix = null;
_.aPosition = null;
_.aTexCoord = null;
_.aTranslation = null;
_.arTint = 0;
_.elements = null;
_.gbTint = 0;
_.stableAttrs = null;
_.this$0 = null;
_.uScreenSize = null;
_.vertices = null;
function QuadShader_0(ctx){
  var maxVecs;
  this.ctx = ctx;
  maxVecs = ctx.gl.gl.getParameter(36347) - 3;
  if (maxVecs < 3)
    throw new RuntimeException_1('GL_MAX_VERTEX_UNIFORM_VECTORS too low: have ' + maxVecs + ', need at least 3');
  this.maxQuads = ~~(maxVecs / 3);
}

defineSeed(723, 712, {}, QuadShader_0);
_.createTextureCore = function createTextureCore_0(){
  return new QuadShader$QuadCore_0(this, $replace_0($replace_0('uniform vec2 u_ScreenSize;\nuniform vec4 u_Data[_VEC4S_PER_QUAD_*_MAX_QUADS_];\nattribute vec3 a_Vertex;\nvarying vec2 v_TexCoord;\nvarying vec4 v_Color;\nvoid main(void) {\nint index = _VEC4S_PER_QUAD_*int(a_Vertex.z);\nvec4 mat = u_Data[index+0];\nvec4 txc = u_Data[index+1];\nvec4 tcs = u_Data[index+2];\nmat3 transform = mat3(\n  mat.x, mat.y, 0,\n  mat.z, mat.w, 0,\n  txc.x, txc.y, 1);\ngl_Position = vec4(transform * vec3(a_Vertex.xy, 1.0), 1.0);\ngl_Position.xy /= u_ScreenSize.xy;\ngl_Position.x -= 1.0;\ngl_Position.y = 1.0 - gl_Position.y;\nv_TexCoord = a_Vertex.xy * tcs.xy + txc.zw;\nfloat red = mod(tcs.z, 256.0);\nfloat alpha = (tcs.z - red) / 256.0;\nfloat blue = mod(tcs.w, 256.0);\nfloat green = (tcs.w - blue) / 256.0;\nv_Color = vec4(red / 255.0, green / 255.0, blue / 255.0, alpha / 255.0);\n}', '_MAX_QUADS_', '' + this.maxQuads), '_VEC4S_PER_QUAD_', '3'), $textureFragmentShader());
}
;
_.toString$ = function toString_54(){
  return 'quad/' + this.maxQuads;
}
;
_.maxQuads = 0;
function $addExtraData(this$static, quadData, pos){
  quadData[pos++] = this$static.arTint;
  quadData[pos++] = this$static.gbTint;
  return pos;
}

function QuadShader$QuadCore_0(this$0, vertShader, fragShader){
  var base, ii;
  this.this$0 = this$0;
  GLShader$Core_0.call(this, this$0, vertShader, fragShader);
  this.uScreenSize = $getUniform2f(this.prog);
  this.uData = $getUniform4fv(this.prog);
  this.aVertex = $getAttrib(this.prog, 'a_Vertex', 3, 5122);
  this.vertices = $createShortBuffer(this$0.ctx, this$0.maxQuads * 4 * 3);
  this.elements = $createShortBuffer(this$0.ctx, this$0.maxQuads * 6);
  for (ii = 0; ii < this$0.maxQuads; ++ii) {
    $add_20($add_21(this.vertices, 0, 0), ii);
    $add_20($add_21(this.vertices, 1, 0), ii);
    $add_20($add_21(this.vertices, 0, 1), ii);
    $add_20($add_21(this.vertices, 1, 1), ii);
    base = ii * 4;
    $add_20($add_20($add_20(this.elements, base), base + 1), base + 2);
    $add_20($add_20($add_20(this.elements, base + 1), base + 3), base + 2);
  }
  this.data = $createFloatBuffer(this$0.ctx, this$0.maxQuads * 3 * 4);
  $bind(this.vertices, 34962);
  $send(this.vertices, 34962, 35044);
  $bind(this.elements, 34963);
  $send(this.elements, 34963, 35044);
}

defineSeed(724, 713, {}, QuadShader$QuadCore_0);
_.activate_0 = function activate_13(fbufWidth, fbufHeight){
  $bind_0(this.prog);
  $bind_2(this.uScreenSize, fbufWidth / 2, fbufHeight / 2);
  $bind(this.vertices, 34962);
  $bind_1(this.aVertex, 0, 0);
  $bind(this.elements, 34963);
}
;
_.addQuad = function addQuad_0(m00, m01, m10, m11, tx, ty, x1, y1, sx1, sy1, x2, y2, sx2, sy2, x3, y3, sx3, sy3, x4, y4, sx4, sy4){
  var dh, dw, opos, pos, quadData;
  dw = x2 - x1;
  dh = y3 - y1;
  quadData = this.data.staging;
  opos = this.data.stagingPos;
  pos = opos;
  quadData[pos++] = m00 * dw;
  quadData[pos++] = m01 * dw;
  quadData[pos++] = m10 * dh;
  quadData[pos++] = m11 * dh;
  quadData[pos++] = tx + m00 * x1 + m10 * y1;
  quadData[pos++] = ty + m01 * x1 + m11 * y1;
  quadData[pos++] = sx1;
  quadData[pos++] = sy1;
  quadData[pos++] = sx2 - sx1;
  quadData[pos++] = sy3 - sy1;
  pos = $addExtraData(this, quadData, pos);
  $skip(this.data, pos - opos);
  ++this.quadCounter;
  this.quadCounter >= this.this$0.maxQuads && $flush_1(this.this$0);
}
;
_.deactivate = function deactivate_1(){
  $unbind(this.aVertex);
}
;
_.destroy = function destroy_1(){
  $destroy_0(this.prog);
  $destroy(this.vertices);
  $destroy(this.elements);
  $destroy(this.data);
}
;
_.flush = function flush_3(){
  $bindTexture_0(this.this$0_0.ctx, this.lastTex);
  if (this.quadCounter == 0)
    return;
  $bind_4(this.uData, this.data, this.quadCounter * 3);
  $drawElements_0(this.elements, 6 * this.quadCounter);
  this.quadCounter = 0;
}
;
_.prepare = function prepare_1(tex, tint, justActivated){
  $prepare(this, tex, justActivated);
  this.arTint = ~~tint >> 16 & 65535;
  this.gbTint = tint & 65535;
}
;
_.aVertex = null;
_.arTint = 0;
_.data = null;
_.elements = null;
_.gbTint = 0;
_.quadCounter = 0;
_.this$0 = null;
_.uData = null;
_.uScreenSize = null;
_.vertices = null;
function $clinit_Scale(){
  $clinit_Scale = nullMethod;
  ONE_0 = new Scale_0(1);
}

function $invScaled(this$static, length_0){
  return length_0 / this$static.factor;
}

function $scaledCeil(this$static, length_0){
  return iceil(this$static.factor * length_0);
}

function Scale_0(factor){
  $clinit_Scale();
  this.factor = factor;
}

defineSeed(725, 1, {}, Scale_0);
_.toString$ = function toString_55(){
  return 'x' + this.factor;
}
;
_.factor = 0;
var ONE_0;
function JsonParserException_0(e, message){
  Throwable_1.call(this, message, e);
}

defineSeed(727, 77, makeCastMap([Q$Serializable, Q$Exception, Q$RuntimeException, Q$Throwable]), JsonParserException_0);
function $clinit_JsonTypedArray(){
  $clinit_JsonTypedArray = nullMethod;
  getters = new HashMap_0;
  getters.put(Ljava_lang_Boolean_2_classLit, new JsonTypedArray$1_0);
  getters.put(Ljava_lang_Integer_2_classLit, new JsonTypedArray$2_0);
  getters.put(Ljava_lang_Double_2_classLit, new JsonTypedArray$3_0);
  getters.put(Ljava_lang_Float_2_classLit, new JsonTypedArray$4_0);
  getters.put(Ljava_lang_String_2_classLit, new JsonTypedArray$5_0);
  getters.put(Lplayn_core_Json$Array_2_classLit, new JsonTypedArray$6_0);
  getters.put(Lplayn_core_Json$Object_2_classLit, new JsonTypedArray$7_0);
}

function $get_12(this$static, index){
  return this$static.getter.get_2(this$static.array, index, null);
}

function JsonTypedArray_0(array, type){
  $clinit_JsonTypedArray();
  var getter;
  this.array = array;
  getter = getters.get_1(type);
  if (!getter) {
    throw new IllegalArgumentException_1("Only json types may be used for TypedArray, not '" + type.typeName + "'");
  }
  this.getter = getter;
}

defineSeed(728, 1, {}, JsonTypedArray_0);
_.iterator_0 = function iterator_15(){
  return new JsonTypedArray$8_0(this);
}
;
_.array = null;
_.getter = null;
var getters;
function JsonTypedArray$1_0(){
}

defineSeed(729, 1, {}, JsonTypedArray$1_0);
_.get_2 = function get_17(array, index, dflt){
  return $clinit_Boolean() , typeof array[index] == 'boolean' && array[index]?TRUE:FALSE;
}
;
function JsonTypedArray$2_0(){
}

defineSeed(730, 1, {}, JsonTypedArray$2_0);
_.get_2 = function get_18(array, index, dflt){
  return valueOf_3(~~Math.max(Math.min(typeof array[index] == 'number'?array[index]:0, 2147483647), -2147483648));
}
;
function JsonTypedArray$3_0(){
}

defineSeed(731, 1, {}, JsonTypedArray$3_0);
_.get_2 = function get_19(array, index, dflt){
  return new Double_0(typeof array[index] == 'number'?array[index]:0);
}
;
function JsonTypedArray$4_0(){
}

defineSeed(732, 1, {}, JsonTypedArray$4_0);
_.get_2 = function get_20(array, index, dflt){
  return new Float_0(typeof array[index] == 'number'?array[index]:0);
}
;
function JsonTypedArray$5_0(){
}

defineSeed(733, 1, {}, JsonTypedArray$5_0);
_.get_2 = function get_21(array, index, dflt){
  return typeof array[index] == 'string'?array[index]:dflt;
}
;
function JsonTypedArray$6_0(){
}

defineSeed(734, 1, {}, JsonTypedArray$6_0);
_.get_2 = function get_22(array, index, dflt){
  return array[index] instanceof Array?array[index]:dflt;
}
;
function JsonTypedArray$7_0(){
}

defineSeed(735, 1, {}, JsonTypedArray$7_0);
_.get_2 = function get_23(array, index, dflt){
  return isValueObject(array[index])?array[index]:dflt;
}
;
function $next_9(this$static){
  if (this$static.index_0 >= this$static.this$0.array.length) {
    throw new NoSuchElementException_0;
  }
  return $get_12(this$static.this$0, this$static.index_0++);
}

function JsonTypedArray$8_0(this$0){
  this.this$0 = this$0;
}

defineSeed(736, 1, {}, JsonTypedArray$8_0);
_.hasNext = function hasNext_11(){
  return this.index_0 < this.this$0.array.length;
}
;
_.next_0 = function next_12(){
  return $next_9(this);
}
;
_.remove_2 = function remove_34(){
  throw new UnsupportedOperationException_0;
}
;
_.index_0 = 0;
_.this$0 = null;
function getElementSize_2(){
  throw new RuntimeException_1('Unrecognized buffer type: ' + null.nullMethod());
}

function RunQueue_0(){
}

defineSeed(738, 1, {}, RunQueue_0);
_.head = null;
function $clear_5(this$static){
  return $clearRect_0(this$static, this$static.width_1(), this$static.height_1());
}

function $clearRect_0(this$static, width, height){
  $clearRect(this$static.ctx, 0, 0, width, height);
  this$static.isDirty = true;
  return this$static;
}

function $fillRect_0(this$static, x, y, w, h_0){
  $fillRect(this$static.ctx, x, y, w, h_0);
  this$static.isDirty = true;
  return this$static;
}

function $scale_2(this$static, x, y){
  $scale(this$static.ctx, x, y);
  return this$static;
}

function $setAlpha(this$static, alpha){
  $setGlobalAlpha(this$static.ctx, alpha);
  return this$static;
}

function $setFillColor(this$static, color){
  $setFillStyleWeb(this$static.ctx, cssColorString(color));
  return this$static;
}

function AbstractHtmlCanvas_0(ctx, width, height){
  this.width_0 = width;
  this.height_0 = height;
  this.ctx = ctx;
}

defineSeed(739, 697, {});
_.clear_1 = function clear_3(){
  return $clear_5(this);
}
;
_.createPath = function createPath(){
  return new HtmlPath_0;
}
;
_.drawLine = function drawLine_1(x0, y0, x1, y1){
  this.ctx.beginPath();
  $moveTo(this.ctx, x0, y0);
  $lineTo(this.ctx, x1, y1);
  this.ctx.stroke();
  this.isDirty = true;
  return this;
}
;
_.fillPath = function fillPath(path){
  $replay(path, this.ctx);
  this.ctx.fill();
  this.isDirty = true;
  return this;
}
;
_.fillRect_0 = function fillRect_1(x, y, w, h_0){
  return $fillRect_0(this, x, y, w, h_0);
}
;
_.gc = function gc(){
  return this.ctx;
}
;
_.restore_0 = function restore_2(){
  this.ctx.restore();
  return this;
}
;
_.rotate_0 = function rotate_1(radians){
  $rotate(this.ctx, radians);
  return this;
}
;
_.save_0 = function save_2(){
  this.ctx.save();
  return this;
}
;
_.scale_1 = function scale_6(x, y){
  return $scale(this.ctx, x, y) , this;
}
;
_.setAlpha = function setAlpha_1(alpha){
  return $setAlpha(this, alpha);
}
;
_.setFillColor = function setFillColor_1(color){
  return $setFillColor(this, color);
}
;
_.setFillPattern = function setFillPattern_1(pattern){
  $setFillStyleWeb(this.ctx, $pattern(pattern, this.ctx));
  return this;
}
;
_.setStrokeColor = function setStrokeColor(color){
  $setStrokeStyleWeb(this.ctx, cssColorString(color));
  return this;
}
;
_.setStrokeWidth = function setStrokeWidth(w){
  $setLineWidth(this.ctx, w);
  return this;
}
;
_.transform_2 = function transform_1(m11, m12, m21, m22, dx, dy){
  $transform(this.ctx, m11, m12, m21, m22, dx, dy);
  return this;
}
;
_.translate_0 = function translate_3(x, y){
  $translate(this.ctx, x, y);
  return this;
}
;
_.ctx = null;
function $getBundle(this$static, collection){
  var clientBundle, entry, entry$iterator, regExp;
  clientBundle = null;
  for (entry$iterator = this$static.clientBundles.entrySet_0().iterator_0(); entry$iterator.hasNext();) {
    entry = entry$iterator.next_0();
    regExp = entry.getKey();
    !!$exec(new RegExp(regExp), collection) && (clientBundle = entry.getValue());
  }
  return clientBundle;
}

function $getImage_1(this$static, path, scale){
  var url, img;
  url = this$static.pathPrefix + path;
  $getBundle(this$static, path);
  return img = $doc.createElement('img') , 'crossOrigin' in img && img.setAttribute('crossOrigin', 'anonymous') , img.src = url , new HtmlImage_1(this$static.platform.graphics.ctx_1(), scale, img);
}

function $getSound_1(this$static, path){
  var url, audio, sound;
  url = this$static.pathPrefix + path;
  $getBundle(this$static, path);
  url += '.mp3';
  return audio = platform_1.audio , sound = $createSound(audio.soundController, url) , new HtmlSound_0(sound);
}

function $getText_1(this$static, path, callback){
  var $e0, e, fullPath, xhr, xdr;
  fullPath = this$static.pathPrefix + path;
  try {
    xhr = create_7();
    $setOnReadyStateChange(xhr, new HtmlAssets$2_0(fullPath, callback));
    xhr.open('GET', fullPath, true);
    xhr.send(null);
  }
   catch ($e0) {
    $e0 = caught_0($e0);
    if (instanceOf($e0, Q$JavaScriptException)) {
      e = $e0;
      if ($wnd.navigator.userAgent.indexOf('MSIE') != -1) {
        xdr = new $wnd.XDomainRequest;
        $setHandler(xdr, new HtmlAssets$1_0(fullPath, callback));
        xdr.open('GET', fullPath, true);
        xdr.send();
      }
       else {
        throw e;
      }
    }
     else 
      throw $e0;
  }
}

function HtmlAssets_0(platform){
  this.clientBundles = new HashMap_0;
  this.platform = platform;
}

defineSeed(740, 638, {}, HtmlAssets_0);
_.pathPrefix = '';
_.platform = null;
function HtmlAssets$1_0(val$fullPath, val$callback){
  this.val$fullPath = val$fullPath;
  this.val$callback = val$callback;
}

defineSeed(741, 1, {}, HtmlAssets$1_0);
_.onError = function onError(xdr){
  $error(platform_1.log_0, 'xdr::onError[' + this.val$fullPath + ']()');
  $onFailure_0(this.val$callback, new RuntimeException_1('Error getting ' + this.val$fullPath + ' : ' + xdr.contentType));
}
;
_.onLoad = function onLoad(xdr){
  $onSuccess_5(this.val$callback, xdr.responseText);
}
;
_.onProgress = function onProgress(xdr){
}
;
_.onTimeout = function onTimeout(xdr){
  $error(platform_1.log_0, 'xdr::onTimeout[' + this.val$fullPath + ']()');
  $onFailure_0(this.val$callback, new RuntimeException_1('Error getting ' + this.val$fullPath + ' : ' + xdr.contentType));
}
;
_.val$callback = null;
_.val$fullPath = null;
function HtmlAssets$2_0(val$fullPath, val$callback){
  this.val$fullPath = val$fullPath;
  this.val$callback = val$callback;
}

defineSeed(742, 1, {}, HtmlAssets$2_0);
_.onReadyStateChange = function onReadyStateChange(xhr){
  var $e0, e, readyState, status_0, status_1;
  readyState = xhr.readyState;
  if (readyState == 4) {
    status_0 = xhr.status;
    if (status_0 != 0 && (status_0 < 200 || status_0 >= 400)) {
      $error(platform_1.log_0, 'xhr::onReadyStateChange[' + this.val$fullPath + '](readyState = 4; status = ' + status_0 + ')');
      $onFailure_0(this.val$callback, new RuntimeException_1('Error getting ' + this.val$fullPath + ' : ' + xhr.statusText));
    }
     else {
      try {
        $onSuccess_5(this.val$callback, xhr.responseText);
      }
       catch ($e0) {
        $e0 = caught_0($e0);
        if (instanceOf($e0, Q$JavaScriptException)) {
          e = $e0;
          throw e;
        }
         else 
          throw $e0;
      }
    }
  }
}
;
_.val$callback = null;
_.val$fullPath = null;
function $init_0(this$static){
  $debug(($clinit_HtmlPlatform() , log_0), 'Preferred sound type(s): ' + this$static.soundController.preferredSoundTypes);
  maybeCreateAudioContext();
}

function HtmlAudio_0(){
  this.soundController = new SoundController_0;
}

function maybeCreateAudioContext(){
  try {
    return new AudioContext;
  }
   catch (ignore) {
  }
  try {
    return new webkitAudioContext;
  }
   catch (ignore) {
  }
  return null;
}

defineSeed(743, 1, {}, HtmlAudio_0);
function HtmlCanvas_0(width, height){
  HtmlCanvas_2.call(this, $doc.createElement('canvas'), width, height);
}

function HtmlCanvas_1(ctx, canvas, width, height){
  AbstractHtmlCanvas_0.call(this, ctx, width, height);
  this.canvas = canvas;
}

function HtmlCanvas_2(canvas, width, height){
  HtmlCanvas_1.call(this, canvas.getContext('2d'), canvas, width, height);
  $setWidth(canvas, iceil(width));
  $setHeight(canvas, iceil(height));
}

function create_9(scale, width, height){
  var canvas, sh, sw;
  sw = iceil(scale.factor * width);
  sh = iceil(scale.factor * height);
  canvas = new HtmlCanvas_0(sw, sh);
  $scale_2(canvas, scale.factor, scale.factor);
  return canvas;
}

defineSeed(744, 739, {}, HtmlCanvas_0);
_.canvas = null;
function $draw_4(this$static, ctx, dx, dy, dw, dh, sx, sy, sw, sh){
  sx *= this$static.scale_0.factor;
  sy *= this$static.scale_0.factor;
  sw *= this$static.scale_0.factor;
  sh *= this$static.scale_0.factor;
  $drawImage_0(ctx, this$static.img, sx, sy, sw, sh, dx, dy, dw, dh);
}

function $updateTexture(this$static, tex){
  $updateTexture_0(this$static.ctx, tex, this$static.img);
}

function HtmlImage_0(ctx, scale, img){
  ImageGL_0.call(this, ctx, scale);
  img.complete = true;
  this.img = img;
}

function HtmlImage_1(ctx, scale, img){
  ImageGL_0.call(this, ctx, scale);
  this.img = img;
}

defineSeed(746, 717, {}, HtmlImage_1);
_.addCallback = function addCallback(callback){
  if (this.img.complete) {
    ++callback.this$0.successCount;
  }
   else {
    addEventListener_0(this.img, 'load', new HtmlImage$1_0(this, callback), false);
    addEventListener_0(this.img, 'error', new HtmlImage$2_0(this, callback), false);
  }
}
;
_.clearTexture = function clearTexture_0(){
  !!this.ctx && $clearTexture(this);
}
;
_.draw_0 = function draw_38(ctx, x, y, width, height){
  $drawImage(ctx, this.img, x, y, width, height);
}
;
_.draw_1 = function draw_39(ctx, dx, dy, dw, dh, sx, sy, sw, sh){
  $draw_4(this, ctx, dx, dy, dw, dh, sx, sy, sw, sh);
}
;
_.height_1 = function height_3(){
  return !this.img?0:$invScaled(this.scale_0, this.img.height);
}
;
_.isReady = function isReady(){
  return this.img.complete;
}
;
_.toPattern = function toPattern_0(){
  this.img.complete;
  return new HtmlPattern_1(this, this.repeatX, this.repeatY);
}
;
_.updateTexture = function updateTexture(tex){
  $updateTexture(this, tex);
}
;
_.width_1 = function width_3(){
  return !this.img?0:$invScaled(this.scale_0, this.img.width);
}
;
_.img = null;
function $ensureTexture(this$static){
  if (this$static.canvas.isDirty) {
    this$static.canvas.isDirty = false;
    this$static.repeatX || this$static.repeatY || this$static.mipmapped?!!this$static.ctx && $clearTexture(this$static):this$static.tex > 0 && $updateTexture(this$static, this$static.tex);
  }
  return this$static.tex > 0?this$static.tex:this$static.img.complete?this$static.repeatX || this$static.repeatY || this$static.mipmapped?(this$static.tex = $scaleTexture(this$static)):(this$static.tex = $createMainTex(this$static)):0;
}

function HtmlCanvasImage_0(ctx, scale, canvas){
  HtmlImage_0.call(this, ctx, scale, canvas.canvas);
  this.canvas = canvas;
}

defineSeed(745, 746, {}, HtmlCanvasImage_0);
_.ensureTexture = function ensureTexture_0(){
  return $ensureTexture(this);
}
;
_.canvas = null;
function $clinit_HtmlFont(){
  $clinit_HtmlFont = nullMethod;
  DEFAULT = new HtmlFont_0('sans-serif', ($clinit_Font$Style() , PLAIN), 12);
}

function HtmlFont_0(name_0, style, size){
  $clinit_HtmlFont();
  AbstractFont_0.call(this, name_0.indexOf('"') != 0 && name_0.indexOf(' ') != -1?'"' + name_0 + '"':name_0, style, size);
}

defineSeed(747, 640, makeCastMap([Q$AbstractFont]), HtmlFont_0);
var DEFAULT;
function $adjustWidth(this$static, width){
  switch (this$static.font_0.style_0.ordinal) {
    case 2:
      return width + this$static.emwidth / 8;
    case 3:
      return width + this$static.emwidth / 6;
    default:return width;
  }
}

function $descent(this$static){
  return this$static.height_0 - 0.699999988079071 * this$static.height_0;
}

function HtmlFontMetrics_0(font, height, emwidth){
  this.font_0 = font;
  this.height_0 = height;
  this.emwidth = emwidth;
}

defineSeed(748, 1, {}, HtmlFontMetrics_0);
_.emwidth = 0;
_.font_0 = null;
_.height_0 = 0;
function $createObject(this$static, object, type){
  $push(this$static.webGLObjects, object);
  $push_0(this$static.webGLObjectTypes, type.ordinal);
  return this$static.webGLObjects.length - 1;
}

function $deleteObject(this$static, index, type){
  var object;
  object = this$static.webGLObjects[index];
  this$static.webGLObjects[index] = null;
  this$static.webGLObjectTypes[index] = ($clinit_HtmlGL20$WebGLObjectType() , NULL).ordinal;
  switch (type.ordinal) {
    case 1:
      $deleteBuffer(this$static.gl, object);
      break;
    case 2:
      $deleteFramebuffer(this$static.gl, object);
      break;
    case 3:
      $deleteProgram(this$static.gl, object);
      break;
    case 4:
      $deleteRenderbuffer(this$static.gl, object);
      break;
    case 5:
      $deleteShader(this$static.gl, object);
      break;
    case 6:
      $deleteTexture(this$static.gl, object);
  }
}

function $deleteObjects(this$static, indices, type){
  var i;
  for (i = 0; i < 1; ++i) {
    $deleteObject(this$static, indices[i], type);
  }
}

function $genObject(this$static, type){
  switch (type.ordinal) {
    case 1:
      return this$static.gl.createBuffer();
    case 2:
      return this$static.gl.createFramebuffer();
    case 3:
      return this$static.gl.createProgram();
    case 4:
      return this$static.gl.createRenderbuffer();
    case 6:
      return this$static.gl.createTexture();
    default:throw new RuntimeException_1('genObject(s) not supported for type ' + type);
  }
}

function $genObjects(this$static, names, type){
  var i, object;
  for (i = 0; i < 1; ++i) {
    object = $genObject(this$static, type);
    names[i] = $createObject(this$static, object, type);
  }
}

--></script>
<script><!--
function $getTypedArray(buffer, type, byteSize){
  var arrayHolder, bufferElementSize, byteOffset, webGLArray;
  if (!instanceOf(buffer, Q$HasArrayBufferView)) {
    throw new RuntimeException_1('Native buffer required ' + buffer);
  }
  arrayHolder = buffer;
  bufferElementSize = arrayHolder.getElementSize();
  webGLArray = arrayHolder.getTypedArray();
  byteSize == -1 && (byteSize = (buffer.limit - buffer.position_0) * bufferElementSize);
  if (byteSize == buffer.capacity * bufferElementSize && type == arrayHolder.getElementType()) {
    return webGLArray;
  }
  byteOffset = webGLArray.byteOffset + buffer.position_0 * bufferElementSize;
  switch (type) {
    case 5126:
      return create_1(webGLArray.buffer, byteOffset, ~~(byteSize / 4));
    case 5121:
      return create_6(webGLArray.buffer, byteOffset, byteSize);
    case 5123:
      return create_5(webGLArray.buffer, byteOffset, ~~(byteSize / 2));
    case 5124:
      return create_3(webGLArray.buffer, byteOffset, ~~(byteSize / 4));
    case 5122:
      return create_2(webGLArray.buffer, byteOffset, ~~(byteSize / 2));
    case 5120:
      return create_4(webGLArray.buffer, byteOffset, byteSize);
    default:throw new IllegalArgumentException_1('Type: ' + type);
  }
}

function $glBindBuffer(this$static, target, buffer){
  var webGlBuf;
  webGlBuf = this$static.webGLObjects[buffer];
  target == 34962?(this$static.requestedArrayBuffer = webGlBuf):target == 34963?(this$static.requestedElementArrayBuffer = webGlBuf):$bindBuffer(this$static.gl, target, webGlBuf);
}

function $glBindFramebuffer(this$static, framebuffer){
  $bindFramebuffer(this$static.gl, 36160, this$static.webGLObjects[framebuffer]);
}

function $glBindTexture(this$static, textureId){
  $bindTexture(this$static.gl, 3553, this$static.webGLObjects[textureId]);
}

function $glBufferData(this$static, target, byteSize, data, usage){
  if (target == 34962) {
    if (this$static.requestedArrayBuffer != this$static.boundArrayBuffer) {
      $bindBuffer(this$static.gl, 34962, this$static.requestedArrayBuffer);
      this$static.boundArrayBuffer = this$static.requestedArrayBuffer;
    }
  }
   else if (target == 34963) {
    if (this$static.requestedElementArrayBuffer != this$static.boundElementArrayBuffer) {
      $bindBuffer(this$static.gl, 34963, this$static.requestedElementArrayBuffer);
      this$static.boundElementArrayBuffer = this$static.requestedElementArrayBuffer;
    }
  }
  $bufferData(this$static.gl, target, $getTypedArray(data, 5120, byteSize), usage);
}

function $glClear(this$static, mask){
  $clear_1(this$static.gl, mask);
}

function $glClearColor(this$static, f, g, h_0, i){
  $clearColor(this$static.gl, f, g, h_0, i);
}

function $glCompileShader(this$static, shader){
  $compileShader(this$static.gl, this$static.webGLObjects[shader]);
}

function $glCreateShader(this$static, type){
  return $createObject(this$static, $createShader(this$static.gl, type), ($clinit_HtmlGL20$WebGLObjectType() , SHADER));
}

function $glDisableVertexAttribArray(this$static, index){
  this$static.enabledArrays &= ~(1 << index);
}

function $glDrawElements(this$static, count){
  $prepareDraw(this$static);
  if (this$static.requestedElementArrayBuffer != this$static.boundElementArrayBuffer) {
    $bindBuffer(this$static.gl, 34963, this$static.requestedElementArrayBuffer);
    this$static.boundElementArrayBuffer = this$static.requestedElementArrayBuffer;
  }
  $drawElements(this$static.gl, 4, count, 5123, 0);
}

function $glEnableVertexAttribArray(this$static, index){
  this$static.enabledArrays |= 1 << index;
}

function $glFramebufferTexture2D(this$static, texture){
  $framebufferTexture2D(this$static.gl, 36160, 36064, 3553, this$static.webGLObjects[texture], 0);
}

function $glGetAttribLocation(this$static, program, name_0){
  return $getAttribLocation(this$static.gl, this$static.webGLObjects[program], name_0);
}

function $glGetShaderInfoLog(this$static, shader){
  return $getShaderInfoLog(this$static.gl, this$static.webGLObjects[shader]);
}

function $glGetShaderiv(this$static, shader, params){
  params[0] = $getShaderParameterb(this$static.gl, this$static.webGLObjects[shader], 35713)?1:0;
}

function $glGetUniformLocation(this$static, program, name_0){
  return $createObject(this$static, $getUniformLocation(this$static.gl, this$static.webGLObjects[program], name_0), ($clinit_HtmlGL20$WebGLObjectType() , UNIFORM_LOCATION));
}

function $glShaderSource(this$static, shader, string){
  $shaderSource(this$static.gl, this$static.webGLObjects[shader], string);
}

function $glTexImage2D(this$static, width, height){
  $texImage2D(this$static.gl, 3553, 0, 6408, width, height, 0, 6408, 5121, null);
}

function $glTexParameteri(this$static, glTextureMinFilter, glFilterMin){
  $texParameteri(this$static.gl, 3553, glTextureMinFilter, glFilterMin);
}

function $glUniform1i(this$static, location_0){
  $uniform1i(this$static.gl, this$static.webGLObjects[location_0], 0);
}

function $glUniform2f(this$static, location_0, x, y){
  $uniform2f(this$static.gl, this$static.webGLObjects[location_0], x, y);
}

function $glUniform4fv(this$static, location_0, count, v){
  $uniform4fv(this$static.gl, this$static.webGLObjects[location_0], $getTypedArray(v, 5126, 16 * count));
}

function $glUseProgram(this$static, program){
  $useProgram(this$static.gl, this$static.webGLObjects[program]);
}

function $glVertexAttribPointer(this$static, indx, size, type, stride, ptr){
  this$static.useNioBuffer &= ~(1 << indx);
  if (this$static.boundArrayBuffer != this$static.requestedArrayBuffer) {
    $bindBuffer(this$static.gl, 34962, this$static.requestedArrayBuffer);
    this$static.boundArrayBuffer = this$static.requestedArrayBuffer;
  }
  $vertexAttribPointer(this$static.gl, indx, size, type, false, stride, ptr);
}

function $glViewport(this$static, w, h_0){
  $viewport(this$static.gl, 0, 0, w, h_0);
}

function $prepareDraw(this$static){
  var data, elementSize, enabled, i, mask, previousElementSize, previousNio;
  previousNio = null;
  previousElementSize = 0;
  if (this$static.useNioBuffer == 0 && this$static.enabledArrays == this$static.previouslyEnabledArrays) {
    return;
  }
  for (i = 0; i < 5; ++i) {
    mask = 1 << i;
    enabled = this$static.enabledArrays & mask;
    enabled != (this$static.previouslyEnabledArrays & mask) && (enabled != 0?$enableVertexAttribArray(this$static.gl, i):$disableVertexAttribArray(this$static.gl, i));
    if (enabled != 0 && (this$static.useNioBuffer & mask) != 0) {
      data = this$static.vertexAttribArrayState[i];
      if (!!previousNio && previousNio.nioBufferLimit >= data.nioBufferLimit) {
        if (this$static.boundArrayBuffer != previousNio.webGlBuffer) {
          $bindBuffer(this$static.gl, 34962, previousNio.webGlBuffer);
          this$static.boundArrayBuffer = data.webGlBuffer;
        }
        $vertexAttribPointer(this$static.gl, i, data.size, data.type_0, data.normalize, data.stride, data.nioBufferPosition * previousElementSize);
      }
       else {
        if (this$static.boundArrayBuffer != data.webGlBuffer) {
          $bindBuffer(this$static.gl, 34962, data.webGlBuffer);
          this$static.boundArrayBuffer = data.webGlBuffer;
        }
        elementSize = getElementSize_2();
        null.nullMethod();
        if (data.nioBufferPosition * elementSize < data.stride) {
          null.nullMethod();
          $bufferData(this$static.gl, 34962, $getTypedArray(data.nioBuffer, data.type_0, data.nioBufferLimit * elementSize), 35040);
          $vertexAttribPointer(this$static.gl, i, data.size, data.type_0, data.normalize, data.stride, data.nioBufferPosition * elementSize);
          previousNio = data;
          previousElementSize = elementSize;
        }
         else {
          null.nullMethod();
          $bufferData(this$static.gl, 34962, $getTypedArray(data.nioBuffer, data.type_0, (data.nioBufferLimit - data.nioBufferPosition) * elementSize), 35040);
          $vertexAttribPointer(this$static.gl, i, data.size, data.type_0, data.normalize, data.stride, 0);
        }
        null.nullMethod();
      }
    }
  }
  this$static.previouslyEnabledArrays = this$static.enabledArrays;
}

function HtmlGL20_0(gl){
  var data, i;
  this.vertexAttribArrayState = initDim(_3Lplayn_html_HtmlGL20$VertexAttribArrayState_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$HtmlGL20$VertexAttribArrayState, 5, 0);
  this.webGLObjects = [];
  this.webGLObjectTypes = [];
  this.gl = gl;
  $push(this.webGLObjects, null);
  $push_0(this.webGLObjectTypes, ($clinit_HtmlGL20$WebGLObjectType() , NULL).ordinal);
  gl.createBuffer();
  for (i = 0; i < 5; ++i) {
    data = new HtmlGL20$VertexAttribArrayState_0;
    data.webGlBuffer = gl.createBuffer();
    this.vertexAttribArrayState[i] = data;
  }
}

defineSeed(749, 1, {}, HtmlGL20_0);
_.boundArrayBuffer = null;
_.boundElementArrayBuffer = null;
_.enabledArrays = 0;
_.gl = null;
_.previouslyEnabledArrays = 0;
_.requestedArrayBuffer = null;
_.requestedElementArrayBuffer = null;
_.useNioBuffer = 0;
function HtmlGL20$VertexAttribArrayState_0(){
}

defineSeed(750, 1, makeCastMap([Q$HtmlGL20$VertexAttribArrayState]), HtmlGL20$VertexAttribArrayState_0);
_.nioBuffer = null;
_.nioBufferLimit = 0;
_.nioBufferPosition = 0;
_.normalize = false;
_.size = 0;
_.stride = 0;
_.type_0 = 0;
_.webGlBuffer = null;
function $clinit_HtmlGL20$WebGLObjectType(){
  $clinit_HtmlGL20$WebGLObjectType = nullMethod;
  NULL = new HtmlGL20$WebGLObjectType_0('NULL', 0);
  BUFFER = new HtmlGL20$WebGLObjectType_0('BUFFER', 1);
  FRAME_BUFFER = new HtmlGL20$WebGLObjectType_0('FRAME_BUFFER', 2);
  PROGRAM = new HtmlGL20$WebGLObjectType_0('PROGRAM', 3);
  RENDER_BUFFER = new HtmlGL20$WebGLObjectType_0('RENDER_BUFFER', 4);
  SHADER = new HtmlGL20$WebGLObjectType_0('SHADER', 5);
  TEXTURE = new HtmlGL20$WebGLObjectType_0('TEXTURE', 6);
  UNIFORM_LOCATION = new HtmlGL20$WebGLObjectType_0('UNIFORM_LOCATION', 7);
  $VALUES_30 = initValues(_3Lplayn_html_HtmlGL20$WebGLObjectType_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$HtmlGL20$WebGLObjectType, [NULL, BUFFER, FRAME_BUFFER, PROGRAM, RENDER_BUFFER, SHADER, TEXTURE, UNIFORM_LOCATION]);
}

function HtmlGL20$WebGLObjectType_0(enum$name, enum$ordinal){
  Enum_0.call(this, enum$name, enum$ordinal);
}

function values_31(){
  $clinit_HtmlGL20$WebGLObjectType();
  return $VALUES_30;
}

defineSeed(751, 11, makeCastMap([Q$Serializable, Q$Comparable, Q$Enum, Q$HtmlGL20$WebGLObjectType]), HtmlGL20$WebGLObjectType_0);
var $VALUES_30, BUFFER, FRAME_BUFFER, NULL, PROGRAM, RENDER_BUFFER, SHADER, TEXTURE, UNIFORM_LOCATION;
function $tryBasicGLCalls(this$static){
  var err, pixelData, testFloat32Array, testInt32Array, testUint16Array, testUint8Array;
  testFloat32Array = createFloat32Array(toJsArray(initValues(_3F_classLit, makeCastMap([Q$Serializable]), -1, [0, 1, 2])));
  if (testFloat32Array[0] != 0 || testFloat32Array[1] != 1 || testFloat32Array[2] != 2) {
    throw new RuntimeException_1('Typed Float32Array check failed');
  }
  testInt32Array = createInt32Array(toJsArray_0(initValues(_3I_classLit, makeCastMap([Q$int_$1, Q$Serializable]), -1, [0, 1, 2])));
  if (testInt32Array[0] != 0 || testInt32Array[1] != 1 || testInt32Array[2] != 2) {
    throw new RuntimeException_1('Typed Int32Array check failed');
  }
  testUint16Array = createUint16Array(toJsArray_0(initValues(_3I_classLit, makeCastMap([Q$int_$1, Q$Serializable]), -1, [0, 1, 2])));
  if (testUint16Array[0] != 0 || testUint16Array[1] != 1 || testUint16Array[2] != 2) {
    throw new RuntimeException_1('Typed Uint16Array check failed');
  }
  testUint8Array = createUint8Array(toJsArray_0(initValues(_3I_classLit, makeCastMap([Q$int_$1, Q$Serializable]), -1, [0, 1, 2])));
  if (testUint8Array[0] != 0 || testUint8Array[1] != 1 || testUint8Array[2] != 2) {
    throw new RuntimeException_1('Typed Uint8Array check failed');
  }
  $bindFramebuffer_0(this$static, 0, this$static.defaultFbufWidth, this$static.defaultFbufHeight);
  $glClearColor(this$static.gl, 1, 1, 1, 1);
  $glClear(this$static.gl, 16384);
  err = this$static.glc.getError();
  if (err != 0) {
    throw new RuntimeException_1('Read back GL test failed to clear color (error ' + err + ')');
  }
  pixelData = new Uint8Array(4);
  $readPixels(this$static.glc, 0, 0, 1, 1, 6408, 5121, pixelData);
  if (pixelData[0] != 255 || pixelData[1] != 255 || pixelData[2] != 255) {
    throw new RuntimeException_1('Read back GL test failed to read back correct color');
  }
}

function $updateTexture_0(this$static, tex, img){
  $glBindTexture(this$static.gl, tex);
  $texImage2D_0(this$static.glc, 3553, 0, 6408, 6408, 5121, img);
}

function HtmlGLContext_0(platform, gl, canvas){
  GL20Context_0.call(this, platform, new HtmlGL20_0(gl), ($clinit_HtmlUrlParameters() , checkGLErrors));
  this.glc = gl;
  $tryBasicGLCalls(this);
  $setSize(this, iceil(canvas.width), iceil(canvas.height));
  this.gl.gl.disable(2884);
  this.gl.gl.enable(3042);
  this.gl.gl.blendFunc(1, 771);
  $glClearColor(this.gl, 0, 0, 0, 1);
  !!this.quadShader && $clearProgram(this.quadShader);
  !!this.trisShader && $clearProgram(this.trisShader);
  this.quadShader = $createQuadShader(this);
  this.trisShader = new IndexedTrisShader_0(this);
  $checkGLError(this, 'initGL');
  this.glc.pixelStorei(37441, 1);
}

defineSeed(752, 704, {}, HtmlGLContext_0);
_.createTransform = function createTransform_0(){
  return new HtmlInternalTransform_0;
}
;
_.glc = null;
function HtmlGame$1_0(){
}

defineSeed(753, 1, {}, HtmlGame$1_0);
function HtmlGame$2_0(){
}

defineSeed(754, 1, {}, HtmlGame$2_0);
_.execute = function execute_10(){
  var config, platform, platform_0;
  config = new HtmlPlatform$Config_0;
  config.mode = 1;
  platform = ($clinit_HtmlPlatform() , platform_0 = new HtmlPlatform_0(config) , platform_1 = platform_0 , $init_0(platform_0.audio) , $init_1(platform_0.keyboard) , platform_0);
  platform.assets.pathPrefix = 'playn/';
  run_1(new PlaynNewtonAdventureGameHtml$1_0);
}
;
function $createImage(this$static, width, height){
  return new HtmlCanvasImage_0(this$static.ctx_1(), this$static.scale_4(), create_9(this$static.scale_4(), width, height));
}

function $getFontMetrics(this$static, font){
  var emwidth, height, metrics;
  metrics = this$static.fontMetrics.get_1(font);
  if (!metrics) {
    this$static.measureElement.style['fontSize'] = font.size + ($clinit_Style$Unit() , 'px');
    this$static.measureElement.style['fontWeight'] = ($clinit_Style$FontWeight() , 'normal');
    this$static.measureElement.style['fontStyle'] = ($clinit_Style$FontStyle() , 'normal');
    this$static.measureElement.style['fontFamily'] = font.name_0;
    $setInnerText(this$static.measureElement, 'THEQUICKBROWNFOXJUMPEDOVERTHELAZYDOGthequickbrownfoxjumpedoverthelazydog_-+!.,[]0123456789');
    switch (font.style_0.ordinal) {
      case 1:
        this$static.measureElement.style['fontWeight'] = 'bold';
        break;
      case 2:
        this$static.measureElement.style['fontStyle'] = 'italic';
        break;
      case 3:
        this$static.measureElement.style['fontWeight'] = 'bold';
        this$static.measureElement.style['fontStyle'] = 'italic';
    }
    height = this$static.measureElement.offsetHeight || 0;
    $setInnerText(this$static.measureElement, 'm');
    emwidth = this$static.measureElement.offsetWidth || 0;
    metrics = new HtmlFontMetrics_0(font, height, emwidth);
    this$static.fontMetrics.put(font, metrics);
  }
  return metrics;
}

function $layoutText(this$static, text, format){
  return layoutText(this$static, this$static.dummyCtx, text, format);
}

function $transformMouse(this$static, x, y){
  return $set_9(this$static.mousePoint, x / this$static.scale_4().factor, y / this$static.scale_4().factor);
}

function HtmlGraphics_0(){
  var doc;
  this.mousePoint = new Point_0;
  this.fontMetrics = new HashMap_0;
  doc = $doc;
  this.dummyCanvas = doc.createElement('canvas');
  this.dummyCtx = this.dummyCanvas.getContext('2d');
  this.rootElement = doc.getElementById('playn-root');
  if (!this.rootElement) {
    this.rootElement = doc.createElement('div');
    this.rootElement.setAttribute('style', 'width: 640px; height: 480px');
    $appendChild(doc.body, this.rootElement);
  }
   else {
    this.rootElement.innerHTML = '';
  }
  this.measureElement = doc.createElement('div');
  this.measureElement.style['visibility'] = ($clinit_Style$Visibility() , 'hidden');
  this.measureElement.style['position'] = ($clinit_Style$Position() , 'absolute');
  this.measureElement.style['top'] = -500 + ($clinit_Style$Unit() , 'px');
  this.measureElement.style['overflow'] = ($clinit_Style$Overflow() , 'visible');
  this.measureElement.style['whiteSpace'] = ($clinit_Style$WhiteSpace() , 'nowrap');
  $appendChild(this.rootElement, this.measureElement);
}

function cssColorString(color){
  var a, b, g, r;
  a = (~~color >> 24 & 255) / 255;
  r = ~~color >> 16 & 255;
  g = ~~color >> 8 & 255;
  b = color & 255;
  return 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';
}

defineSeed(755, 1, {});
_.ctx_0 = function ctx_0(){
  return this.ctx_1();
}
;
_.ctx_1 = function ctx_1(){
  return null;
}
;
_.dummyCanvas = null;
_.dummyCtx = null;
_.measureElement = null;
_.rootElement = null;
function $height_0(this$static){
  return ifloor($invScaled(this$static.scale_0, this$static.elem.offsetHeight || 0));
}

function $width_0(this$static){
  return ifloor($invScaled(this$static.scale_0, this$static.elem.offsetWidth || 0));
}

function HtmlGraphicsCanvas_0(){
  HtmlGraphics_0.call(this);
  this.scale_0 = new Scale_0(1);
  this.rootLayer = new GroupLayerCanvas_0(($clinit_HtmlPlatform() , hasTypedArraySupport)?new HtmlInternalTransform_0:new StockInternalTransform_0);
  this.elem = $doc.createElement('canvas');
  $setWidth(this.elem, this.rootElement.offsetWidth || 0);
  $setHeight(this.elem, this.rootElement.offsetHeight || 0);
  $appendChild(this.rootElement, this.elem);
  this.ctx = this.elem.getContext('2d');
  this.ctx.scale(1, 1);
  this.canvas = new HtmlGraphicsCanvas$1_0(this, this.ctx);
}

defineSeed(756, 755, {}, HtmlGraphicsCanvas_0);
_.createImmediateLayer = function createImmediateLayer(renderer){
  return new ImmediateLayerCanvas_0(($clinit_HtmlPlatform() , hasTypedArraySupport)?new HtmlInternalTransform_0:new StockInternalTransform_0, renderer);
}
;
_.height_2 = function height_4(){
  return $height_0(this);
}
;
_.paint_1 = function paint_3(){
  $clear_5(this.canvas);
  $paint(this.rootLayer, this.canvas, 1);
  $setAlpha(this.canvas, 1);
}
;
_.rootElement_0 = function rootElement_0(){
  return this.elem;
}
;
_.rootLayer_0 = function rootLayer_0(){
  return this.rootLayer;
}
;
_.scale_4 = function scale_7(){
  return this.scale_0;
}
;
_.width_2 = function width_4(){
  return $width_0(this);
}
;
_.canvas = null;
_.ctx = null;
_.elem = null;
_.rootLayer = null;
_.scale_0 = null;
function HtmlGraphicsCanvas$1_0(this$0, $anonymous0){
  this.this$0 = this$0;
  AbstractHtmlCanvas_0.call(this, $anonymous0, 0, 0);
}

defineSeed(757, 739, {}, HtmlGraphicsCanvas$1_0);
_.height_1 = function height_5(){
  return $height_0(this.this$0);
}
;
_.width_1 = function width_5(){
  return $width_0(this.this$0);
}
;
_.this$0 = null;
function HtmlGraphicsGL_0(platform){
  var $e0, attrs, error, gl, re;
  HtmlGraphics_0.call(this);
  this.canvas = $doc.createElement('canvas');
  $setWidth(this.canvas, this.rootElement.offsetWidth || 0);
  $setHeight(this.canvas, this.rootElement.offsetHeight || 0);
  $appendChild(this.rootElement, this.canvas);
  try {
    attrs = {premultipliedAlpha:false};
    attrs.alpha = false;
    attrs.antialias = true;
    gl = getContext(this.canvas, attrs);
    if (!gl)
      throw new RuntimeException_1('Unable to create GL context');
    error = gl.getError();
    if (error != 0)
      throw new RuntimeException_1('GL context started with errors [err=' + error + ']');
    this.ctx = new HtmlGLContext_0(platform, gl, this.canvas);
    this.rootLayer = new GroupLayerGL_0;
  }
   catch ($e0) {
    $e0 = caught_0($e0);
    if (instanceOf($e0, Q$RuntimeException)) {
      re = $e0;
      $removeChild(this.rootElement, this.canvas);
      throw re;
    }
     else 
      throw $e0;
  }
}

defineSeed(758, 755, {}, HtmlGraphicsGL_0);
_.createImmediateLayer = function createImmediateLayer_0(renderer){
  return new ImmediateLayerGL_0(this.ctx, renderer);
}
;
_.ctx_0 = function ctx_2(){
  return this.ctx;
}
;
_.ctx_1 = function ctx_3(){
  return this.ctx;
}
;
_.height_2 = function height_6(){
  return this.ctx.viewHeight;
}
;
_.paint_1 = function paint_4(){
  $paint_0(this.ctx, this.rootLayer);
}
;
_.rootElement_0 = function rootElement_1(){
  return this.canvas;
}
;
_.rootLayer_0 = function rootLayer_1(){
  return this.rootLayer;
}
;
_.scale_4 = function scale_8(){
  return this.ctx.scale_0;
}
;
_.width_2 = function width_6(){
  return this.ctx.viewWidth;
}
;
_.canvas = null;
_.ctx = null;
_.rootLayer = null;
function HtmlImage$1_0(this$0, val$callback){
  this.this$0 = this$0;
  this.val$callback = val$callback;
}

defineSeed(759, 1, {}, HtmlImage$1_0);
_.handleEvent = function handleEvent(evt){
  $onSuccess_4(this.val$callback);
}
;
_.this$0 = null;
_.val$callback = null;
function HtmlImage$2_0(this$0, val$callback){
  this.this$0 = this$0;
  this.val$callback = val$callback;
}

defineSeed(760, 1, {}, HtmlImage$2_0);
_.handleEvent = function handleEvent_0(evt){
  $onFailure(this.val$callback, new RuntimeException_1('Error loading image ' + this.this$0.img.src));
}
;
_.this$0 = null;
_.val$callback = null;
function getRelativeX(e, target){
  return (e.clientX || 0) - $getAbsoluteLeft(target) + $getScrollLeft(target) + $getScrollLeft(target.ownerDocument.body);
}

function getRelativeY(e, target){
  return (e.clientY || 0) - $getAbsoluteTop(target) + (target.scrollTop || 0) + (target.ownerDocument.body.scrollTop || 0);
}

function HtmlInput$1_0(val$handler){
  this.val$handler = val$handler;
}

defineSeed(762, 1, {}, HtmlInput$1_0);
_.handleEvent = function handleEvent_1(evt){
  this.val$handler.handleEvent(evt);
}
;
_.val$handler = null;
function $clinit_HtmlInternalTransform(){
  $clinit_HtmlInternalTransform = nullMethod;
  new HtmlInternalTransform_0;
}

function $concatenate(this$static, m00, m01, m10, m11, tx, ty, originX, originY){
  multiply(this$static.matrix[0], this$static.matrix[1], this$static.matrix[2], this$static.matrix[3], this$static.matrix[4], this$static.matrix[5], 1, 0, 0, 1, originX, originY, this$static);
  multiply(this$static.matrix[0], this$static.matrix[1], this$static.matrix[2], this$static.matrix[3], this$static.matrix[4], this$static.matrix[5], m00, m01, m10, m11, tx - originX, ty - originY, this$static);
  multiply(this$static.matrix[0], this$static.matrix[1], this$static.matrix[2], this$static.matrix[3], this$static.matrix[4], this$static.matrix[5], 1, 0, 0, 1, -originX, -originY, this$static);
  return this$static;
}

function $concatenate_0(this$static, other, originX, originY){
  var ot;
  ot = other;
  return $concatenate(this$static, ot.matrix[0], ot.matrix[1], ot.matrix[2], ot.matrix[3], ot.matrix[4], ot.matrix[5], originX, originY);
}

function $preConcatenate(this$static, other){
  multiply_0(other.m00_0(), other.m01_0(), other.m10_0(), other.m11_0(), other.tx_0(), other.ty_0(), this$static, this$static);
  return this$static;
}

function $set_8(this$static, other){
  $set_2(this$static.matrix, other.matrix);
  return this$static;
}

function $setM00(this$static, value){
  this$static.matrix[0] = value;
}

function $setM01(this$static, value){
  this$static.matrix[1] = value;
}

function $setM10(this$static, value){
  this$static.matrix[2] = value;
}

function $setM11(this$static, value){
  this$static.matrix[3] = value;
}

function $setRotation(this$static, angle){
  var cosa, sina, sx, sy;
  sx = sqrt(this$static.matrix[0] * this$static.matrix[0] + this$static.matrix[1] * this$static.matrix[1]);
  sy = sqrt(this$static.matrix[2] * this$static.matrix[2] + this$static.matrix[3] * this$static.matrix[3]);
  sina = Math.sin(angle);
  cosa = Math.cos(angle);
  this$static.matrix[0] = cosa * sx;
  this$static.matrix[1] = sina * sx;
  this$static.matrix[2] = -sina * sy;
  this$static.matrix[3] = cosa * sy;
  return this$static;
}

function $setTx(this$static, tx){
  this$static.matrix[4] = tx;
  return this$static;
}

function $setTy(this$static, ty){
  this$static.matrix[5] = ty;
  return this$static;
}

function HtmlInternalTransform_0(){
  $clinit_HtmlInternalTransform();
  HtmlInternalTransform_2.call(this, initValues(_3F_classLit, makeCastMap([Q$Serializable]), -1, [1, 0, 0, 1, 0, 0]));
}

function HtmlInternalTransform_1(matrix){
  this.matrix = matrix;
}

function HtmlInternalTransform_2(matrix){
  HtmlInternalTransform_1.call(this, createFloat32Array(toJsArray(matrix)));
}

function multiply(am00, am01, am10, am11, atx, aty, bm00, bm01, bm10, bm11, btx, bty, into){
  $set_1(into.matrix, initValues(_3F_classLit, makeCastMap([Q$Serializable]), -1, [am00 * bm00 + am10 * bm01, am01 * bm00 + am11 * bm01, am00 * bm10 + am10 * bm11, am01 * bm10 + am11 * bm11, am00 * btx + am10 * bty + atx, am01 * btx + am11 * bty + aty]), 0);
  return into;
}

function multiply_0(m00, m01, m10, m11, tx, ty, b, into){
  return multiply(m00, m01, m10, m11, tx, ty, b.matrix[0], b.matrix[1], b.matrix[2], b.matrix[3], b.matrix[4], b.matrix[5], into);
}

defineSeed(763, 681, {}, HtmlInternalTransform_0);
_.concatenate = function concatenate_0(m00, m01, m10, m11, tx, ty, originX, originY){
  return $concatenate(this, m00, m01, m10, m11, tx, ty, originX, originY);
}
;
_.inverseTransform = function inverseTransform_0(p, into){
  var det, m00, m01, m10, m11, rdet, x, y;
  m00 = this.matrix[0];
  m01 = this.matrix[1];
  m10 = this.matrix[2];
  m11 = this.matrix[3];
  x = p.x - this.matrix[4];
  y = p.y - this.matrix[5];
  det = m00 * m11 - m01 * m10;
  if (abs(det) == 0) {
    throw new NoninvertibleTransformException_0('affine [' + toString_61(this.matrix[0]) + ' ' + toString_61(this.matrix[1]) + ' ' + toString_61(this.matrix[2]) + ' ' + toString_61(this.matrix[3]) + ' ' + new Vector_0(this.matrix[4], this.matrix[5]) + ']');
  }
  rdet = 1 / det;
  return into.x = (x * m11 - y * m10) * rdet , into.y = (y * m00 - x * m01) * rdet , into;
}
;
_.m00_0 = function m00_1(){
  return this.matrix[0];
}
;
_.m01_0 = function m01_1(){
  return this.matrix[1];
}
;
_.m10_0 = function m10_1(){
  return this.matrix[2];
}
;
_.m11_0 = function m11_1(){
  return this.matrix[3];
}
;
_.scaleX = function scaleX_2(scaleX){
  $setM00(this, this.matrix[0] * scaleX);
  $setM01(this, this.matrix[1] * scaleX);
  $setTx(this, this.matrix[4] * scaleX);
  return this;
}
;
_.scaleY = function scaleY_2(scaleY){
  $setM10(this, this.matrix[2] * scaleY);
  $setM11(this, this.matrix[3] * scaleY);
  $setTy(this, this.matrix[5] * scaleY);
  return this;
}
;
_.set_1 = function set_1(other){
  return $set_8(this, other);
}
;
_.setTransform = function setTransform_1(m00, m01, m10, m11, tx, ty){
  return $set_1(this.matrix, initValues(_3F_classLit, makeCastMap([Q$Serializable]), -1, [m00, m01, m10, m11, tx, ty]), 0) , this;
}
;
_.toString$ = function toString_56(){
  return 'affine [' + toString_61(this.matrix[0]) + ' ' + toString_61(this.matrix[1]) + ' ' + toString_61(this.matrix[2]) + ' ' + toString_61(this.matrix[3]) + ' ' + new Vector_0(this.matrix[4], this.matrix[5]) + ']';
}
;
_.translate_1 = function translate_4(tx, ty){
  return multiply(this.matrix[0], this.matrix[1], this.matrix[2], this.matrix[3], this.matrix[4], this.matrix[5], 1, 0, 0, 1, tx, ty, this);
}
;
_.translateX = function translateX_1(tx){
  return multiply(this.matrix[0], this.matrix[1], this.matrix[2], this.matrix[3], this.matrix[4], this.matrix[5], 1, 0, 0, 1, tx, 0, this);
}
;
_.translateY = function translateY_1(ty){
  return multiply(this.matrix[0], this.matrix[1], this.matrix[2], this.matrix[3], this.matrix[4], this.matrix[5], 1, 0, 0, 1, 0, ty, this);
}
;
_.tx_0 = function tx_1(){
  return this.matrix[4];
}
;
_.ty_0 = function ty_1(){
  return this.matrix[5];
}
;
_.uniformScale = function uniformScale_1(scale){
  return $scale_1(this, scale, scale);
}
;
_.matrix = null;
function $parse(json){
  var $e0, e, jsonParse, object;
  try {
    jsonParse = JSON.parse(json);
    if (!isValueObject(jsonParse))
      throw new JsonParserException_0(null, 'Input JSON was not an object');
    object = jsonParse;
    return object;
  }
   catch ($e0) {
    $e0 = caught_0($e0);
    if (instanceOf($e0, Q$JavaScriptException)) {
      e = $e0;
      throw new JsonParserException_0(e, 'Failed to parse JSON');
    }
     else 
      throw $e0;
  }
}

function isValueObject(value){
  return value != null && typeof value == 'object' && !(value instanceof Array);
}

function $getArray(this$static, arrayType){
  return new JsonTypedArray_0(this$static['quests'] instanceof Array?this$static['quests']:null, arrayType);
}

function $init_1(this$static){
  captureEvent_0('keydown', new HtmlKeyboard$1_0(this$static));
  captureEvent_0('keypress', new HtmlKeyboard$2_0(this$static));
  captureEvent_0('keyup', new HtmlKeyboard$3_0(this$static));
}

function $setListener_1(this$static, listener){
  this$static.listener = listener;
}

function HtmlKeyboard_0(){
}

--></script>
<script><!--
function keyForCode(keyCode){
  switch (keyCode) {
    case 18:
      return $clinit_Key() , ALT;
    case 8:
      return $clinit_Key() , BACKSPACE;
    case 17:
      return $clinit_Key() , CONTROL;
    case 46:
      return $clinit_Key() , DELETE;
    case 40:
      return $clinit_Key() , DOWN_1;
    case 35:
      return $clinit_Key() , END;
    case 13:
      return $clinit_Key() , ENTER;
    case 27:
      return $clinit_Key() , ESCAPE;
    case 36:
      return $clinit_Key() , HOME;
    case 37:
      return $clinit_Key() , LEFT_2;
    case 34:
      return $clinit_Key() , PAGE_DOWN;
    case 33:
      return $clinit_Key() , PAGE_UP;
    case 39:
      return $clinit_Key() , RIGHT_2;
    case 16:
      return $clinit_Key() , SHIFT;
    case 9:
      return $clinit_Key() , TAB;
    case 38:
      return $clinit_Key() , UP_1;
    case 19:
      return $clinit_Key() , PAUSE;
    case 20:
      return $clinit_Key() , CAPS_LOCK;
    case 32:
      return $clinit_Key() , SPACE;
    case 45:
      return $clinit_Key() , INSERT;
    case 48:
      return $clinit_Key() , K0;
    case 49:
      return $clinit_Key() , K1_0;
    case 50:
      return $clinit_Key() , K2_0;
    case 51:
      return $clinit_Key() , K3_0;
    case 52:
      return $clinit_Key() , K4;
    case 53:
      return $clinit_Key() , K5;
    case 54:
      return $clinit_Key() , K6;
    case 55:
      return $clinit_Key() , K7;
    case 56:
      return $clinit_Key() , K8;
    case 57:
      return $clinit_Key() , K9;
    case 65:
      return $clinit_Key() , A_0;
    case 66:
      return $clinit_Key() , B_0;
    case 67:
      return $clinit_Key() , C_0;
    case 68:
      return $clinit_Key() , D;
    case 69:
      return $clinit_Key() , E;
    case 70:
      return $clinit_Key() , F;
    case 71:
      return $clinit_Key() , G;
    case 72:
      return $clinit_Key() , H;
    case 73:
      return $clinit_Key() , I;
    case 74:
      return $clinit_Key() , J;
    case 75:
      return $clinit_Key() , K_0;
    case 76:
      return $clinit_Key() , L;
    case 77:
      return $clinit_Key() , M;
    case 78:
      return $clinit_Key() , N;
    case 79:
      return $clinit_Key() , O;
    case 80:
      return $clinit_Key() , P;
    case 81:
      return $clinit_Key() , Q;
    case 82:
      return $clinit_Key() , R_0;
    case 83:
      return $clinit_Key() , S;
    case 84:
      return $clinit_Key() , T;
    case 85:
      return $clinit_Key() , U;
    case 86:
      return $clinit_Key() , V;
    case 87:
      return $clinit_Key() , W;
    case 88:
      return $clinit_Key() , X;
    case 89:
      return $clinit_Key() , Y;
    case 90:
      return $clinit_Key() , Z;
    case 92:
    case 91:
      return $clinit_Key() , WINDOWS;
    case 96:
      return $clinit_Key() , NP0;
    case 97:
      return $clinit_Key() , NP1;
    case 98:
      return $clinit_Key() , NP2;
    case 99:
      return $clinit_Key() , NP3;
    case 100:
      return $clinit_Key() , NP4;
    case 101:
      return $clinit_Key() , NP5;
    case 102:
      return $clinit_Key() , NP6;
    case 103:
      return $clinit_Key() , NP7;
    case 104:
      return $clinit_Key() , NP8;
    case 105:
      return $clinit_Key() , NP9;
    case 106:
      return $clinit_Key() , NP_MULTIPLY;
    case 107:
      return $clinit_Key() , NP_ADD;
    case 109:
      return $clinit_Key() , NP_SUBTRACT;
    case 110:
      return $clinit_Key() , NP_DECIMAL;
    case 111:
      return $clinit_Key() , NP_DIVIDE;
    case 112:
      return $clinit_Key() , F1;
    case 113:
      return $clinit_Key() , F2;
    case 114:
      return $clinit_Key() , F3;
    case 115:
      return $clinit_Key() , F4;
    case 116:
      return $clinit_Key() , F5;
    case 117:
      return $clinit_Key() , F6;
    case 118:
      return $clinit_Key() , F7;
    case 119:
      return $clinit_Key() , F8;
    case 120:
      return $clinit_Key() , F9;
    case 121:
      return $clinit_Key() , F10;
    case 122:
      return $clinit_Key() , F11;
    case 123:
      return $clinit_Key() , F12;
    case 144:
      return $clinit_Key() , NP_NUM_LOCK;
    case 145:
      return $clinit_Key() , SCROLL_LOCK;
    case 186:
      return $clinit_Key() , SEMICOLON;
    case 187:
      return $clinit_Key() , EQUALS;
    case 188:
      return $clinit_Key() , COMMA;
    case 189:
      return $clinit_Key() , MINUS;
    case 190:
      return $clinit_Key() , PERIOD;
    case 191:
      return $clinit_Key() , SLASH;
    case 192:
      return $clinit_Key() , BACKQUOTE;
    case 219:
      return $clinit_Key() , LEFT_BRACKET;
    case 220:
      return $clinit_Key() , BACKSLASH;
    case 221:
      return $clinit_Key() , RIGHT_BRACKET;
    case 222:
      return $clinit_Key() , QUOTE;
    default:return $clinit_Key() , UNKNOWN;
  }
}

defineSeed(767, 1, {}, HtmlKeyboard_0);
_.listener = null;
function HtmlKeyboard$1_0(this$0){
  this.this$0 = this$0;
}

defineSeed(768, 1, {}, HtmlKeyboard$1_0);
_.handleEvent = function handleEvent_2(nativeEvent){
  var event_0;
  if (this.this$0.listener) {
    event_0 = new Keyboard$Event$Impl_0(new Events$Flags$Impl_0, now_0(), keyForCode(nativeEvent.keyCode || 0));
    $onKeyDown(this.this$0.listener, event_0);
    event_0.flags.preventDefault_0 && (nativeEvent.preventDefault() , undefined);
  }
}
;
_.this$0 = null;
function HtmlKeyboard$2_0(this$0){
  this.this$0 = this$0;
}

defineSeed(769, 1, {}, HtmlKeyboard$2_0);
_.handleEvent = function handleEvent_3(nativeEvent){
  var event_0;
  if (this.this$0.listener) {
    event_0 = new Keyboard$TypedEvent$Impl_0(new Events$Flags$Impl_0, now_0(), (nativeEvent.charCode || 0) & 65535);
    event_0.flags.preventDefault_0 && (nativeEvent.preventDefault() , undefined);
  }
}
;
_.this$0 = null;
function HtmlKeyboard$3_0(this$0){
  this.this$0 = this$0;
}

defineSeed(770, 1, {}, HtmlKeyboard$3_0);
_.handleEvent = function handleEvent_4(nativeEvent){
  var event_0;
  if (this.this$0.listener) {
    event_0 = new Keyboard$Event$Impl_0(new Events$Flags$Impl_0, now_0(), keyForCode(nativeEvent.keyCode || 0));
    $onKeyUp(this.this$0.listener, event_0);
    event_0.flags.preventDefault_0 && (nativeEvent.preventDefault() , undefined);
  }
}
;
_.this$0 = null;
defineSeed(771, 661, {});
function HtmlLogSimple_0(){
  this.minLevel = ($clinit_Log$Level() , DEBUG);
}

defineSeed(772, 771, {}, HtmlLogSimple_0);
function $handleRequestsInUserEventContext(this$static){
  this$static.isRequestingMouseLock && !$isLocked() && $requestMouseLockImpl(this$static.rootElement);
}

function $hasMouse(){
  return 'onmousedown' in $doc.documentElement && $wnd.navigator.userAgent.match(/ipad|iphone|android/i) == null;
}

function $isLocked(){
  return !!($doc.pointerLockElement || $doc.webkitPointerLockElement || $doc.mozPointerLockElement);
}

function $requestMouseLockImpl(element){
  element.requestPointerLock = element.requestPointerLock || element.webkitRequestPointerLock || element.mozRequestPointerLock;
  element.requestPointerLock && element.requestPointerLock();
}

function HtmlMouse_0(platform, rootElement){
  this.DOWN = new MouseImpl$1_0;
  this.UP = new MouseImpl$2_0;
  this.DRAG = new MouseImpl$3_0;
  this.MOVE = new MouseImpl$4_0;
  this.OVER = new MouseImpl$5_0;
  this.OUT = new MouseImpl$6_0;
  this.WHEEL_SCROLL = new MouseImpl$7_0;
  this.lastMousePt = new Point_0;
  this.rootElement = rootElement;
  addEventListener_0($doc, 'contextmenu', new HtmlMouse$1_0, false);
  captureEvent(rootElement, 'mousedown', new HtmlMouse$2_0(this, platform, rootElement));
  captureEvent_0('mouseup', new HtmlInput$1_0(new HtmlMouse$3_0(this, platform, rootElement)));
  captureEvent_0('mousemove', new HtmlInput$1_0(new HtmlMouse$4_0(this, platform, rootElement)));
  captureEvent(rootElement, 'mousemove', new HtmlMouse$5_0(this, platform, rootElement));
  captureEvent(rootElement, getMouseWheelEvent(), new HtmlMouse$6_0(this));
}

function getMouseButton(evt){
  switch ($eventGetButton(evt)) {
    case 1:
      return 0;
    case 4:
      return 1;
    case 2:
      return 2;
    default:return $eventGetButton(evt);
  }
}

function getMouseWheelEvent(){
  if (navigator.userAgent.toLowerCase().indexOf('firefox') != -1) {
    return 'DOMMouseScroll';
  }
   else {
    return 'mousewheel';
  }
}

function getMouseWheelVelocity(evt){
  var delta = 0;
  var agentInfo = ($clinit_HtmlPlatform() , agentInfo_0);
  if (agentInfo.isFirefox) {
    agentInfo.isMacOS?(delta = 1 * evt.detail):(delta = 1 * evt.detail / 3);
  }
   else if (agentInfo.isOpera) {
    agentInfo.isLinux?(delta = -1 * evt.wheelDelta / 80):(delta = -1 * evt.wheelDelta / 40);
  }
   else if (agentInfo.isChrome || agentInfo.isSafari) {
    delta = -1 * evt.wheelDelta / 120;
    Math.abs(delta) < 1 && (agentInfo.isWindows?(delta = -1 * evt.wheelDelta):agentInfo.isMacOS && (delta = -1 * evt.wheelDelta / 3));
  }
  return delta;
}

defineSeed(773, 665, {}, HtmlMouse_0);
_.inDragSequence = false;
_.isRequestingMouseLock = false;
_.rootElement = null;
function HtmlMouse$1_0(){
}

defineSeed(774, 1, {}, HtmlMouse$1_0);
_.handleEvent = function handleEvent_5(evt){
  evt.preventDefault();
  evt.stopPropagation();
}
;
function HtmlMouse$1XYEventHandler_0(val$platform, val$rootElement){
  this.val$platform = val$platform;
  this.val$rootElement = val$rootElement;
}

defineSeed(776, 1, {});
_.handleEvent = function handleEvent_6(ev){
  var xy;
  xy = $transformMouse(this.val$platform.graphics, getRelativeX(ev, this.val$rootElement), getRelativeY(ev, this.val$rootElement));
  this.handleEvent_0(ev, xy.x, xy.y);
}
;
_.val$platform = null;
_.val$rootElement = null;
function HtmlMouse$1MoveEventHandler_0(this$0, val$platform, val$rootElement){
  this.this$0 = this$0;
  HtmlMouse$1XYEventHandler_0.call(this, val$platform, val$rootElement);
}

defineSeed(775, 776, {});
_.handleEvent_0 = function handleEvent_7(ev, x, y){
  var dx, dy;
  if (this.lastX == -1) {
    this.lastX = x;
    this.lastY = y;
  }
  if (this.this$0.inDragSequence == this.wantDragSequence()) {
    if ($isLocked()) {
      dx = ev.webkitMovementX;
      dy = ev.webkitMovementY;
    }
     else {
      dx = x - this.lastX;
      dy = y - this.lastY;
    }
    $onMouseMove_1(this.this$0, new Mouse$MotionEvent$Impl_0(new Events$Flags$Impl_0, now_0(), x, y, dx, dy)) && (ev.preventDefault() , undefined);
  }
  this.lastX = x;
  this.lastY = y;
  $set_9(this.this$0.lastMousePt, x, y);
}
;
_.lastX = -1;
_.lastY = -1;
_.this$0 = null;
function HtmlMouse$2_0(this$0, val$platform, val$rootElement){
  this.this$0 = this$0;
  HtmlMouse$1XYEventHandler_0.call(this, val$platform, val$rootElement);
}

defineSeed(777, 776, {}, HtmlMouse$2_0);
_.handleEvent_0 = function handleEvent_8(ev, x, y){
  this.this$0.inDragSequence = true;
  $onMouseDown_0(this.this$0, new Mouse$ButtonEvent$Impl_0(new Events$Flags$Impl_0, now_0(), x, y, getMouseButton(ev))) && (ev.preventDefault() , undefined);
}
;
_.this$0 = null;
function HtmlMouse$3_0(this$0, val$platform, val$rootElement){
  this.this$0 = this$0;
  HtmlMouse$1XYEventHandler_0.call(this, val$platform, val$rootElement);
}

defineSeed(778, 776, {}, HtmlMouse$3_0);
_.handleEvent_0 = function handleEvent_9(ev, x, y){
  if (this.this$0.inDragSequence) {
    this.this$0.inDragSequence = false;
    $onMouseUp_0(this.this$0, new Mouse$ButtonEvent$Impl_0(new Events$Flags$Impl_0, now_0(), x, y, getMouseButton(ev))) && (ev.preventDefault() , undefined);
  }
  $handleRequestsInUserEventContext(this.this$0);
}
;
_.this$0 = null;
function HtmlMouse$4_0(this$0, val$platform, val$rootElement){
  HtmlMouse$1MoveEventHandler_0.call(this, this$0, val$platform, val$rootElement);
}

defineSeed(779, 775, {}, HtmlMouse$4_0);
_.wantDragSequence = function wantDragSequence(){
  return true;
}
;
function HtmlMouse$5_0(this$0, val$platform, val$rootElement){
  HtmlMouse$1MoveEventHandler_0.call(this, this$0, val$platform, val$rootElement);
}

defineSeed(780, 775, {}, HtmlMouse$5_0);
_.wantDragSequence = function wantDragSequence_0(){
  return false;
}
;
function HtmlMouse$6_0(this$0){
  this.this$0 = this$0;
}

defineSeed(781, 1, {}, HtmlMouse$6_0);
_.handleEvent = function handleEvent_10(ev){
  $onMouseWheelScroll(this.this$0, new Mouse$WheelEvent$Impl_0(new Events$Flags$Impl_0, now_0(), this.this$0.lastMousePt.x, this.this$0.lastMousePt.y, getMouseWheelVelocity(ev))) && (ev.preventDefault() , undefined);
}
;
_.this$0 = null;
function $lineTo_0(this$static, x, y){
  $push_1(this$static.list, 1);
  $push_1(this$static.list, x);
  $push_1(this$static.list, y);
  return this$static;
}

function $replay(this$static, ctx){
  var c1x, c1y, c2x, c2y, cpx, cpy, i, len, x, y;
  ctx.beginPath();
  len = this$static.list.length;
  i = 0;
  while (i < len) {
    switch (round_int(this$static.list[i++])) {
      case 0:
        {
          x = this$static.list[i++];
          y = this$static.list[i++];
          ctx.moveTo(x, y);
          break;
        }

      case 1:
        {
          x = this$static.list[i++];
          y = this$static.list[i++];
          ctx.lineTo(x, y);
          break;
        }

      case 2:
        {
          cpx = this$static.list[i++];
          cpy = this$static.list[i++];
          x = this$static.list[i++];
          y = this$static.list[i++];
          ctx.quadraticCurveTo(cpx, cpy, x, y);
          break;
        }

      case 3:
        {
          c1x = this$static.list[i++];
          c1y = this$static.list[i++];
          c2x = this$static.list[i++];
          c2y = this$static.list[i++];
          x = this$static.list[i++];
          y = this$static.list[i++];
          ctx.bezierCurveTo(c1x, c1y, c2x, c2y, x, y);
          break;
        }

      case 4:
        {
          ctx.closePath();
          break;
        }

      default:throw new AssertionError_0('Corrupt command list');
    }
  }
}

function HtmlPath_0(){
  this.list = [];
}

defineSeed(782, 1, {}, HtmlPath_0);
function $pattern(this$static, ctx){
  var repeat;
  if (this$static.repeatX) {
    this$static.repeatY?(repeat = ($clinit_Context2d$Repetition() , REPEAT)):(repeat = ($clinit_Context2d$Repetition() , REPEAT_X));
  }
   else if (this$static.repeatY) {
    repeat = ($clinit_Context2d$Repetition() , REPEAT_Y);
  }
   else {
    return null;
  }
  return $createPattern(ctx, this$static.patimg, repeat.value_0);
}

function HtmlPattern_0(image, patimg, repeatX, repeatY){
  this.image = image;
  this.patimg = patimg;
  this.repeatX = repeatX;
  this.repeatY = repeatY;
}

function HtmlPattern_1(image, repeatX, repeatY){
  HtmlPattern_0.call(this, image, image.img, repeatX, repeatY);
}

defineSeed(783, 1, {}, HtmlPattern_1);
_.image_0 = function image_1(){
  return this.image;
}
;
_.image = null;
_.patimg = null;
_.repeatX = false;
_.repeatY = false;
function $clinit_HtmlPlatform(){
  var userAgent;
  $clinit_HtmlPlatform = nullMethod;
  hasTypedArraySupport = typeof Float32Array != 'undefined';
  log_0 = new HtmlLogSimple_0;
  agentInfo_0 = (userAgent = navigator.userAgent.toLowerCase() , {isFirefox:userAgent.indexOf('firefox') != -1, isChrome:userAgent.indexOf('chrome') != -1, isSafari:userAgent.indexOf('safari') != -1, isOpera:userAgent.indexOf('opera') != -1, isIE:userAgent.indexOf('msie') != -1, isMacOS:userAgent.indexOf('mac') != -1, isLinux:userAgent.indexOf('linux') != -1, isWindows:userAgent.indexOf('win') != -1});
}

function $createGraphics(this$static, config){
  var $e0, e, t;
  try {
    switch (config.mode) {
      case 1:
        return new HtmlGraphicsCanvas_0;
      case 0:
        return new HtmlGraphicsGL_0(this$static);
      default:case 2:
        return !!$wnd.WebGLRenderingContext && (!/Chrome/.test(navigator.userAgent) || !/OS X 10_5/.test(navigator.userAgent))?new HtmlGraphicsGL_0(this$static):new HtmlGraphicsCanvas_0;
    }
  }
   catch ($e0) {
    $e0 = caught_0($e0);
    if (instanceOf($e0, Q$RuntimeException)) {
      e = $e0;
      $info(this$static.log_0, 'Failed to create GL context (' + e.getMessage() + '). Falling back.');
    }
     else if (instanceOf($e0, Q$Throwable)) {
      t = $e0;
      $info(this$static.log_0, 'GL context creation failed with an unknown error.' + t);
    }
     else 
      throw $e0;
  }
  return new HtmlGraphicsCanvas_0;
}

function $requestAnimationFrame(callback){
  var fn = function(){
    callback.fire();
  }
  ;
  $wnd.requestAnimationFrame?$wnd.requestAnimationFrame(fn):$wnd.mozRequestAnimationFrame?$wnd.mozRequestAnimationFrame(fn):$wnd.webkitRequestAnimationFrame?$wnd.webkitRequestAnimationFrame(fn):$wnd.setTimeout(fn, 20);
}

function $run(this$static, game){
  $init(game);
  this$static.paintCallback = new HtmlPlatform$1_0(this$static, game);
  $requestAnimationFrame(this$static.paintCallback);
}

function $tick_1(this$static){
  return round_int(now_0() - this$static.start);
}

function HtmlPlatform_0(config){
  var $e0, e;
  AbstractPlatform_0.call(this, log_0);
  this.assets = new HtmlAssets_0(this);
  this.audio = new HtmlAudio_0;
  this.keyboard = new HtmlKeyboard_0;
  this.storage = new HtmlStorage_0;
  this.start = initNow();
  try {
    this.graphics = $createGraphics(this, config);
    this.pointer = new HtmlPointer_0(this, this.graphics.rootElement_0());
    this.mouse = new HtmlMouse_0(this, this.graphics.rootElement_0());
    new HtmlTouch_0(this, this.graphics.rootElement_0());
  }
   catch ($e0) {
    $e0 = caught_0($e0);
    if (instanceOf($e0, Q$Throwable)) {
      e = $e0;
      $error_0(log_0, 'init()', e);
      alert_0('failed to init(): ' + e.getMessage());
      throw new RuntimeException_3(e);
    }
     else 
      throw $e0;
  }
}

function addEventListener_0(target, name_0, handler, capture){
  $clinit_HtmlPlatform();
  target.addEventListener(name_0, function(e){
    handler.handleEvent(e);
  }
  , capture);
}

function captureEvent(target, name_0, handler){
  $clinit_HtmlPlatform();
  addEventListener_0(!target?$doc:target, name_0, handler, true);
}

function captureEvent_0(name_0, handler){
  $clinit_HtmlPlatform();
  addEventListener_0($doc, name_0, handler, true);
}

function initNow(){
  function now(){
    return new Date;
  }

  !Date.now && (Date.now = now);
  return Date.now();
}

function now_0(){
  $clinit_HtmlPlatform();
  return Date.now();
}

defineSeed(784, 643, {}, HtmlPlatform_0);
_.graphics = null;
_.mouse = null;
_.paintCallback = null;
_.pointer = null;
var agentInfo_0, hasTypedArraySupport, log_0;
function HtmlPlatform$1_0(this$0, val$game){
  this.this$0 = this$0;
  this.val$game = val$game;
}

defineSeed(785, 1, {}, HtmlPlatform$1_0);
_.fire = function fire_0(){
  $requestAnimationFrame(this.this$0.paintCallback);
  this.this$0.runQueue.head = null;
  $tick_0(this.val$game, $tick_1(this.this$0));
  this.this$0.graphics.paint_1();
}
;
_.this$0 = null;
_.val$game = null;
function HtmlPlatform$Config_0(){
  this.mode = requestedMode();
}

defineSeed(787, 1, {}, HtmlPlatform$Config_0);
function $eventFromMouse(this$static, rootElement, nativeEvent){
  var x, xy, y;
  x = (nativeEvent.clientX || 0) - $getAbsoluteLeft(rootElement) + $getScrollLeft(rootElement) + $getScrollLeft(rootElement.ownerDocument.body);
  y = (nativeEvent.clientY || 0) - $getAbsoluteTop(rootElement) + (rootElement.scrollTop || 0) + (rootElement.ownerDocument.body.scrollTop || 0);
  xy = $transformMouse(this$static.platform.graphics, x, y);
  return new Pointer$Event$Impl_0(new Events$Flags$Impl_0, now_0(), xy.x, xy.y, false);
}

function $eventFromTouch(this$static, rootElement, touch){
  var x, xy, y;
  x = touch.clientX - $getAbsoluteLeft(rootElement) + $getScrollLeft(rootElement) + $getScrollLeft(rootElement.ownerDocument.body);
  y = touch.clientY - $getAbsoluteTop(rootElement) + (rootElement.scrollTop || 0) + (rootElement.ownerDocument.body.scrollTop || 0);
  xy = $transformMouse(this$static.platform.graphics, x, y);
  return new Pointer$Event$Impl_0(new Events$Flags$Impl_0, now_0(), xy.x, xy.y, true);
}

function HtmlPointer_0(platform, rootElement){
  this.active = new Dispatcher$CaptureState_0;
  this.START = new PointerImpl$1_0;
  this.DRAG = new PointerImpl$2_0;
  this.END = new PointerImpl$3_0;
  this.platform = platform;
  captureEvent(rootElement, 'touchstart', new HtmlPointer$1_0(this, rootElement));
  captureEvent_0('touchend', new HtmlInput$1_0(new HtmlPointer$2_0(this, rootElement)));
  captureEvent_0('touchmove', new HtmlInput$1_0(new HtmlPointer$3_0(this, rootElement)));
  captureEvent(rootElement, 'mousedown', new HtmlPointer$4_0(this, rootElement));
  captureEvent_0('mouseup', new HtmlInput$1_0(new HtmlPointer$5_0(this, rootElement)));
  captureEvent_0('mousemove', new HtmlInput$1_0(new HtmlPointer$6_0(this, rootElement)));
}

defineSeed(788, 675, {}, HtmlPointer_0);
_.inDragSequence = false;
_.platform = null;
function HtmlPointer$1_0(this$0, val$rootElement){
  this.this$0 = this$0;
  this.val$rootElement = val$rootElement;
}

defineSeed(789, 1, {}, HtmlPointer$1_0);
_.handleEvent = function handleEvent_11(nativeEvent){
  var touches;
  touches = nativeEvent.changedTouches;
  if (touches.length > 0) {
    this.this$0.inDragSequence = true;
    $onPointerStart_0(this.this$0, $eventFromTouch(this.this$0, this.val$rootElement, touches[0])) && (nativeEvent.preventDefault() , undefined);
  }
}
;
_.this$0 = null;
_.val$rootElement = null;
function HtmlPointer$2_0(this$0, val$rootElement){
  this.this$0 = this$0;
  this.val$rootElement = val$rootElement;
}

defineSeed(790, 1, {}, HtmlPointer$2_0);
_.handleEvent = function handleEvent_12(nativeEvent){
  var touches;
  touches = nativeEvent.changedTouches;
  if (this.this$0.inDragSequence && touches.length > 0) {
    this.this$0.inDragSequence = false;
    $onPointerEnd_0(this.this$0, $eventFromTouch(this.this$0, this.val$rootElement, touches[0]), true) && (nativeEvent.preventDefault() , undefined);
  }
   else {
    nativeEvent.preventDefault();
  }
}
;
_.this$0 = null;
_.val$rootElement = null;
function HtmlPointer$3_0(this$0, val$rootElement){
  this.this$0 = this$0;
  this.val$rootElement = val$rootElement;
}

defineSeed(791, 1, {}, HtmlPointer$3_0);
_.handleEvent = function handleEvent_13(nativeEvent){
  var touches;
  touches = nativeEvent.changedTouches;
  this.this$0.inDragSequence && touches.length > 0?$onPointerDrag_0(this.this$0, $eventFromTouch(this.this$0, this.val$rootElement, touches[0]), true) && (nativeEvent.preventDefault() , undefined):(nativeEvent.preventDefault() , undefined);
}
;
_.this$0 = null;
_.val$rootElement = null;
function HtmlPointer$4_0(this$0, val$rootElement){
  this.this$0 = this$0;
  this.val$rootElement = val$rootElement;
}

defineSeed(792, 1, {}, HtmlPointer$4_0);
_.handleEvent = function handleEvent_14(nativeEvent){
  this.this$0.inDragSequence = true;
  $onPointerStart_0(this.this$0, $eventFromMouse(this.this$0, this.val$rootElement, nativeEvent)) && (nativeEvent.preventDefault() , undefined);
}
;
_.this$0 = null;
_.val$rootElement = null;
function HtmlPointer$5_0(this$0, val$rootElement){
  this.this$0 = this$0;
  this.val$rootElement = val$rootElement;
}

defineSeed(793, 1, {}, HtmlPointer$5_0);
_.handleEvent = function handleEvent_15(nativeEvent){
  if (this.this$0.inDragSequence) {
    this.this$0.inDragSequence = false;
    $onPointerEnd_0(this.this$0, $eventFromMouse(this.this$0, this.val$rootElement, nativeEvent), false) && (nativeEvent.preventDefault() , undefined);
  }
}
;
_.this$0 = null;
_.val$rootElement = null;
function HtmlPointer$6_0(this$0, val$rootElement){
  this.this$0 = this$0;
  this.val$rootElement = val$rootElement;
}

defineSeed(794, 1, {}, HtmlPointer$6_0);
_.handleEvent = function handleEvent_16(nativeEvent){
  this.this$0.inDragSequence && $onPointerDrag_0(this.this$0, $eventFromMouse(this.this$0, this.val$rootElement, nativeEvent), false) && (nativeEvent.preventDefault() , undefined);
}
;
_.this$0 = null;
_.val$rootElement = null;
function $setLoopingImpl(this$static, looping){
  this$static.impl.setLooping_0(looping);
}

function $setVolumeImpl(this$static, volume){
  this$static.impl.setVolume_0(round_int(volume * 100));
}

function HtmlSound_0(sound){
  $addEventHandler(sound, new HtmlSound$1_0(this, sound));
}

defineSeed(795, 644, {}, HtmlSound_0);
function $onSoundLoadStateChange(this$static, event_0){
  var loadState;
  loadState = event_0.loadState;
  switch (loadState.ordinal) {
    case 5:
    case 4:
      break;
    case 2:
    case 1:
    case 3:
      $onLoaded(this$static.this$0, this$static.val$sound);
      break;
    case 0:
      $onLoadError(new RuntimeException_1(loadState.name_0));
      break;
    default:throw new RuntimeException_1('Unrecognized sound load state ' + loadState.name_0);
  }
}

function HtmlSound$1_0(this$0, val$sound){
  this.this$0 = this$0;
  this.val$sound = val$sound;
}

defineSeed(796, 1, {}, HtmlSound$1_0);
_.this$0 = null;
_.val$sound = null;
function $getItem_1(this$static, key){
  var $e0;
  try {
    return this$static.storageMap.get_1(key);
  }
   catch ($e0) {
    $e0 = caught_0($e0);
    if (!instanceOf($e0, Q$RuntimeException))
      throw $e0;
  }
  return null;
}

function $setItem_1(this$static, key, value){
  if (key == null || key == '') {
    return;
  }
  this$static.storageMap.put(key, value);
}

function HtmlStorage_0(){
  var storage;
  storage = getLocalStorageIfSupported();
  storage?(this.storageMap = new StorageMap_0(storage)):(this.storageMap = new HashMap_0);
}

defineSeed(797, 1, {}, HtmlStorage_0);
_.storageMap = null;
function $fill_0(this$static, ctx){
  configContext(ctx, this$static.format);
  $fillText(ctx, this$static.text, 0, 0);
}

function HtmlTextLayout_0(text, format, metrics, width){
  AbstractTextLayout_0.call(this, text, format, new Rectangle_0($adjustWidth(metrics, width), metrics.height_0));
  this.metrics = metrics;
}

function configContext(ctx, format){
  var font, style;
  font = !format.font_0?($clinit_HtmlFont() , DEFAULT):format.font_0;
  style = '';
  switch (font.style_0.ordinal) {
    case 1:
      style = 'bold';
      break;
    case 2:
      style = 'italic';
      break;
    case 3:
      style = 'bold italic';
  }
  $setFont(ctx, style + ' ' + font.size + 'px ' + font.name_0);
  $setTextBaseline(ctx, ($clinit_Context2d$TextBaseline() , TOP).value_0);
}

function layoutText(gfx, ctx, text, format){
  var metrics, width;
  metrics = $getFontMetrics(gfx, !format.font_0?($clinit_HtmlFont() , DEFAULT):format.font_0);
  configContext(ctx, format);
  width = ctx.measureText(text).width;
  return new HtmlTextLayout_0(text, format, metrics, width);
}

defineSeed(798, 645, {}, HtmlTextLayout_0);
_.metrics = null;
function $toEvents(this$static, nativeEvent, flags){
  var id, nativeTouches, nativeTouchesLen, t, touch, touches, x, xy, y;
  nativeTouches = nativeEvent.changedTouches;
  nativeTouchesLen = nativeTouches.length;
  touches = initDim(_3Lplayn_core_Touch$Event$Impl_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Touch$Event$Impl, nativeTouchesLen, 0);
  for (t = 0; t < nativeTouchesLen; ++t) {
    touch = nativeTouches[t];
    x = $getRelativeX(touch, this$static.rootElement);
    y = $getRelativeY(touch, this$static.rootElement);
    xy = $transformMouse(this$static.platform.graphics, x, y);
    id = nativeEvent.changedTouches[t].identifier || 0;
    touches[t] = new Touch$Event$Impl_0(flags, now_0(), xy.x, xy.y, id);
  }
  return touches;
}

function HtmlTouch_0(platform, rootElement){
  $clinit_TouchImpl();
  this.activeLayers = new HashMap_0;
  this.platform = platform;
  this.rootElement = rootElement;
  captureEvent(rootElement, 'touchstart', new HtmlTouch$1_0(this));
  captureEvent_0('touchmove', new HtmlInput$1_0(new HtmlTouch$2_0(this)));
  captureEvent_0('touchend', new HtmlInput$1_0(new HtmlTouch$3_0(this)));
}

defineSeed(799, 689, {}, HtmlTouch_0);
_.inTouchSequence = false;
_.platform = null;
_.rootElement = null;
function HtmlTouch$1_0(this$0){
  this.this$0 = this$0;
}

defineSeed(800, 1, {}, HtmlTouch$1_0);
_.handleEvent = function handleEvent_17(nativeEvent){
  var flags;
  this.this$0.inTouchSequence = true;
  flags = new Events$Flags$Impl_0;
  $onTouchStart(this.this$0, $toEvents(this.this$0, nativeEvent, flags));
  flags.preventDefault_0 && (nativeEvent.preventDefault() , undefined);
}
;
_.this$0 = null;
function HtmlTouch$2_0(this$0){
  this.this$0 = this$0;
}

defineSeed(801, 1, {}, HtmlTouch$2_0);
_.handleEvent = function handleEvent_18(nativeEvent){
  var flags;
  if (this.this$0.inTouchSequence) {
    flags = new Events$Flags$Impl_0;
    $onTouchMove(this.this$0, $toEvents(this.this$0, nativeEvent, flags));
    flags.preventDefault_0 && (nativeEvent.preventDefault() , undefined);
  }
}
;
_.this$0 = null;
function HtmlTouch$3_0(this$0){
  this.this$0 = this$0;
}

defineSeed(802, 1, {}, HtmlTouch$3_0);
_.handleEvent = function handleEvent_19(nativeEvent){
  var flags;
  if (this.this$0.inTouchSequence) {
    flags = new Events$Flags$Impl_0;
    $onTouchEnd(this.this$0, $toEvents(this.this$0, nativeEvent, flags));
    flags.preventDefault_0 && (nativeEvent.preventDefault() , undefined);
    nativeEvent.touches.length == 0 && (this.this$0.inTouchSequence = false);
  }
}
;
_.this$0 = null;
function $clinit_HtmlUrlParameters(){
  $clinit_HtmlUrlParameters = nullMethod;
  checkGLErrors = $equals_0('check', (ensureParameterMap() , paramMap.get_1('glerrors')));
  $equals_0('quad', (ensureParameterMap() , paramMap.get_1('glshader')));
}

var checkGLErrors;
function requestedMode(){
  var renderer;
  renderer = (ensureParameterMap() , paramMap.get_1('renderer'));
  if ($equals_0('canvas', renderer)) {
    return 1;
  }
   else if ($equals_0('gl', renderer)) {
    return 0;
  }
  return 2;
}

--></script>
<script><!--
function $setHandler(this$static, handler){
  var _this = this$static;
  this$static.onerror = $entry(function(){
    handler.onError(_this);
  }
  );
  this$static.onload = $entry(function(){
    handler.onLoad(_this);
  }
  );
  this$static.onprogress = $entry(function(){
    handler.onProgress(_this);
  }
  );
  this$static.ontimeout = $entry(function(){
    handler.onTimeout(_this);
  }
  );
}

defineSeed(805, 1, makeCastMap([Q$AbstractDimension]));
_.equals$ = function equals_32(obj){
  var d;
  if (obj === this) {
    return true;
  }
  if (instanceOf(obj, Q$AbstractDimension)) {
    d = obj;
    return d.width_0 == this.width_0 && d.height_0 == this.height_0;
  }
  return false;
}
;
_.hashCode$ = function hashCode_31(){
  return round_int(this.width_0) ^ round_int(this.height_0);
}
;
_.toString$ = function toString_57(){
  return $clinit_Dimensions() , this.width_0 + 'x' + this.height_0;
}
;
defineSeed(806, 1, makeCastMap([Q$AbstractPoint]));
_.equals$ = function equals_33(obj){
  var p;
  if (obj === this) {
    return true;
  }
  if (instanceOf(obj, Q$AbstractPoint)) {
    p = obj;
    return this.x_0() == p.x && this.y_0() == p.y;
  }
  return false;
}
;
_.hashCode$ = function hashCode_32(){
  return round_int(this.x_0()) ^ round_int(this.y_0());
}
;
_.toString$ = function toString_58(){
  return pointToString(this.x_0(), this.y_0());
}
;
defineSeed(808, 1, {});
defineSeed(807, 808, makeCastMap([Q$AbstractRectangle]));
_.equals$ = function equals_34(obj){
  var r;
  if (obj === this) {
    return true;
  }
  if (instanceOf(obj, Q$AbstractRectangle)) {
    r = obj;
    return r.x == this.x && r.y == this.y && r.width_0 == this.width_0 && r.height_0 == this.height_0;
  }
  return false;
}
;
_.hashCode$ = function hashCode_33(){
  return round_int(this.x) ^ round_int(this.y) ^ round_int(this.width_0) ^ round_int(this.height_0);
}
;
_.toString$ = function toString_59(){
  return ($clinit_Dimensions() , this.width_0 + 'x' + this.height_0) + pointToString(this.x, this.y);
}
;
defineSeed(809, 1, makeCastMap([Q$AbstractVector]));
_.equals$ = function equals_35(obj){
  var p;
  if (obj === this) {
    return true;
  }
  if (instanceOf(obj, Q$AbstractVector)) {
    p = obj;
    return this.x_0() == p.x && this.y_0() == p.y;
  }
  return false;
}
;
_.hashCode$ = function hashCode_34(){
  return round_int(this.x_0()) ^ round_int(this.y_0());
}
;
_.toString$ = function toString_60(){
  return vectorToString(this.x_0(), this.y_0());
}
;
function Dimension_0(){
  this.width_0 = 0;
  this.height_0 = 0;
}

defineSeed(810, 805, makeCastMap([Q$Serializable, Q$AbstractDimension]), Dimension_0);
_.height_0 = 0;
_.width_0 = 0;
function $clinit_Dimensions(){
  $clinit_Dimensions = nullMethod;
  new Dimension_0;
}

function iceil(v){
  var iv;
  iv = round_int(v);
  return v <= 0 || iv == v || iv == 2147483647?iv:iv + 1;
}

function ifloor(v){
  var iv;
  iv = round_int(v);
  return v >= 0 || iv == v || iv == -2147483648?iv:iv - 1;
}

function toString_61(value){
  var buf, ii, ivalue;
  buf = new StringBuilder_0;
  if (value >= 0) {
    buf.impl.string += '+';
  }
   else {
    buf.impl.string += '-';
    value = -value;
  }
  ivalue = round_int(value);
  $append_1(buf.impl, ivalue);
  buf.impl.string += '.';
  for (ii = 0; ii < 3; ++ii) {
    value = (value - ivalue) * 10;
    ivalue = round_int(value);
    $append_1(buf.impl, ivalue);
  }
  for (ii = 0; ii < 2; ++ii) {
    $charAt_0(buf, buf.impl.string.length - 1) == 48 && $setLength(buf, buf.impl.string.length - 1);
  }
  return buf.impl.string;
}

function $set_9(this$static, x, y){
  this$static.x = x;
  this$static.y = y;
  return this$static;
}

function Point_0(){
}

function Point_1(x, y){
  $set_9(this, x, y);
}

defineSeed(813, 806, makeCastMap([Q$Serializable, Q$AbstractPoint]), Point_0, Point_1);
_.x_0 = function x_0(){
  return this.x;
}
;
_.y_0 = function y_0(){
  return this.y;
}
;
_.x = 0;
_.y = 0;
function $clinit_Points(){
  $clinit_Points = nullMethod;
  new Point_1(0, 0);
}

function pointToString(x, y){
  $clinit_Points();
  return toString_61(x) + toString_61(y);
}

function Rectangle_0(width, height){
  this.x = 0;
  this.y = 0;
  this.height_0 = height;
  this.width_0 = width;
}

defineSeed(815, 807, makeCastMap([Q$Serializable, Q$AbstractRectangle]), Rectangle_0);
_.height_0 = 0;
_.width_0 = 0;
_.x = 0;
_.y = 0;
function multiply_1(am00, am01, am10, am11, atx, aty, bm00, bm01, bm10, bm11, btx, bty, into){
  into.m00 = am00 * bm00 + am10 * bm01;
  into.m01 = am01 * bm00 + am11 * bm01;
  into.m10 = am00 * bm10 + am10 * bm11;
  into.m11 = am01 * bm10 + am11 * bm11;
  into.tx = am00 * btx + am10 * bty + atx;
  into.ty = am01 * btx + am11 * bty + aty;
  return into;
}

function Vector_0(x, y){
  this.x = x;
  this.y = y;
}

defineSeed(817, 809, makeCastMap([Q$AbstractVector]), Vector_0);
_.x_0 = function x_1(){
  return this.x;
}
;
_.y_0 = function y_1(){
  return this.y;
}
;
_.x = 0;
_.y = 0;
function $clinit_Vectors(){
  $clinit_Vectors = nullMethod;
  new Vector_0(1, 0);
  new Vector_0(0, 1);
  new Vector_0(0, 0);
  new Vector_0(-3.4028234663852886E38, -3.4028234663852886E38);
  new Vector_0(3.4028234663852886E38, 3.4028234663852886E38);
}

function vectorToString(x, y){
  $clinit_Vectors();
  return toString_61(x) + toString_61(y);
}

function NoninvertibleTransformException_0(s){
  RuntimeException_1.call(this, s);
}

defineSeed(819, 77, makeCastMap([Q$Serializable, Q$Exception, Q$RuntimeException, Q$Throwable, Q$NoninvertibleTransformException]), NoninvertibleTransformException_0);
var $entry = entry_0;
function gwtOnLoad(errFn, modName, modBase, softPermutationId){
  $moduleName = modName;
  $moduleBase = modBase;
  if (errFn)
    try {
      $entry(init)();
    }
     catch (e) {
      errFn(modName);
    }
   else {
    $entry(init)();
  }
}

--></script>
<script><!--
var Ljava_lang_Object_2_classLit = createForClass(1), Lcom_google_gwt_core_client_JavaScriptObject_2_classLit = createForClass(68), Ljava_lang_Throwable_2_classLit = createForClass(52), Ljava_lang_Exception_2_classLit = createForClass(51), Ljava_lang_RuntimeException_2_classLit = createForClass(77), Ljava_lang_StackTraceElement_2_classLit = createForClass(524), _3Ljava_lang_StackTraceElement_2_classLit = createForArray(825, Ljava_lang_StackTraceElement_2_classLit), Lcom_google_gwt_lang_LongLibBase$LongEmul_2_classLit = createForClass(180), _3Lcom_google_gwt_lang_LongLibBase$LongEmul_2_classLit = createForArray(826, Lcom_google_gwt_lang_LongLibBase$LongEmul_2_classLit), I_classLit = createForPrimitive(' I'), _3I_classLit = createForArray(827, I_classLit), Lcom_google_gwt_lang_SeedUtil_2_classLit = createForClass(181), Ljava_lang_Enum_2_classLit = createForClass(11), Lplayn_core_Game$Default_2_classLit = createForClass(387), Lim_bci_newtonadv_platform_playn_core_PlaynNewtonAdventureGame_2_classLit = createForClass(386), Lim_bci_newtonadv_platform_playn_html_PlaynNewtonAdventureGameHtml$1_2_classLit = createForClass(400), Lplayn_html_HtmlGame$1_2_classLit = createForClass(753), Lplayn_html_HtmlGame$2_2_classLit = createForClass(754), Lcom_google_gwt_core_client_Scheduler_2_classLit = createForClass(84), Lim_bci_newtonadv_platform_playn_core_PlaynNewtonAdventureGame$2_2_classLit = createForClass(388), Ljava_lang_Error_2_classLit = createForClass(506), Ljava_lang_AssertionError_2_classLit = createForClass(505), Z_classLit = createForPrimitive(' Z'), Ljava_lang_Boolean_2_classLit = createForClass(507), Ljava_lang_Number_2_classLit = createForClass(511), C_classLit = createForPrimitive(' C'), _3C_classLit = createForArray(828, C_classLit), J_classLit = createForPrimitive(' J'), _3J_classLit = createForArray(829, J_classLit), Ljava_lang_Class_2_classLit = createForClass(509), D_classLit = createForPrimitive(' D'), _3D_classLit = createForArray(830, D_classLit), Ljava_lang_Double_2_classLit = createForClass(510), F_classLit = createForPrimitive(' F'), Ljava_lang_Float_2_classLit = createForClass(512), Ljava_lang_Integer_2_classLit = createForClass(515), _3Ljava_lang_Integer_2_classLit = createForArray(831, Ljava_lang_Integer_2_classLit), Ljava_lang_Long_2_classLit = createForClass(517), _3Ljava_lang_Long_2_classLit = createForArray(832, Ljava_lang_Long_2_classLit), S_classLit = createForPrimitive(' S'), Ljava_lang_String_2_classLit = createForClass(2), _3Ljava_lang_String_2_classLit = createForArray(824, Ljava_lang_String_2_classLit), Ljava_lang_StringBuilder_2_classLit = createForClass(527), Ljava_lang_ArrayStoreException_2_classLit = createForClass(504), Lcom_google_gwt_core_client_JavaScriptException_2_classLit = createForClass(76), Ljava_lang_ArithmeticException_2_classLit = createForClass(501), Lcom_google_gwt_core_client_impl_StringBufferImpl_2_classLit = createForClass(95), Lcom_google_gwt_core_client_impl_SchedulerImpl_2_classLit = createForClass(86), Lcom_google_gwt_core_client_impl_SchedulerImpl$Flusher_2_classLit = createForClass(87), Lcom_google_gwt_core_client_impl_SchedulerImpl$Rescuer_2_classLit = createForClass(88), Lcom_google_gwt_core_client_impl_StackTraceCreator$Collector_2_classLit = createForClass(91), Lcom_google_gwt_core_client_impl_StackTraceCreator$CollectorMoz_2_classLit = createForClass(93), Lcom_google_gwt_core_client_impl_StackTraceCreator$CollectorChrome_2_classLit = createForClass(92), Lcom_google_gwt_core_client_impl_StackTraceCreator$CollectorChromeNoSourceMap_2_classLit = createForClass(94), Lcom_google_gwt_core_client_impl_StringBufferImplAppend_2_classLit = createForClass(96), Lplayn_core_LogImpl_2_classLit = createForClass(661), Lplayn_core_Log$Level_2_classLit = createForEnum(660, values_29), _3Lplayn_core_Log$Level_2_classLit = createForArray(833, Lplayn_core_Log$Level_2_classLit), Lplayn_core_AbstractPlatform_2_classLit = createForClass(643), Lplayn_html_HtmlPlatform_2_classLit = createForClass(784), Lplayn_html_HtmlPlatform$Config_2_classLit = createForClass(787), Lplayn_html_HtmlPlatform$1_2_classLit = createForClass(785), Lplayn_html_HtmlLog_2_classLit = createForClass(771), Ljava_lang_NullPointerException_2_classLit = createForClass(520), Ljava_lang_IllegalArgumentException_2_classLit = createForClass(513), Lplayn_html_HtmlLogSimple_2_classLit = createForClass(772), Ljava_lang_StringBuffer_2_classLit = createForClass(526), Lplayn_core_AbstractAssets_2_classLit = createForClass(638), Lplayn_html_HtmlAssets_2_classLit = createForClass(740), Lplayn_html_HtmlAssets$1_2_classLit = createForClass(741), Lplayn_html_HtmlAssets$2_2_classLit = createForClass(742), Lplayn_html_HtmlGraphics_2_classLit = createForClass(755), Lplayn_core_PointerImpl_2_classLit = createForClass(675), Lplayn_html_HtmlPointer_2_classLit = createForClass(788), Lplayn_html_HtmlPointer$1_2_classLit = createForClass(789), Lplayn_html_HtmlPointer$2_2_classLit = createForClass(790), Lplayn_html_HtmlPointer$3_2_classLit = createForClass(791), Lplayn_html_HtmlPointer$4_2_classLit = createForClass(792), Lplayn_html_HtmlPointer$5_2_classLit = createForClass(793), Lplayn_html_HtmlPointer$6_2_classLit = createForClass(794), Lplayn_core_Pointer$Listener_2_classLit = createForInterface(), Lplayn_core_PointerImpl$1_2_classLit = createForClass(676), Lplayn_core_PointerImpl$2_2_classLit = createForClass(677), Lplayn_core_PointerImpl$3_2_classLit = createForClass(678), Lplayn_core_Events$Input$Impl_2_classLit = createForClass(652), Lplayn_core_Events$Position$Impl_2_classLit = createForClass(653), Lplayn_core_Pointer$Event$Impl_2_classLit = createForClass(674), Lplayn_core_Events$Flags$Impl_2_classLit = createForClass(651), Lplayn_core_AbstractLayer_2_classLit = createForClass(641), Lplayn_core_AbstractLayer$Flag_2_classLit = createForEnum(642, values_26), _3Lplayn_core_AbstractLayer$Flag_2_classLit = createForArray(834, Lplayn_core_AbstractLayer$Flag_2_classLit), Lplayn_core_MouseImpl_2_classLit = createForClass(665), Lplayn_html_HtmlMouse_2_classLit = createForClass(773), Lplayn_html_HtmlMouse$1_2_classLit = createForClass(774), Lplayn_html_HtmlMouse$1XYEventHandler_2_classLit = createForClass(776), Lplayn_html_HtmlMouse$1MoveEventHandler_2_classLit = createForClass(775), Lplayn_html_HtmlMouse$2_2_classLit = createForClass(777), Lplayn_html_HtmlMouse$3_2_classLit = createForClass(778), Lplayn_html_HtmlMouse$4_2_classLit = createForClass(779), Lplayn_html_HtmlMouse$5_2_classLit = createForClass(780), Lplayn_html_HtmlMouse$6_2_classLit = createForClass(781), Lplayn_core_MouseImpl$1_2_classLit = createForClass(666), Lplayn_core_MouseImpl$2_2_classLit = createForClass(667), Lplayn_core_MouseImpl$3_2_classLit = createForClass(668), Lplayn_core_MouseImpl$4_2_classLit = createForClass(669), Lplayn_core_MouseImpl$5_2_classLit = createForClass(670), Lplayn_core_MouseImpl$6_2_classLit = createForClass(671), Lplayn_core_MouseImpl$7_2_classLit = createForClass(672), Lplayn_core_Mouse$ButtonEvent$Impl_2_classLit = createForClass(662), Lplayn_core_Mouse$MotionEvent$Impl_2_classLit = createForClass(663), Lplayn_core_Mouse$WheelEvent$Impl_2_classLit = createForClass(664), Lplayn_core_Mouse$Adapter_2_classLit = createForClass(285), Lplayn_core_TouchImpl_2_classLit = createForClass(689), Lplayn_html_HtmlTouch_2_classLit = createForClass(799), Lplayn_core_Touch$Event$Impl_2_classLit = createForClass(688), _3Lplayn_core_Touch$Event$Impl_2_classLit = createForArray(835, Lplayn_core_Touch$Event$Impl_2_classLit), Lplayn_html_HtmlTouch$1_2_classLit = createForClass(800), Lplayn_html_HtmlTouch$2_2_classLit = createForClass(801), Lplayn_html_HtmlTouch$3_2_classLit = createForClass(802), Lplayn_core_TouchImpl$1_2_classLit = createForClass(690), Lplayn_core_TouchImpl$2_2_classLit = createForClass(691), Lplayn_core_TouchImpl$3_2_classLit = createForClass(692), Lcom_google_web_bindery_event_shared_Event_2_classLit = createForClass(154), Lcom_google_gwt_event_shared_GwtEvent_2_classLit = createForClass(153), Lcom_google_gwt_user_client_Window$ClosingEvent_2_classLit = createForClass(217), Lcom_google_gwt_event_shared_HandlerManager_2_classLit = createForClass(162), Lcom_google_gwt_user_client_Window$WindowHandlers_2_classLit = createForClass(220), Lcom_google_web_bindery_event_shared_Event$Type_2_classLit = createForClass(157), Lcom_google_gwt_event_shared_GwtEvent$Type_2_classLit = createForClass(156), Lcom_google_web_bindery_event_shared_EventBus_2_classLit = createForClass(165), Lcom_google_web_bindery_event_shared_SimpleEventBus_2_classLit = createForClass(164), Lcom_google_gwt_event_shared_HandlerManager$Bus_2_classLit = createForClass(163), Lcom_google_web_bindery_event_shared_SimpleEventBus$1_2_classLit = createForClass(249), Lcom_google_web_bindery_event_shared_SimpleEventBus$2_2_classLit = createForClass(250), Lcom_google_web_bindery_event_shared_SimpleEventBus$3_2_classLit = createForClass(251), Lplayn_html_HtmlAudio_2_classLit = createForClass(743), Lplayn_html_HtmlKeyboard_2_classLit = createForClass(767), Lplayn_html_HtmlKeyboard$1_2_classLit = createForClass(768), Lplayn_html_HtmlKeyboard$2_2_classLit = createForClass(769), Lplayn_html_HtmlKeyboard$3_2_classLit = createForClass(770), Lplayn_core_Keyboard$Event$Impl_2_classLit = createForClass(657), Lplayn_core_Keyboard$TypedEvent$Impl_2_classLit = createForClass(658), Lplayn_core_Keyboard$Adapter_2_classLit = createForClass(283), Lim_bci_newtonadv_platform_playn_core_PlaynPlatformSpecific_2_classLit = createForClass(389), Lplayn_core_util_RunQueue_2_classLit = createForClass(738), Lplayn_html_HtmlStorage_2_classLit = createForClass(797), Lplayn_html_HtmlGraphicsCanvas_2_classLit = createForClass(756), Lplayn_core_AbstractCanvas_2_classLit = createForClass(639), Lplayn_core_gl_AbstractCanvasGL_2_classLit = createForClass(697), Lplayn_html_AbstractHtmlCanvas_2_classLit = createForClass(739), Lplayn_html_HtmlGraphicsCanvas$1_2_classLit = createForClass(757), Lplayn_html_HtmlGraphicsGL_2_classLit = createForClass(758), Lplayn_html_HtmlInput$1_2_classLit = createForClass(762), Lcom_allen_1sauer_gwt_voices_client_SoundController_2_classLit = createForClass(12), Lcom_allen_1sauer_gwt_voices_client_SoundType_2_classLit = createForEnum(14, values_2), _3Lcom_allen_1sauer_gwt_voices_client_SoundType_2_classLit = createForArray(836, Lcom_allen_1sauer_gwt_voices_client_SoundType_2_classLit), Lcom_allen_1sauer_gwt_voices_client_SoundController$MimeTypeSupport_2_classLit = createForEnum(13, values_1), _3Lcom_allen_1sauer_gwt_voices_client_SoundController$MimeTypeSupport_2_classLit = createForArray(837, Lcom_allen_1sauer_gwt_voices_client_SoundController$MimeTypeSupport_2_classLit), _3Z_classLit = createForArray(838, Z_classLit), Lim_bci_jnuit_playn_controls_PlaynNuitControls_2_classLit = createForClass(281), Lim_bci_jnuit_controls_Control_2_classLit = createForInterface(), _3Lim_bci_jnuit_controls_Control_2_classLit = createForArray(839, Lim_bci_jnuit_controls_Control_2_classLit), Lim_bci_jnuit_playn_controls_PlaynNuitControls$1_2_classLit = createForClass(282), Lim_bci_jnuit_playn_controls_PlaynNuitControls$2_2_classLit = createForClass(284), Lim_bci_jnuit_playn_controls_PlaynNuitControls$3_2_classLit = createForClass(286), Lim_bci_jnuit_playn_controls_MouseButtonControl_2_classLit = createForClass(280), Lim_bci_jnuit_playn_controls_PlaynNuitControls$4_2_classLit = createForClass(287), Lim_bci_jnuit_playn_controls_PlaynNuitControls$5_2_classLit = createForClass(288), Lim_bci_jnuit_playn_controls_PlaynNuitControls$6_2_classLit = createForClass(289), Lim_bci_jnuit_playn_PlaynNuitFont_2_classLit = createForClass(268), Lim_bci_jnuit_NuitTranslator_2_classLit = createForClass(254), Lim_bci_newtonadv_ui_NewtonAdventureNuitTranslator_2_classLit = createForClass(407), Lim_bci_jnuit_NuitLocale_2_classLit = createForEnum(252, values_18), Lplayn_core_Font$Style_2_classLit = createForEnum(654, values_27), _3Lplayn_core_Font$Style_2_classLit = createForArray(840, Lplayn_core_Font$Style_2_classLit), Lcom_esotericsoftware_tablelayout_Toolkit_2_classLit = createForClass(47), Lim_bci_jnuit_NuitToolkit_2_classLit = createForClass(253), Lim_bci_jnuit_controls_Action_2_classLit = createForClass(259), _3Lim_bci_jnuit_controls_Action_2_classLit = createForArray(841, Lim_bci_jnuit_controls_Action_2_classLit), Lim_bci_jnuit_display_VideoResolution_2_classLit = createForClass(264), _3Lim_bci_jnuit_display_VideoResolution_2_classLit = createForArray(842, Lim_bci_jnuit_display_VideoResolution_2_classLit), Lim_bci_jnuit_playn_PlaynNuitRenderer_2_classLit = createForClass(270), Lim_bci_jnuit_playn_PlaynNuitRenderer$TopBorderRenderer_2_classLit = createForClass(275), Lim_bci_jnuit_playn_PlaynNuitRenderer$BottomBorderRenderer_2_classLit = createForClass(271), Lim_bci_jnuit_playn_PlaynNuitRenderer$LeftBorderRenderer_2_classLit = createForClass(273), Lim_bci_jnuit_playn_PlaynNuitRenderer$RightBorderRenderer_2_classLit = createForClass(274), Lim_bci_jnuit_playn_PlaynNuitRenderer$FocusRenderer_2_classLit = createForClass(272), Lim_bci_jnuit_playn_PlaynNuitAudio_2_classLit = createForClass(266), Lim_bci_jnuit_playn_PlaynNuitAudio$1_2_classLit = createForClass(267), Lim_bci_jnuit_playn_PlaynNuitPreferences_2_classLit = createForClass(269), Lim_bci_newtonadv_platform_playn_core_PlaynGameView_2_classLit = createForClass(384), Lim_bci_newtonadv_platform_playn_core_PlaynGameView$1_2_classLit = createForClass(385), Lim_bci_newtonadv_platform_playn_core_RealWatchedAssets_2_classLit = createForClass(395), Lim_bci_newtonadv_platform_playn_core_RealWatchedAssets$1_2_classLit = createForClass(396), Lim_bci_newtonadv_platform_playn_core_RealWatchedAssets$2_2_classLit = createForClass(397), Lim_bci_newtonadv_platform_interfaces_AbstractGameInput_2_classLit = createForClass(374), Lim_bci_newtonadv_platform_playn_core_PlaynGameInput_2_classLit = createForClass(383), Lcom_google_gwt_storage_client_Storage_2_classLit = createForClass(193), Lcom_google_gwt_storage_client_Storage$StorageSupportDetector_2_classLit = createForClass(194), Ljava_util_AbstractMap_2_classLit = createForClass(198), Lcom_google_gwt_storage_client_StorageMap_2_classLit = createForClass(197), Lcom_google_gwt_storage_client_StorageMap$StorageEntry_2_classLit = createForClass(199), Lcom_google_gwt_storage_client_StorageMap$StorageEntryIterator_2_classLit = createForClass(200), Ljava_util_AbstractCollection_2_classLit = createForClass(21), Ljava_util_AbstractSet_2_classLit = createForClass(202), Lcom_google_gwt_storage_client_StorageMap$StorageEntrySet_2_classLit = createForClass(201), Ljava_util_AbstractMap$1_2_classLit = createForClass(545), Ljava_util_AbstractMap$1$1_2_classLit = createForClass(546), Ljava_util_AbstractMap$2_2_classLit = createForClass(547), Ljava_util_AbstractMap$2$1_2_classLit = createForClass(548), _3Ljava_lang_Object_2_classLit = createForArray(823, Ljava_lang_Object_2_classLit), Ljava_util_AbstractHashMap_2_classLit = createForClass(537), Ljava_util_HashMap_2_classLit = createForClass(569), Ljava_util_AbstractHashMap$EntrySet_2_classLit = createForClass(538), Ljava_util_AbstractHashMap$EntrySetIterator_2_classLit = createForClass(539), Ljava_util_AbstractMapEntry_2_classLit = createForClass(541), Ljava_util_AbstractHashMap$MapEntryNull_2_classLit = createForClass(540), Ljava_util_AbstractHashMap$MapEntryString_2_classLit = createForClass(542), Lplayn_core_gl_Scale_2_classLit = createForClass(725), Lplayn_core_canvas_LayerCanvas_2_classLit = createForClass(695), Lplayn_core_canvas_GroupLayerCanvas_2_classLit = createForClass(694), Lcom_google_gwt_canvas_dom_client_Context2d$Repetition_2_classLit = createForEnum(70, values_9), _3Lcom_google_gwt_canvas_dom_client_Context2d$Repetition_2_classLit = createForArray(843, Lcom_google_gwt_canvas_dom_client_Context2d$Repetition_2_classLit), Lcom_google_gwt_canvas_dom_client_Context2d$TextBaseline_2_classLit = createForEnum(71, values_10), _3Lcom_google_gwt_canvas_dom_client_Context2d$TextBaseline_2_classLit = createForArray(844, Lcom_google_gwt_canvas_dom_client_Context2d$TextBaseline_2_classLit), Lplayn_core_gl_GLContext_2_classLit = createForClass(705), Lplayn_core_gl_GL20Context_2_classLit = createForClass(704), Lplayn_html_HtmlGLContext_2_classLit = createForClass(752), _3F_classLit = createForArray(845, F_classLit), Lplayn_core_gl_GLContext$Stats_2_classLit = createForClass(711), Lplayn_core_gl_LayerGL_2_classLit = createForClass(716), Lplayn_core_gl_GroupLayerGL_2_classLit = createForClass(715), Lpythagoras_f_AbstractPoint_2_classLit = createForClass(806), Lpythagoras_f_Point_2_classLit = createForClass(813), Lplayn_core_CachingAssets_2_classLit = createForClass(646), Lim_bci_newtonadv_platform_playn_core_PlaynGameData_2_classLit = createForClass(375), Lim_bci_newtonadv_platform_playn_core_PlaynGameData$QuestsConfig_2_classLit = createForClass(382), Lim_bci_newtonadv_platform_playn_core_PlaynGameData$QuestConfig_2_classLit = createForClass(381), Lim_bci_newtonadv_platform_playn_core_PlaynGameData$1_2_classLit = createForClass(376), Lim_bci_newtonadv_platform_playn_core_PlaynGameData$2_2_classLit = createForClass(377), Lim_bci_newtonadv_platform_playn_core_PlaynGameData$3_2_classLit = createForClass(378), Lim_bci_newtonadv_platform_playn_core_PlaynGameData$4_2_classLit = createForClass(379), Lim_bci_newtonadv_platform_playn_core_PlaynGameData$4$1_2_classLit = createForClass(380), Lplayn_core_TextFormat_2_classLit = createForClass(682), Lplayn_core_TextFormat$Alignment_2_classLit = createForEnum(683, values_30), _3Lplayn_core_TextFormat$Alignment_2_classLit = createForArray(846, Lplayn_core_TextFormat$Alignment_2_classLit), Lplayn_core_TextFormat$Alignment$1_2_classLit = createForEnum(684, null), Lplayn_core_TextFormat$Alignment$2_2_classLit = createForEnum(685, null), Lplayn_core_TextFormat$Alignment$3_2_classLit = createForEnum(686, null), Lim_bci_jnuit_playn_PlaynTextCache_2_classLit = createForClass(276), Lim_bci_jnuit_playn_PlaynTextCache$CachedTextKey_2_classLit = createForClass(278), Lim_bci_jnuit_playn_PlaynTextCache$CachedTextImage_2_classLit = createForClass(277), Lim_bci_jnuit_controls_ActionActivatedDetector_2_classLit = createForClass(260), _3Ljava_lang_Float_2_classLit = createForArray(847, Ljava_lang_Float_2_classLit), Lim_bci_newtonadv_platform_playn_core_PlaynTextureCache_2_classLit = createForClass(394), Lcom_google_gwt_dom_client_Style$Unit_2_classLit = createForEnum(132, values_15), _3Lcom_google_gwt_dom_client_Style$Unit_2_classLit = createForArray(848, Lcom_google_gwt_dom_client_Style$Unit_2_classLit), Lcom_google_gwt_dom_client_Style$FontStyle_2_classLit = createForEnum(113, values_11), _3Lcom_google_gwt_dom_client_Style$FontStyle_2_classLit = createForArray(849, Lcom_google_gwt_dom_client_Style$FontStyle_2_classLit), Lcom_google_gwt_dom_client_Style$FontWeight_2_classLit = createForEnum(117, values_12), _3Lcom_google_gwt_dom_client_Style$FontWeight_2_classLit = createForArray(850, Lcom_google_gwt_dom_client_Style$FontWeight_2_classLit), Lcom_google_gwt_dom_client_Style$Overflow_2_classLit = createForEnum(122, values_13), _3Lcom_google_gwt_dom_client_Style$Overflow_2_classLit = createForArray(851, Lcom_google_gwt_dom_client_Style$Overflow_2_classLit), Lcom_google_gwt_dom_client_Style$Position_2_classLit = createForEnum(127, values_14), _3Lcom_google_gwt_dom_client_Style$Position_2_classLit = createForArray(852, Lcom_google_gwt_dom_client_Style$Position_2_classLit), Lcom_google_gwt_dom_client_Style$Visibility_2_classLit = createForEnum(142, values_16), _3Lcom_google_gwt_dom_client_Style$Visibility_2_classLit = createForArray(853, Lcom_google_gwt_dom_client_Style$Visibility_2_classLit), Lcom_google_gwt_dom_client_Style$WhiteSpace_2_classLit = createForEnum(145, values_17), _3Lcom_google_gwt_dom_client_Style$WhiteSpace_2_classLit = createForArray(854, Lcom_google_gwt_dom_client_Style$WhiteSpace_2_classLit), Lcom_google_gwt_dom_client_Style$Unit$1_2_classLit = createForEnum(133, null), Lcom_google_gwt_dom_client_Style$Unit$2_2_classLit = createForEnum(134, null), Lcom_google_gwt_dom_client_Style$Unit$3_2_classLit = createForEnum(135, null), Lcom_google_gwt_dom_client_Style$Unit$4_2_classLit = createForEnum(136, null), Lcom_google_gwt_dom_client_Style$Unit$5_2_classLit = createForEnum(137, null), Lcom_google_gwt_dom_client_Style$Unit$6_2_classLit = createForEnum(138, null), Lcom_google_gwt_dom_client_Style$Unit$7_2_classLit = createForEnum(139, null), Lcom_google_gwt_dom_client_Style$Unit$8_2_classLit = createForEnum(140, null), Lcom_google_gwt_dom_client_Style$Unit$9_2_classLit = createForEnum(141, null), Lcom_google_gwt_dom_client_Style$FontStyle$1_2_classLit = createForEnum(114, null), Lcom_google_gwt_dom_client_Style$FontStyle$2_2_classLit = createForEnum(115, null), Lcom_google_gwt_dom_client_Style$FontStyle$3_2_classLit = createForEnum(116, null), Lcom_google_gwt_dom_client_Style$FontWeight$1_2_classLit = createForEnum(118, null), Lcom_google_gwt_dom_client_Style$FontWeight$2_2_classLit = createForEnum(119, null), Lcom_google_gwt_dom_client_Style$FontWeight$3_2_classLit = createForEnum(120, null), Lcom_google_gwt_dom_client_Style$FontWeight$4_2_classLit = createForEnum(121, null), Lcom_google_gwt_dom_client_Style$Overflow$1_2_classLit = createForEnum(123, null), Lcom_google_gwt_dom_client_Style$Overflow$2_2_classLit = createForEnum(124, null), Lcom_google_gwt_dom_client_Style$Overflow$3_2_classLit = createForEnum(125, null), Lcom_google_gwt_dom_client_Style$Overflow$4_2_classLit = createForEnum(126, null), Lcom_google_gwt_dom_client_Style$Position$1_2_classLit = createForEnum(128, null), Lcom_google_gwt_dom_client_Style$Position$2_2_classLit = createForEnum(129, null), Lcom_google_gwt_dom_client_Style$Position$3_2_classLit = createForEnum(130, null), Lcom_google_gwt_dom_client_Style$Position$4_2_classLit = createForEnum(131, null), Lcom_google_gwt_dom_client_Style$Visibility$1_2_classLit = createForEnum(143, null), Lcom_google_gwt_dom_client_Style$Visibility$2_2_classLit = createForEnum(144, null), Lcom_google_gwt_dom_client_Style$WhiteSpace$1_2_classLit = createForEnum(146, null), Lcom_google_gwt_dom_client_Style$WhiteSpace$2_2_classLit = createForEnum(147, null), Lcom_google_gwt_dom_client_Style$WhiteSpace$3_2_classLit = createForEnum(148, null), Lcom_google_gwt_dom_client_Style$WhiteSpace$4_2_classLit = createForEnum(149, null), Lcom_google_gwt_dom_client_Style$WhiteSpace$5_2_classLit = createForEnum(150, null), Lpythagoras_f_AbstractTransform_2_classLit = createForClass(681), Lplayn_html_HtmlInternalTransform_2_classLit = createForClass(763), Lpythagoras_f_AffineTransform_2_classLit = createForClass(680), Lplayn_core_StockInternalTransform_2_classLit = createForClass(679), Lplayn_core_canvas_ImmediateLayerCanvas_2_classLit = createForClass(696), Lplayn_html_HtmlGL20$VertexAttribArrayState_2_classLit = createForClass(750), _3Lplayn_html_HtmlGL20$VertexAttribArrayState_2_classLit = createForArray(855, Lplayn_html_HtmlGL20$VertexAttribArrayState_2_classLit), Lplayn_html_HtmlGL20_2_classLit = createForClass(749), Lplayn_html_HtmlGL20$WebGLObjectType_2_classLit = createForEnum(751, values_31), _3Lplayn_html_HtmlGL20$WebGLObjectType_2_classLit = createForArray(856, Lplayn_html_HtmlGL20$WebGLObjectType_2_classLit), Lplayn_core_gl_ImmediateLayerGL_2_classLit = createForClass(718), Lplayn_core_gl_AbstractSurfaceGL_2_classLit = createForClass(700), Lplayn_core_gl_ImmediateLayerGL$ImmediateSurfaceGL_2_classLit = createForClass(720), Lplayn_core_gl_ImmediateLayerGL$1_2_classLit = createForClass(719), Lplayn_core_Dispatcher$CaptureState_2_classLit = createForClass(649), Lplayn_core_Key_2_classLit = createForEnum(656, values_28), _3Lplayn_core_Key_2_classLit = createForArray(857, Lplayn_core_Key_2_classLit), Lim_bci_jnuit_controls_Pointer_2_classLit = createForClass(263), Lplayn_core_AbstractFont_2_classLit = createForClass(640), Lplayn_html_HtmlFont_2_classLit = createForClass(747), _3Lim_bci_jnuit_NuitLocale_2_classLit = createForArray(858, Lim_bci_jnuit_NuitLocale_2_classLit), Ljava_util_EnumMap_2_classLit = createForClass(562), Ljava_util_EnumMap$EntrySet_2_classLit = createForClass(563), Ljava_util_EnumMap$EntrySetIterator_2_classLit = createForClass(564), Ljava_util_EnumMap$MapEntry_2_classLit = createForClass(565), Lim_bci_jnuit_playn_controls_KeyControl_2_classLit = createForClass(279), Lim_bci_jnuit_controls_NullControl_2_classLit = createForClass(262), Ljava_util_AbstractList_2_classLit = createForClass(20), Ljava_util_Arrays$ArrayList_2_classLit = createForClass(551), Ljava_util_AbstractList$IteratorImpl_2_classLit = createForClass(543), Ljava_util_AbstractList$ListIteratorImpl_2_classLit = createForClass(544), Ljava_lang_UnsupportedOperationException_2_classLit = createForClass(529), Lplayn_core_GroupLayerImpl_2_classLit = createForClass(655), Lplayn_core_gl_GLShader_2_classLit = createForClass(712), Lplayn_core_gl_GLShader$Core_2_classLit = createForClass(713), Lplayn_core_gl_IndexedTrisShader_2_classLit = createForClass(721), Lplayn_core_gl_IndexedTrisShader$ITCore_2_classLit = createForClass(722), Ljava_util_Collections$EmptyList_2_classLit = createForClass(555), Ljava_util_Collections$EmptySet_2_classLit = createForClass(556), Ljava_util_Collections$EmptySet$1_2_classLit = createForClass(557), Ljava_util_Collections$1_2_classLit = createForClass(553), Ljava_util_Collections$3_2_classLit = createForClass(554), Ljava_util_EnumSet_2_classLit = createForClass(566), Ljava_util_EnumSet$EnumSetImpl_2_classLit = createForClass(567), Ljava_util_EnumSet$EnumSetImpl$IteratorImpl_2_classLit = createForClass(568), Lcom_google_gwt_user_client_ui_UIObject_2_classLit = createForClass(188), Lcom_google_gwt_user_client_ui_Widget_2_classLit = createForClass(187), Lcom_google_gwt_user_client_ui_Panel_2_classLit = createForClass(226), Lcom_google_gwt_user_client_ui_ComplexPanel_2_classLit = createForClass(225), Lcom_google_gwt_user_client_ui_AbsolutePanel_2_classLit = createForClass(224), Lcom_google_gwt_user_client_ui_RootPanel_2_classLit = createForClass(231), Lcom_google_gwt_user_client_ui_RootPanel$DefaultRootPanel_2_classLit = createForClass(234), Lcom_google_gwt_user_client_ui_RootPanel$1_2_classLit = createForClass(232), Lcom_google_gwt_user_client_ui_RootPanel$2_2_classLit = createForClass(233), Lcom_google_web_bindery_event_shared_UmbrellaException_2_classLit = createForClass(168), Lcom_google_gwt_event_shared_UmbrellaException_2_classLit = createForClass(167), Lcom_google_gwt_user_client_ui_AttachDetachException_2_classLit = createForClass(227), Lcom_google_gwt_user_client_ui_AttachDetachException$1_2_classLit = createForClass(228), Lcom_google_gwt_user_client_ui_AttachDetachException$2_2_classLit = createForClass(229), Ljava_util_MapEntryImpl_2_classLit = createForClass(573), Lpythagoras_f_AbstractVector_2_classLit = createForClass(809), Lpythagoras_f_Vector_2_classLit = createForClass(817), Lplayn_core_canvas_CanvasSurface_2_classLit = createForClass(693), Lplayn_core_gl_QuadShader_2_classLit = createForClass(723), Lplayn_core_gl_QuadShader$QuadCore_2_classLit = createForClass(724), Lpythagoras_util_NoninvertibleTransformException_2_classLit = createForClass(819), Ljava_util_ArrayList_2_classLit = createForClass(19), Ljava_util_HashSet_2_classLit = createForClass(570), Lcom_google_gwt_event_shared_LegacyHandlerWrapper_2_classLit = createForClass(166), Ljava_lang_IllegalStateException_2_classLit = createForClass(514), Lcom_google_gwt_event_logical_shared_CloseEvent_2_classLit = createForClass(161), Lim_bci_newtonadv_Game_2_classLit = createForClass(317), Ljava_lang_IndexOutOfBoundsException_2_classLit = createForClass(503), Lim_bci_newtonadv_score_GameScore_2_classLit = createForClass(401), Lim_bci_newtonadv_GameProgression_2_classLit = createForClass(318), Lim_bci_newtonadv_game_Sequence$AbstractTransitionException_2_classLit = createForClass(362), Lim_bci_newtonadv_game_Sequence$NormalTransitionException_2_classLit = createForClass(363), Lim_bci_newtonadv_game_Sequence$ResumableTransitionException_2_classLit = createForClass(364), Lim_bci_newtonadv_game_Sequence$ResumeTransitionException_2_classLit = createForClass(365), Lim_bci_newtonadv_ui_OptionsSequence_2_classLit = createForClass(415), Lim_bci_newtonadv_game_LevelSequence_2_classLit = createForClass(334), Lim_bci_newtonadv_game_BonusSequence_2_classLit = createForClass(333), Lim_bci_newtonadv_game_MenuSequence_2_classLit = createForClass(341), Lim_bci_newtonadv_game_MainMenuSequence_2_classLit = createForClass(348), Lim_bci_newtonadv_game_MenuSequence$Button_2_classLit = createForClass(343), Lim_bci_newtonadv_game_MainMenuSequence$1_2_classLit = createForClass(349), Lim_bci_newtonadv_game_MainMenuSequence$2_2_classLit = createForClass(350), Lim_bci_newtonadv_game_MainMenuSequence$3_2_classLit = createForClass(351), Lim_bci_newtonadv_game_MainMenuSequence$4_2_classLit = createForClass(352), Lim_bci_newtonadv_game_MainMenuSequence$5_2_classLit = createForClass(353), Lim_bci_newtonadv_game_FrameTimeInfos_2_classLit = createForClass(338), Ljava_util_NoSuchElementException_2_classLit = createForClass(579), Lplayn_core_gl_GL20Buffer_2_classLit = createForClass(701), Lplayn_core_gl_GL20Buffer$FloatImpl_2_classLit = createForClass(702), Lplayn_core_gl_GL20Buffer$ShortImpl_2_classLit = createForClass(703), _3S_classLit = createForArray(859, S_classLit), Lim_bci_newtonadv_game_StoryboardSequence_2_classLit = createForClass(340), Lim_bci_newtonadv_game_StoryboardSequence$1_2_classLit = createForClass(366), Lim_bci_newtonadv_game_QuestMenuSequence_2_classLit = createForClass(355), Lim_bci_newtonadv_game_QuestMenuSequence$1_2_classLit = createForClass(356), Lim_bci_newtonadv_game_QuestMenuSequence$2_2_classLit = createForClass(357), Lim_bci_newtonadv_game_QuestMenuSequence$3_2_classLit = createForClass(358), Lim_bci_newtonadv_game_FadeSequence_2_classLit = createForClass(337), Lplayn_core_gl_GL20Program_2_classLit = createForClass(706), Lplayn_core_gl_GL20Program$2_2_classLit = createForClass(708), Lplayn_core_gl_GL20Program$5_2_classLit = createForClass(709), Lplayn_core_gl_GL20Program$8_2_classLit = createForClass(710), Lplayn_core_gl_GL20Program$10_2_classLit = createForClass(707), Lim_bci_jnuit_widgets_Widget_2_classLit = createForClass(294), Lim_bci_jnuit_widgets_Stack_2_classLit = createForClass(310), Lim_bci_newtonadv_ui_OptionsGUI_2_classLit = createForClass(408), Lim_bci_jnuit_widgets_Button_2_classLit = createForClass(299), Lim_bci_newtonadv_ui_OptionsGUI$2_2_classLit = createForClass(409), Lim_bci_newtonadv_ui_OptionsGUI$3_2_classLit = createForClass(410), Lim_bci_newtonadv_ui_OptionsGUI$4_2_classLit = createForClass(411), Lim_bci_newtonadv_ui_OptionsGUI$5_2_classLit = createForClass(412), Lim_bci_newtonadv_ui_OptionsGUI$6_2_classLit = createForClass(413), Lim_bci_newtonadv_ui_OptionsGUI$7_2_classLit = createForClass(414), Lim_bci_jnuit_widgets_Widget$1_2_classLit = createForClass(316), Lim_bci_jnuit_widgets_Root_2_classLit = createForClass(309), Lim_bci_newtonadv_game_HelpSequence_2_classLit = createForClass(344), Lim_bci_newtonadv_game_QuestSequence_2_classLit = createForClass(359), Lim_bci_newtonadv_anim_Play_2_classLit = createForClass(327), Lim_bci_newtonadv_anim_AnimationCollection_2_classLit = createForClass(322), Lim_bci_newtonadv_anim_AnimationCollection$NotReadyAnimation_2_classLit = createForClass(323), Lim_bci_newtonadv_anim_AnimationCollection$NotReadyFirstAnimation_2_classLit = createForClass(325), Lim_bci_newtonadv_anim_AnimationCollection$NotReadyAnimationWithName_2_classLit = createForClass(324), Lnet_phys2d_math_Vector2f_2_classLit = createForClass(594), Ljava_nio_Buffer_2_classLit = createForClass(530), Ljava_nio_ByteBuffer_2_classLit = createForClass(533), Ljava_nio_ByteOrder_2_classLit = createForClass(534), Ljava_nio_FloatBuffer_2_classLit = createForClass(535), Ljava_nio_ShortBuffer_2_classLit = createForClass(536), Ljava_util_Random_2_classLit = createForClass(580), Ljava_util_TreeMap_2_classLit = createForClass(404), Ljava_util_TreeMap$EntryIterator_2_classLit = createForClass(582), Ljava_util_TreeMap$EntrySet_2_classLit = createForClass(583), Ljava_util_TreeMap$Node_2_classLit = createForClass(584), _3Ljava_util_TreeMap$Node_2_classLit = createForArray(860, Ljava_util_TreeMap$Node_2_classLit), Ljava_util_TreeMap$State_2_classLit = createForClass(585), Ljava_util_TreeMap$SubMapType_2_classLit = createForEnum(586, values_25), _3Ljava_util_TreeMap$SubMapType_2_classLit = createForArray(861, Ljava_util_TreeMap$SubMapType_2_classLit), Ljava_util_TreeMap$SubMapType$1_2_classLit = createForEnum(587, null), Ljava_util_TreeMap$SubMapType$2_2_classLit = createForEnum(588, null), Ljava_util_TreeMap$SubMapType$3_2_classLit = createForEnum(589, null), Ljava_util_TreeMap$1_2_classLit = createForClass(581), Lim_bci_newtonadv_ui_Themer_2_classLit = createForClass(416), Lim_bci_jnuit_background_ColoredBackground_2_classLit = createForClass(255), Lim_bci_jnuit_widgets_Container_2_classLit = createForClass(293), Lim_bci_jnuit_widgets_Table_2_classLit = createForClass(292), Lim_bci_jnuit_widgets_VideoConfigurator_2_classLit = createForClass(313), Lim_bci_jnuit_widgets_VideoConfigurator$1_2_classLit = createForClass(314), Lim_bci_jnuit_widgets_VideoConfigurator$2_2_classLit = createForClass(315), Lim_bci_jnuit_widgets_AudioConfigurator_2_classLit = createForClass(291), Lim_bci_jnuit_widgets_AudioConfigurator$Volume_2_classLit = createForClass(300), Lim_bci_jnuit_widgets_Select_2_classLit = createForClass(296), Lim_bci_jnuit_widgets_AudioConfigurator$1_2_classLit = createForClass(295), Lim_bci_jnuit_widgets_AudioConfigurator$2_2_classLit = createForClass(297), Lim_bci_jnuit_widgets_AudioConfigurator$3_2_classLit = createForClass(298), Lim_bci_jnuit_widgets_ControlsConfigurator_2_classLit = createForClass(301), Lim_bci_jnuit_widgets_ControlsConfigurator$ControlConfigurator_2_classLit = createForClass(303), Lim_bci_jnuit_widgets_ControlsConfigurator$1_2_classLit = createForClass(302), Lim_bci_jnuit_widgets_ControlsConfigurator$2_2_classLit = createForClass(304), Lim_bci_jnuit_widgets_ControlsConfigurator$3_2_classLit = createForClass(305), Lim_bci_jnuit_widgets_ControlsConfigurator$4_2_classLit = createForClass(306), Lim_bci_jnuit_widgets_ControlsConfigurator$5_2_classLit = createForClass(307), Lcom_esotericsoftware_tablelayout_Cell_2_classLit = createForClass(37), Lim_bci_newtonadv_ui_ModChooser_2_classLit = createForClass(405), Lim_bci_newtonadv_ui_ModChooser$1_2_classLit = createForClass(406), Ljava_util_Date_2_classLit = createForClass(560), Lim_bci_newtonadv_game_special_occasion_SnowLayer$SnowFlake_2_classLit = createForClass(369), _3Lim_bci_newtonadv_game_special_occasion_SnowLayer$SnowFlake_2_classLit = createForArray(862, Lim_bci_newtonadv_game_special_occasion_SnowLayer$SnowFlake_2_classLit), Lim_bci_newtonadv_game_special_occasion_SnowLayer_2_classLit = createForClass(368), Lim_bci_newtonadv_game_special_occasion_NullOccasionLayer_2_classLit = createForClass(367), Lim_bci_newtonadv_game_ScoreSequence_2_classLit = createForClass(360), Lim_bci_newtonadv_game_ScoreSequence$1_2_classLit = createForClass(361), Ljava_util_LinkedHashMap_2_classLit = createForClass(571), Ljava_util_LinkedHashMap$ChainEntry_2_classLit = createForClass(572), Ljava_util_LinkedHashMap$EntrySet_2_classLit = createForClass(574), Ljava_util_LinkedHashMap$EntrySet$EntryIterator_2_classLit = createForClass(575), Lim_bci_newtonadv_platform_playn_core_PlaynTexture_2_classLit = createForClass(393), Ljava_nio_BufferOverflowException_2_classLit = createForClass(531), Lim_bci_jnuit_widgets_Label_2_classLit = createForClass(308), Lim_bci_jnuit_widgets_Toggle_2_classLit = createForClass(312), Lcom_esotericsoftware_tablelayout_BaseTableLayout_2_classLit = createForClass(36), Lim_bci_jnuit_widgets_TableLayout_2_classLit = createForClass(311), Lcom_esotericsoftware_tablelayout_Value_2_classLit = createForClass(39), Lcom_esotericsoftware_tablelayout_FixedValue_2_classLit = createForClass(40), Lim_bci_newtonadv_anim_AnimationFrame_2_classLit = createForClass(326), Lim_bci_newtonadv_game_LevelMenuSequence_2_classLit = createForClass(345), Lim_bci_newtonadv_game_LevelMenuSequence$1_2_classLit = createForClass(346), Lim_bci_newtonadv_game_LevelMenuSequence$2_2_classLit = createForClass(347), Lnet_phys2d_raw_CollisionSpace_2_classLit = createForClass(482), Lnet_phys2d_raw_World_2_classLit = createForClass(481), Lim_bci_newtonadv_world_World_2_classLit = createForClass(480), Lim_bci_newtonadv_util_NewtonColor_2_classLit = createForEnum(421, values_19), Lim_bci_newtonadv_world_World$1_2_classLit = createForClass(483), Lim_bci_newtonadv_world_World$2_2_classLit = createForClass(484), Lim_bci_newtonadv_world_World$4_2_classLit = createForClass(485), Lnet_phys2d_raw_CollisionEvent_2_classLit = createForClass(600), _3Lnet_phys2d_raw_CollisionEvent_2_classLit = createForArray(863, Lnet_phys2d_raw_CollisionEvent_2_classLit), Lim_bci_newtonadv_world_GameOverException_2_classLit = createForClass(455), Lnet_phys2d_raw_Body_2_classLit = createForClass(329), Lim_bci_newtonadv_game_AbstractDrawableBody_2_classLit = createForClass(328), Lim_bci_newtonadv_world_Hero_2_classLit = createForClass(457), Lim_bci_newtonadv_score_LevelScore_2_classLit = createForClass(402), Lim_bci_newtonadv_game_PreloaderFadeSequence_2_classLit = createForClass(354), Lim_bci_newtonadv_game_GameOverSequence_2_classLit = createForClass(339), Lim_bci_newtonadv_game_GameOverSequence$1_2_classLit = createForClass(342), Lim_bci_newtonadv_anim_Animation_2_classLit = createForClass(321), Lplayn_core_gl_AbstractImageGL_2_classLit = createForClass(698), Lplayn_core_gl_ImageGL_2_classLit = createForClass(717), Lplayn_html_HtmlImage_2_classLit = createForClass(746), Lplayn_html_HtmlImage$1_2_classLit = createForClass(759), Lplayn_html_HtmlImage$2_2_classLit = createForClass(760), Lplayn_core_gl_AbstractImageGL$1_2_classLit = createForClass(699), Lim_bci_jnuit_focus_ColoredRectangleFocusCursor_2_classLit = createForClass(265), Lim_bci_jnuit_text_TextColor_2_classLit = createForClass(290), Lim_bci_jnuit_controls_ControlActivatedDetector_2_classLit = createForClass(261), Lim_bci_jnuit_border_ColoredBorder_2_classLit = createForClass(257), Lim_bci_newtonadv_ui_TweaksGUI_2_classLit = createForClass(417), Lim_bci_newtonadv_ui_TweaksGUI$1_2_classLit = createForClass(418), Lim_bci_newtonadv_game_time_TimedAction_2_classLit = createForClass(372), Lim_bci_newtonadv_game_time_OneShotTimedAction_2_classLit = createForClass(371), Lim_bci_newtonadv_game_EntityList_2_classLit = createForClass(336), Lim_bci_newtonadv_score_QuestScore_2_classLit = createForClass(403), Lim_bci_newtonadv_LevelProgression_2_classLit = createForClass(319), Lim_bci_newtonadv_QuestProgression_2_classLit = createForClass(320), Lnet_phys2d_raw_BodyList_2_classLit = createForClass(598), Lnet_phys2d_raw_StaticBody_2_classLit = createForClass(331), Lim_bci_newtonadv_game_AbstractDrawableStaticBody_2_classLit = createForClass(330), Lim_bci_newtonadv_world_Door_2_classLit = createForClass(451), Lim_bci_newtonadv_world_DoorToBonusWorld_2_classLit = createForClass(452), Lplayn_core_AbstractSound_2_classLit = createForClass(644), Lplayn_html_HtmlSound_2_classLit = createForClass(795), Lplayn_html_HtmlSound$1_2_classLit = createForClass(796), Lplayn_core_json_JsonParserException_2_classLit = createForClass(727), Lim_bci_jnuit_background_NullBackground_2_classLit = createForClass(256), Lim_bci_jnuit_border_NullBorder_2_classLit = createForClass(258), Lim_bci_newtonadv_game_AbstractEntity_2_classLit = createForClass(332), Lim_bci_newtonadv_world_ScoreVisualIndicator_2_classLit = createForClass(472), Lnet_phys2d_raw_shapes_AABox_2_classLit = createForClass(631), Lim_bci_newtonadv_world_LosedApple_2_classLit = createForClass(462), Lnet_phys2d_math_Matrix2f_2_classLit = createForClass(593), Lim_bci_newtonadv_world_AnimatedPlatform_2_classLit = createForClass(426), Lim_bci_newtonadv_world_Blocker_2_classLit = createForClass(433), Lim_bci_newtonadv_world_StaticPlatform_2_classLit = createForClass(474), Lim_bci_newtonadv_game_DrawableComparator_2_classLit = createForClass(335), Lim_bci_newtonadv_world_Key_2_classLit = createForClass(458), Lcom_allen_1sauer_gwt_voices_client_Sound$LoadState_2_classLit = createForEnum(10, values_0), _3Lcom_allen_1sauer_gwt_voices_client_Sound$LoadState_2_classLit = createForArray(864, Lcom_allen_1sauer_gwt_voices_client_Sound$LoadState_2_classLit), Lplayn_core_Json$Array_2_classLit = createForInterface(), Lplayn_core_Json$Object_2_classLit = createForInterface(), Lplayn_core_json_JsonTypedArray_2_classLit = createForClass(728), Lplayn_core_json_JsonTypedArray$1_2_classLit = createForClass(729), Lplayn_core_json_JsonTypedArray$2_2_classLit = createForClass(730), Lplayn_core_json_JsonTypedArray$3_2_classLit = createForClass(731), Lplayn_core_json_JsonTypedArray$4_2_classLit = createForClass(732), Lplayn_core_json_JsonTypedArray$5_2_classLit = createForClass(733), Lplayn_core_json_JsonTypedArray$6_2_classLit = createForClass(734), Lplayn_core_json_JsonTypedArray$7_2_classLit = createForClass(735), Lplayn_core_json_JsonTypedArray$8_2_classLit = createForClass(736), Lcom_esotericsoftware_tablelayout_CellValue_2_classLit = createForClass(38), Lcom_esotericsoftware_tablelayout_MinWidthValue_2_classLit = createForClass(44), Lcom_esotericsoftware_tablelayout_MinHeightValue_2_classLit = createForClass(43), Lcom_esotericsoftware_tablelayout_PrefWidthValue_2_classLit = createForClass(46), Lcom_esotericsoftware_tablelayout_PrefHeightValue_2_classLit = createForClass(45), Lcom_esotericsoftware_tablelayout_MaxWidthValue_2_classLit = createForClass(42), Lcom_esotericsoftware_tablelayout_MaxHeightValue_2_classLit = createForClass(41), Lnet_phys2d_raw_JointList_2_classLit = createForClass(602), Lnet_phys2d_raw_Contact_2_classLit = createForClass(601), _3Lnet_phys2d_raw_Contact_2_classLit = createForArray(865, Lnet_phys2d_raw_Contact_2_classLit), Lnet_phys2d_raw_Arbiter_2_classLit = createForClass(595), Lnet_phys2d_raw_ArbiterList_2_classLit = createForClass(596), Lim_bci_newtonadv_world_TmxLoader_2_classLit = createForClass(478), Lnet_phys2d_math_ROVector2f_2_classLit = createForInterface(), _3Lnet_phys2d_math_ROVector2f_2_classLit = createForArray(866, Lnet_phys2d_math_ROVector2f_2_classLit), _3Lnet_phys2d_math_Vector2f_2_classLit = createForArray(867, Lnet_phys2d_math_Vector2f_2_classLit), Lim_bci_newtonadv_util_AbsoluteAABox_2_classLit = createForClass(419), Lim_bci_newtonadv_world_StaticQuadSpaceStrategy_2_classLit = createForClass(475), Lim_bci_newtonadv_world_StaticQuadSpaceStrategy$Space_2_classLit = createForClass(476), Lplayn_core_AbstractTextLayout_2_classLit = createForClass(645), Lplayn_html_HtmlTextLayout_2_classLit = createForClass(798), Ljava_util_Comparators$1_2_classLit = createForClass(559), Ljava_util_AbstractSequentialList_2_classLit = createForClass(549), Ljava_util_LinkedList_2_classLit = createForClass(576), Ljava_util_LinkedList$ListIteratorImpl_2_classLit = createForClass(577), Ljava_util_LinkedList$Node_2_classLit = createForClass(578), Lim_bci_tmxloader_TmxMap_2_classLit = createForClass(492), _3Lim_bci_newtonadv_util_NewtonColor_2_classLit = createForArray(868, Lim_bci_newtonadv_util_NewtonColor_2_classLit), Lim_bci_newtonadv_util_MultidimensionnalIterator_2_classLit = createForClass(420), Lim_bci_tmxloader_TmxLayer_2_classLit = createForClass(490), Lim_bci_tmxloader_TmxTileInstance_2_classLit = createForClass(497), _3Lim_bci_tmxloader_TmxTileInstance_2_classLit = createForArray(869, Lim_bci_tmxloader_TmxTileInstance_2_classLit), _3_3Lim_bci_tmxloader_TmxTileInstance_2_classLit = createForArray(870, _3Lim_bci_tmxloader_TmxTileInstance_2_classLit), Lplayn_html_HtmlFontMetrics_2_classLit = createForClass(748), Lplayn_html_HtmlCanvasImage_2_classLit = createForClass(745), Lplayn_html_HtmlCanvas_2_classLit = createForClass(744), Lnet_phys2d_raw_shapes_AbstractShape_2_classLit = createForClass(632), Lnet_phys2d_raw_shapes_Circle_2_classLit = createForClass(634), _3_3I_classLit = createForArray(871, _3I_classLit), Lim_bci_tmxloader_TmxTileInstanceEffect_2_classLit = createForEnum(498, values_24), Lim_bci_newtonadv_platform_playn_core_PlaynStaticPlatformDrawer_2_classLit = createForClass(392), Lim_bci_newtonadv_world_Mummy_2_classLit = createForClass(466), Lim_bci_newtonadv_world_Bat_2_classLit = createForClass(432), Lim_bci_newtonadv_world_PickableObject_2_classLit = createForClass(429), Lim_bci_newtonadv_world_Apple_2_classLit = createForClass(428), Lim_bci_newtonadv_world_Coin_2_classLit = createForClass(444), Lim_bci_newtonadv_world_Letter_2_classLit = createForClass(461), Lim_bci_newtonadv_world_WorldMap_2_classLit = createForClass(486), Lim_bci_newtonadv_world_Compass_2_classLit = createForClass(447), Lim_bci_newtonadv_world_Cloud_2_classLit = createForClass(442), Lim_bci_newtonadv_world_PikesComponent_2_classLit = createForClass(469), Lim_bci_newtonadv_world_PikesComponent$DangerousSide_2_classLit = createForEnum(470, values_22), _3Lim_bci_newtonadv_world_PikesComponent$DangerousSide_2_classLit = createForArray(872, Lim_bci_newtonadv_world_PikesComponent$DangerousSide_2_classLit), Lim_bci_newtonadv_world_Pikes_2_classLit = createForClass(468), Lim_bci_newtonadv_world_StaticPikes_2_classLit = createForClass(473), Lim_bci_newtonadv_world_Cannon_2_classLit = createForClass(440), Lim_bci_newtonadv_world_Cannon$Orientation_2_classLit = createForEnum(441, values_21), _3Lim_bci_newtonadv_world_Cannon$Orientation_2_classLit = createForArray(873, Lim_bci_newtonadv_world_Cannon$Orientation_2_classLit), Lim_bci_newtonadv_world_MobilePikeAnchor_2_classLit = createForClass(464), Lim_bci_newtonadv_world_MobilePikes_2_classLit = createForClass(465), Lnet_phys2d_raw_BasicJoint_2_classLit = createForClass(597), Lim_bci_newtonadv_world_AxeAnchor_2_classLit = createForClass(431), Lim_bci_newtonadv_world_Axe_2_classLit = createForClass(430), Lim_bci_newtonadv_world_BouncePlatform_2_classLit = createForClass(439), Lim_bci_newtonadv_world_Activator_2_classLit = createForClass(427), Lim_bci_newtonadv_world_MemoryActivator_2_classLit = createForClass(463), Lim_bci_newtonadv_world_LaserBlocker_2_classLit = createForClass(460), Lim_bci_newtonadv_world_Accelerator_2_classLit = createForClass(425), Lim_bci_newtonadv_world_MovingPlatform_2_classLit = createForClass(450), Lim_bci_newtonadv_world_DangerousMovingPlatform_2_classLit = createForClass(449), Lim_bci_newtonadv_world_Teleporter_2_classLit = createForClass(477), Lim_bci_newtonadv_world_Colorizer_2_classLit = createForClass(446), Lim_bci_newtonadv_world_ColoredPlatform_2_classLit = createForClass(445), Lim_bci_newtonadv_world_KeyLock_2_classLit = createForClass(459), Lim_bci_newtonadv_world_HelpSign_2_classLit = createForClass(456), Lim_bci_newtonadv_world_Clue_2_classLit = createForClass(443), Lim_bci_newtonadv_world_Bomb_2_classLit = createForClass(434), Lim_bci_newtonadv_world_BombHole_2_classLit = createForClass(435), Lim_bci_newtonadv_world_Crate_2_classLit = createForClass(448), Lim_bci_newtonadv_world_Boss_2_classLit = createForClass(436), Lnet_phys2d_raw_shapes_Line_2_classLit = createForClass(637), Lnet_phys2d_raw_shapes_Polygon_2_classLit = createForClass(636), Lnet_phys2d_raw_shapes_ConvexPolygon_2_classLit = createForClass(635), Lnet_phys2d_raw_shapes_Box_2_classLit = createForClass(633), Lim_bci_newtonadv_world_BossHand_2_classLit = createForClass(437), Lim_bci_newtonadv_world_BossHand$Side_2_classLit = createForEnum(438, values_20), _3Lim_bci_newtonadv_world_BossHand$Side_2_classLit = createForArray(874, Lim_bci_newtonadv_world_BossHand$Side_2_classLit), Lpythagoras_f_RectangularShape_2_classLit = createForClass(808), Lpythagoras_f_AbstractRectangle_2_classLit = createForClass(807), Lpythagoras_f_Rectangle_2_classLit = createForClass(815), Lcom_allen_1sauer_gwt_voices_client_AbstractSound_2_classLit = createForClass(3), Lcom_allen_1sauer_gwt_voices_client_FlashSound_2_classLit = createForClass(4), Lcom_allen_1sauer_gwt_voices_client_FlashSound$1_2_classLit = createForClass(5), Lcom_allen_1sauer_gwt_voices_client_FlashSound$2_2_classLit = createForClass(6), Lcom_allen_1sauer_gwt_voices_client_NativeSound_2_classLit = createForClass(9), Lim_bci_tmxloader_TmxTile_2_classLit = createForClass(496), Ljava_lang_NumberFormatException_2_classLit = createForClass(523), Lim_bci_tmxloader_TmxFrame_2_classLit = createForClass(488), Lim_bci_tmxloader_TmxImage_2_classLit = createForClass(489), Lcom_allen_1sauer_gwt_voices_client_Html5Sound_2_classLit = createForClass(7), Lcom_allen_1sauer_gwt_voices_client_Html5Sound$1_2_classLit = createForClass(8), Lcom_allen_1sauer_gwt_voices_client_ui_FlashMovie_2_classLit = createForClass(23), Lcom_allen_1sauer_gwt_voices_client_ui_VoicesMovie_2_classLit = createForClass(24), Lcom_allen_1sauer_gwt_voices_client_ui_VoicesMovie$1_2_classLit = createForClass(25), Lcom_allen_1sauer_gwt_voices_client_WebAudioSound_2_classLit = createForClass(15), Lim_bci_tmxloader_TmxProperty_2_classLit = createForClass(495), Lim_bci_newtonadv_platform_playn_core_PlaynStaticPlatformDrawable_2_classLit = createForClass(390), Lim_bci_newtonadv_platform_playn_core_PlaynStaticPlatformDrawable$1_2_classLit = createForClass(391), Lim_bci_newtonadv_world_PickedUpObject_2_classLit = createForClass(467), Lim_bci_newtonadv_game_time_PingPongTimedAction_2_classLit = createForClass(373), Lim_bci_newtonadv_world_FireBall_2_classLit = createForClass(454), Lim_bci_newtonadv_world_Explosion_2_classLit = createForClass(453), Lcom_google_gwt_user_client_ui_FocusWidget_2_classLit = createForClass(186), Lcom_google_gwt_media_client_MediaBase_2_classLit = createForClass(185), Lcom_google_gwt_media_client_Audio_2_classLit = createForClass(184), Lcom_google_gwt_media_client_Audio$AudioElementSupportDetector_2_classLit = createForClass(190), Lcom_google_gwt_media_client_Audio$AudioElementSupportDetectedMaybe_2_classLit = createForClass(189), Lcom_allen_1sauer_gwt_voices_client_ui_impl_FlashMovieImpl_2_classLit = createForClass(26), Lcom_allen_1sauer_gwt_voices_client_ui_impl_FlashMovieImplPlayN_2_classLit = createForClass(28), Lcom_allen_1sauer_gwt_voices_client_handler_SoundHandlerCollection_2_classLit = createForClass(18), Ljava_util_EventObject_2_classLit = createForClass(17), Lcom_allen_1sauer_gwt_voices_client_handler_SoundLoadStateChangeEvent_2_classLit = createForClass(22), Lcom_github_asilvestre_jpurexml_XmlParseException_2_classLit = createForClass(50), Lcom_github_asilvestre_jpurexml_XmlDoc_2_classLit = createForClass(49), Lcom_github_asilvestre_jpurexml_XmlParser$TagHeaderStates_2_classLit = createForEnum(null, values_8), _3Lcom_github_asilvestre_jpurexml_XmlParser$TagHeaderStates_2_classLit = createForArray(875, Lcom_github_asilvestre_jpurexml_XmlParser$TagHeaderStates_2_classLit), _3_3Lcom_github_asilvestre_jpurexml_XmlParser$TagHeaderStates_2_classLit = createForArray(876, _3Lcom_github_asilvestre_jpurexml_XmlParser$TagHeaderStates_2_classLit), Lcom_github_asilvestre_jpurexml_XmlParser$AttrStates_2_classLit = createForEnum(null, values_4), _3Lcom_github_asilvestre_jpurexml_XmlParser$AttrStates_2_classLit = createForArray(877, Lcom_github_asilvestre_jpurexml_XmlParser$AttrStates_2_classLit), _3_3Lcom_github_asilvestre_jpurexml_XmlParser$AttrStates_2_classLit = createForArray(878, _3Lcom_github_asilvestre_jpurexml_XmlParser$AttrStates_2_classLit), Lcom_github_asilvestre_jpurexml_XmlParser$TagContentStates_2_classLit = createForEnum(null, values_6), _3Lcom_github_asilvestre_jpurexml_XmlParser$TagContentStates_2_classLit = createForArray(879, Lcom_github_asilvestre_jpurexml_XmlParser$TagContentStates_2_classLit), _3_3Lcom_github_asilvestre_jpurexml_XmlParser$TagContentStates_2_classLit = createForArray(880, _3Lcom_github_asilvestre_jpurexml_XmlParser$TagContentStates_2_classLit), Lcom_github_asilvestre_jpurexml_XmlParser$StringPair_2_classLit = createForClass(57), _3Lcom_github_asilvestre_jpurexml_XmlParser$StringPair_2_classLit = createForArray(881, Lcom_github_asilvestre_jpurexml_XmlParser$StringPair_2_classLit), Lcom_github_asilvestre_jpurexml_XmlParser$TagHeaderActions_2_classLit = createForEnum(61, values_7), _3Lcom_github_asilvestre_jpurexml_XmlParser$TagHeaderActions_2_classLit = createForArray(882, Lcom_github_asilvestre_jpurexml_XmlParser$TagHeaderActions_2_classLit), Lcom_github_asilvestre_jpurexml_XmlParser$TagHeaderParserData_2_classLit = createForClass(62), Lcom_github_asilvestre_jpurexml_XmlParser$AttrActions_2_classLit = createForEnum(54, values_3), _3Lcom_github_asilvestre_jpurexml_XmlParser$AttrActions_2_classLit = createForArray(883, Lcom_github_asilvestre_jpurexml_XmlParser$AttrActions_2_classLit), Lcom_github_asilvestre_jpurexml_XmlParser$AttrParserData_2_classLit = createForClass(55), Lcom_github_asilvestre_jpurexml_XmlParser$TagContentActions_2_classLit = createForEnum(58, values_5), _3Lcom_github_asilvestre_jpurexml_XmlParser$TagContentActions_2_classLit = createForArray(884, Lcom_github_asilvestre_jpurexml_XmlParser$TagContentActions_2_classLit), Lcom_github_asilvestre_jpurexml_XmlParser$TagContentParserData_2_classLit = createForClass(59), Lcom_github_asilvestre_jpurexml_XmlTag_2_classLit = createForClass(65), Lim_bci_tmxloader_TmxTileset_2_classLit = createForClass(499), Lnet_phys2d_raw_collide_FeaturePair_2_classLit = createForClass(615), Lim_bci_newtonadv_world_UsedKey_2_classLit = createForClass(479), Lpythagoras_f_AbstractDimension_2_classLit = createForClass(805), Lpythagoras_f_Dimension_2_classLit = createForClass(810), Lcom_allen_1sauer_gwt_voices_client_ui_impl_FlashMovieImplIE6_2_classLit = createForClass(27), Lcom_allen_1sauer_gwt_voices_client_ui_impl_FlashMovieImplStandard_2_classLit = createForClass(30), Lcom_allen_1sauer_gwt_voices_client_ui_impl_FlashMovieImplSafari_2_classLit = createForClass(29), Lcom_github_asilvestre_jpurexml_XmlPrologue_2_classLit = createForClass(64), Lim_bci_tmxloader_TmxMapOrientation_2_classLit = createForEnum(493, values_23), _3Lim_bci_tmxloader_TmxMapOrientation_2_classLit = createForArray(885, Lim_bci_tmxloader_TmxMapOrientation_2_classLit), _3Lim_bci_tmxloader_TmxTileInstanceEffect_2_classLit = createForArray(886, Lim_bci_tmxloader_TmxTileInstanceEffect_2_classLit), Lim_bci_tmxloader_TmxData_2_classLit = createForClass(487), Lnet_phys2d_raw_collide_ColliderUnavailableException_2_classLit = createForClass(608), Lcom_google_gwt_event_dom_client_DomEvent_2_classLit = createForClass(152), Lcom_google_gwt_event_dom_client_EndedEvent_2_classLit = createForClass(158), Lcom_google_gwt_event_dom_client_DomEvent$Type_2_classLit = createForClass(155), Lcom_google_gwt_user_client_ui_WidgetCollection_2_classLit = createForClass(235), _3Lcom_google_gwt_user_client_ui_Widget_2_classLit = createForArray(887, Lcom_google_gwt_user_client_ui_Widget_2_classLit), Lcom_google_gwt_user_client_ui_WidgetCollection$WidgetIterator_2_classLit = createForClass(236), Lcom_allen_1sauer_gwt_voices_client_handler_PlaybackCompleteEvent_2_classLit = createForClass(16), Lnet_phys2d_raw_collide_CircleCircleCollider_2_classLit = createForClass(606), Lnet_phys2d_raw_collide_SwapCollider_2_classLit = createForClass(630), Lnet_phys2d_raw_collide_BoxCircleCollider_2_classLit = createForClass(605), _3Lnet_phys2d_raw_shapes_Line_2_classLit = createForArray(888, Lnet_phys2d_raw_shapes_Line_2_classLit), Lnet_phys2d_raw_collide_LineCircleCollider_2_classLit = createForClass(622), Lnet_phys2d_raw_collide_PolygonPolygonCollider_2_classLit = createForClass(625), Lnet_phys2d_raw_collide_PolygonCircleCollider_2_classLit = createForClass(629), Lnet_phys2d_raw_collide_Intersection_2_classLit = createForClass(616), _3Lnet_phys2d_raw_collide_Intersection_2_classLit = createForArray(889, Lnet_phys2d_raw_collide_Intersection_2_classLit), _3_3Lnet_phys2d_raw_collide_Intersection_2_classLit = createForArray(890, _3Lnet_phys2d_raw_collide_Intersection_2_classLit), Lnet_phys2d_raw_collide_BoxBoxCollider_2_classLit = createForClass(603), Lnet_phys2d_raw_collide_BoxBoxCollider$ClipVertex_2_classLit = createForClass(604), _3Lnet_phys2d_raw_collide_BoxBoxCollider$ClipVertex_2_classLit = createForArray(891, Lnet_phys2d_raw_collide_BoxBoxCollider$ClipVertex_2_classLit), Lnet_phys2d_raw_collide_LineBoxCollider_2_classLit = createForClass(621), Lnet_phys2d_raw_collide_PolygonBoxCollider_2_classLit = createForClass(628), Lnet_phys2d_raw_collide_LineLineCollider_2_classLit = createForClass(623), Lnet_phys2d_raw_collide_LinePolygonCollider_2_classLit = createForClass(624), Ljava_nio_BufferUnderflowException_2_classLit = createForClass(532), Lcom_google_gwt_event_dom_client_PrivateMap_2_classLit = createForClass(159), Ljava_util_TreeSet_2_classLit = createForClass(590), Lplayn_html_HtmlPattern_2_classLit = createForClass(783), Lnet_phys2d_raw_collide_EdgeSweep_2_classLit = createForClass(609), Lnet_phys2d_raw_collide_EdgeSweep$ProjectedVertex_2_classLit = createForClass(614), Lnet_phys2d_raw_collide_EdgeSweep$CurrentEdges_2_classLit = createForClass(610), Lnet_phys2d_raw_collide_EdgeSweep$CurrentEdges$LinkedEdgeList_2_classLit = createForClass(611), Lnet_phys2d_raw_collide_EdgeSweep$EdgePairs_2_classLit = createForClass(612), Lnet_phys2d_raw_collide_EdgeSweep$EdgePairs$EdgePair_2_classLit = createForClass(613), Lnet_phys2d_raw_collide_IntersectionGatherer_2_classLit = createForClass(617), Lnet_phys2d_raw_collide_IntersectionGatherer$SortableIntersection_2_classLit = createForClass(620), _3Lnet_phys2d_raw_collide_IntersectionGatherer$SortableIntersection_2_classLit = createForArray(892, Lnet_phys2d_raw_collide_IntersectionGatherer$SortableIntersection_2_classLit), Lnet_phys2d_raw_collide_IntersectionGatherer$IntersectionComparator_2_classLit = createForClass(618), Lnet_phys2d_raw_collide_IntersectionGatherer$PointerTableComparator_2_classLit = createForClass(619), Lplayn_html_HtmlPath_2_classLit = createForClass(782), Lnet_phys2d_raw_collide_PenetrationSweep_2_classLit = createForClass(626), Lnet_phys2d_raw_collide_PenetrationSweep$ContourWalker_2_classLit = createForClass(627), Ljava_lang_ArrayIndexOutOfBoundsException_2_classLit = createForClass(502);
$stats && $stats({moduleName:'playn',sessionId:$sessionId,subSystem:'startup',evtGroup:'moduleStartup',millis:(new Date()).getTime(),type:'moduleEvalEnd'});
if ($wnd.playn) $wnd.playn.onScriptLoad();
--></script></body></html>
